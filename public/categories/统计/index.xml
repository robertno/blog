<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>统计 | Bionew</title>
    <link>/categories/%E7%BB%9F%E8%AE%A1/</link>
      <atom:link href="/categories/%E7%BB%9F%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    <description>统计</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh</language><copyright>©`2020`</copyright><lastBuildDate>Thu, 12 Mar 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:square]</url>
      <title>统计</title>
      <link>/categories/%E7%BB%9F%E8%AE%A1/</link>
    </image>
    
    <item>
      <title>R语言初学者指南-第四章</title>
      <link>/post/a-beginner-guide-to-r-chapter4/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/a-beginner-guide-to-r-chapter4/</guid>
      <description>


&lt;div id=&#34;第四章-简单的函数&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第四章 简单的函数&lt;/h1&gt;
&lt;p&gt;今天开始第四章。如题所见，就是&lt;strong&gt;简单&lt;/strong&gt;的函数。
R与其说是一门编程语言，在我看来，它不是，编程只是为了让它更方便快捷，它的初衷，就是统计分析作图。而函数这个概念，在各个编程语言中都出现过，而且地位都不低。这是因为，函数就可以让我们的操作简单起来，算平均值就来个mean()，不用把所有数字加起来再除以个数。
下面看书上的第一节。&lt;/p&gt;
&lt;div id=&#34;tapply函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.1 tapply函数&lt;/h2&gt;
&lt;p&gt;书上的逻辑是这样的：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;先介绍了一下所用的数据集Vrg，是一个对两个温带（美国黄石国家公园和国家野牛保护区）的草原数据的监控分析。这个研究的目的是确定某段时间丛生禾草群落的生物多样性是否发生变化，如果变了，是否与环境因素有关。生物多样性用物种丰富度来定义也就是下面数据展示中的变量&lt;strong&gt;R&lt;/strong&gt;，即每个地点的不同种群数量。研究识别出大约90个物种，数据来自于8个时间截面（也就是变量&lt;strong&gt;Transect&lt;/strong&gt;，对，没看错，中文版就是时间截面），每个截面大约是4-10年，总共选取58个观测值：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Veg &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\Vegetation2.txt&amp;quot;,
                  header = TRUE)
head(Veg, n=20L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    TransectName Samples Transect Time  R ROCK LITTER ML BARESOIL FallPrec
## 1       A_22_58       1        1 1958  8 27.0   30.0  0       26    30.22
## 2       A_22_62       2        1 1962  6 26.0   20.0  0       28    99.56
## 3       A_22_67       3        1 1967  8 30.0   24.0  0       30    43.43
## 4       A_22_74       4        1 1974  8 18.0   35.0  0       16    54.86
## 5       A_22_81       5        1 1981 10 23.0   22.0  4        9    24.38
## 6       A_22_94       6        1 1994  7 26.0   26.0  0       23    10.16
## 7       A_22_02       7        1 2002  6 39.0   19.0  4       19    34.29
## 8       C_22_58       8        2 1958  5 25.0   26.0  0       33    30.22
## 9       C_22_62       9        2 1962  8 24.0   24.0  2       29    99.56
## 10      C_22_67      10        2 1967  6 21.0   16.0  1       41    43.43
## 11      C_22_74      11        2 1974  6 18.0   25.0  0       33    54.86
## 12      C_22_81      12        2 1981  6 19.0   28.0  0       14    24.38
## 13      C_22_94      13        2 1994  6 10.5   41.5  0       29    10.16
## 14      C_22_02      14        2 2002  6 26.0   18.0  2       42    34.29
## 15      D_12_58      15        3 1958  7 56.0   17.0  0       16    33.78
## 16      D_12_62      16        3 1962 10 45.0    7.0  0       23   143.51
## 17      D_12_67      17        3 1967  8 28.0   14.0  0       37    56.38
## 18      D_12_74      18        3 1974 18 27.0   15.0  0        7    68.32
## 19      D_12_81      19        3 1981 12 10.0   37.0  0        0    57.40
## 20      D_12_89      20        3 1989 11 17.0   17.0  0       33    17.52
##    SprPrec SumPrec WinPrec FallTmax SprTmax SumTmax WinTmax FallTmin SprTmin
## 1    75.43  125.47   39.62    16.96   15.77   25.17    3.47     0.49    0.36
## 2    56.13   94.99  107.44    14.56   15.21   24.85    1.16    -0.18    0.18
## 3    65.02  112.26   76.70    18.44   12.76   25.51    3.09     1.23   -1.86
## 4    58.67   70.35   90.67    17.16   14.00   26.67    2.46     1.43   -0.53
## 5    87.63   81.78   45.97    18.49   14.33   26.02    5.72     1.09    0.75
## 6    57.15   95.25   60.70    17.39   16.91   26.78    3.64     0.28    0.64
## 7    31.49   62.99   43.68    19.29   13.86   26.27    2.54     1.86   -1.37
## 8    75.43  125.47   39.62    16.98   15.79   25.19    3.49     0.51    0.38
## 9    56.13   94.99  107.44    14.58   15.23   24.87    1.18    -0.16    0.19
## 10   65.02  112.26   76.70    18.46   12.78   25.53    3.11     1.25   -1.85
## 11   58.67   70.35   90.67    17.18   14.01   26.68    2.47     1.45   -0.52
## 12   87.63   81.78   45.97    18.51   14.35   26.04    5.74     1.11    0.76
## 13   57.15   95.25   60.70    17.41   16.92   26.80    3.65     0.30    0.65
## 14   31.49   62.99   43.68    19.31   13.88   26.29    2.56     1.88   -1.35
## 15  107.95  181.61  105.15    13.00   11.79   21.12   -0.32    -3.28   -3.43
## 16   73.40  125.73  173.48    10.65   11.25   20.81   -2.58    -3.91   -3.58
## 17   83.05  121.15  117.60    14.42    8.91   21.42   -0.72    -2.55   -5.59
## 18   65.78   88.64  116.84    13.23   10.09   22.59   -1.29    -2.31   -4.30
## 19   87.12  133.09   67.05    14.57   10.42   21.96    1.90    -2.69   -3.03
## 20  101.34  120.14  128.01    15.93   11.00   22.06   -2.77    -2.25   -4.11
##    SumTmin WinTmin PCTSAND PCTSILT PCTOrgC
## 1     6.97   -8.54      24      30 0.03459
## 2     6.40  -10.76      24      30 0.03459
## 3     7.12   -8.50      24      30 0.03459
## 4     7.20   -8.28      24      30 0.03459
## 5     6.90   -7.56      24      30 0.03459
## 6     6.94   -9.21      24      30 0.03459
## 7     6.96   -9.61      24      30 0.03459
## 8     6.99   -8.52      20      34 0.06160
## 9     6.41  -10.74      20      34 0.06160
## 10    7.14   -8.48      20      34 0.06160
## 11    7.22   -8.27      20      34 0.06160
## 12    6.92   -7.54      20      34 0.06160
## 13    6.96   -9.19      20      34 0.06160
## 14    6.98   -9.59      20      34 0.06160
## 15    3.11  -12.23      14      46 0.03630
## 16    2.55  -14.38      14      46 0.03630
## 17    3.25  -12.20      14      46 0.03630
## 18    3.32  -11.92      14      46 0.03630
## 19    3.06  -11.27      14      46 0.03630
## 20    3.81  -14.48      14      46 0.03630&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(Veg)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;TransectName&amp;quot; &amp;quot;Samples&amp;quot;      &amp;quot;Transect&amp;quot;     &amp;quot;Time&amp;quot;         &amp;quot;R&amp;quot;           
##  [6] &amp;quot;ROCK&amp;quot;         &amp;quot;LITTER&amp;quot;       &amp;quot;ML&amp;quot;           &amp;quot;BARESOIL&amp;quot;     &amp;quot;FallPrec&amp;quot;    
## [11] &amp;quot;SprPrec&amp;quot;      &amp;quot;SumPrec&amp;quot;      &amp;quot;WinPrec&amp;quot;      &amp;quot;FallTmax&amp;quot;     &amp;quot;SprTmax&amp;quot;     
## [16] &amp;quot;SumTmax&amp;quot;      &amp;quot;WinTmax&amp;quot;      &amp;quot;FallTmin&amp;quot;     &amp;quot;SprTmin&amp;quot;      &amp;quot;SumTmin&amp;quot;     
## [21] &amp;quot;WinTmin&amp;quot;      &amp;quot;PCTSAND&amp;quot;      &amp;quot;PCTSILT&amp;quot;      &amp;quot;PCTOrgC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(Veg)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    58 obs. of  24 variables:
##  $ TransectName: Factor w/ 58 levels &amp;quot;A_22_02&amp;quot;,&amp;quot;A_22_58&amp;quot;,..: 2 3 4 5 6 7 1 9 10 11 ...
##  $ Samples     : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Transect    : int  1 1 1 1 1 1 1 2 2 2 ...
##  $ Time        : int  1958 1962 1967 1974 1981 1994 2002 1958 1962 1967 ...
##  $ R           : int  8 6 8 8 10 7 6 5 8 6 ...
##  $ ROCK        : num  27 26 30 18 23 26 39 25 24 21 ...
##  $ LITTER      : num  30 20 24 35 22 26 19 26 24 16 ...
##  $ ML          : int  0 0 0 0 4 0 4 0 2 1 ...
##  $ BARESOIL    : num  26 28 30 16 9 23 19 33 29 41 ...
##  $ FallPrec    : num  30.2 99.6 43.4 54.9 24.4 ...
##  $ SprPrec     : num  75.4 56.1 65 58.7 87.6 ...
##  $ SumPrec     : num  125.5 95 112.3 70.3 81.8 ...
##  $ WinPrec     : num  39.6 107.4 76.7 90.7 46 ...
##  $ FallTmax    : num  17 14.6 18.4 17.2 18.5 ...
##  $ SprTmax     : num  15.8 15.2 12.8 14 14.3 ...
##  $ SumTmax     : num  25.2 24.9 25.5 26.7 26 ...
##  $ WinTmax     : num  3.47 1.16 3.09 2.46 5.72 ...
##  $ FallTmin    : num  0.49 -0.18 1.23 1.43 1.09 ...
##  $ SprTmin     : num  0.36 0.18 -1.86 -0.53 0.75 ...
##  $ SumTmin     : num  6.97 6.4 7.12 7.2 6.9 ...
##  $ WinTmin     : num  -8.54 -10.76 -8.5 -8.28 -7.56 ...
##  $ PCTSAND     : int  24 24 24 24 24 24 24 20 20 20 ...
##  $ PCTSILT     : int  30 30 30 30 30 30 30 34 34 34 ...
##  $ PCTOrgC     : num  0.0346 0.0346 0.0346 0.0346 0.0346 ...&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;然后算了下8个时间截面的总体物种平均丰富度m以及每个时间截面的平均丰富度m1-m8，并做出了一个向量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m &amp;lt;- mean(Veg$R)
m1 &amp;lt;- mean(Veg$R[Veg$Transect==1])
m2 &amp;lt;- mean(Veg$R[Veg$Transect==2])
m3 &amp;lt;- mean(Veg$R[Veg$Transect==3])
m4 &amp;lt;- mean(Veg$R[Veg$Transect==4])
m5 &amp;lt;- mean(Veg$R[Veg$Transect==5])
m6 &amp;lt;- mean(Veg$R[Veg$Transect==6])
m7 &amp;lt;- mean(Veg$R[Veg$Transect==7])
m8 &amp;lt;- mean(Veg$R[Veg$Transect==8])
c(m,m1,m2,m3,m4,m5,m6,m7,m8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  9.965517  7.571429  6.142857 10.375000  9.250000 12.375000 11.500000
## [8] 10.500000 11.833333&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;大家也看出来了，算每个时间截面的平均丰富度，要是这么做就太麻烦了，能不能简单点呢。答案是有的，就是tapply函数。先演示一下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tapply(Veg$R, Veg$Transect, mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         1         2         3         4         5         6         7         8 
##  7.571429  6.142857 10.375000  9.250000 12.375000 11.500000 10.500000 11.833333&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#或者
tapply(X = Veg$R, INDEX = Veg$Transect, FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         1         2         3         4         5         6         7         8 
##  7.571429  6.142857 10.375000  9.250000 12.375000 11.500000 10.500000 11.833333&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释一下，看第二个语句就应该明白了。tapply这个函数常用的有3个参数，&lt;strong&gt;x=……&lt;/strong&gt;是告诉它，我要对哪个数据集中的哪个变量操作，&lt;strong&gt;INDEX=……&lt;/strong&gt;是告诉它，我要以什么水平来处理这个&lt;strong&gt;x&lt;/strong&gt;，最后的&lt;strong&gt;FUN=……&lt;/strong&gt;就是告诉它，我要对&lt;strong&gt;x&lt;/strong&gt;做什么运算，可以用内置的函数比如mean，sd什么的，也可以用自己编写的函数。
&lt;strong&gt;注意大小写。&lt;/strong&gt;
同理，标准差sd，方差，长度什么的都可以。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Me &amp;lt;- tapply(Veg$R, Veg$Transect, mean)
Sd &amp;lt;- tapply(Veg$R, Veg$Transect, sd)
Le &amp;lt;- tapply(Veg$R, Veg$Transect, length)
#然后用cbind组合起来
cbind(Me,Sd,Le)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          Me        Sd Le
## 1  7.571429 1.3972763  7
## 2  6.142857 0.8997354  7
## 3 10.375000 3.5831949  8
## 4  9.250000 2.3145502  8
## 5 12.375000 2.1339099  8
## 6 11.500000 2.2677868  8
## 7 10.500000 3.1464265  6
## 8 11.833333 2.7141604  6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一节就没了，书上还分了两个小节…………咋想的。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;sapply函数和lapply函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.2 sapply函数和lapply函数&lt;/h2&gt;
&lt;p&gt;大家可能也发现了，我并没用tapply函数计算整个变量&lt;strong&gt;R&lt;/strong&gt;的平均值。是因为这个整体的平均值比较简单。但是如果要一次性输出Veg数据集中所有数值型变量的平均值呢，该怎么做？
这个工作要交给sapply函数,比如我就想一次性输出变量&lt;strong&gt;R&lt;/strong&gt;：&lt;strong&gt;ROCK&lt;/strong&gt;，&lt;strong&gt;LITTER&lt;/strong&gt;，&lt;strong&gt;ML&lt;/strong&gt;，&lt;strong&gt;BARESOIL&lt;/strong&gt;的平均值：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sapply(Veg[, 5:9], FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         R      ROCK    LITTER        ML  BARESOIL 
##  9.965517 20.991379 22.853448  1.086207 17.594828&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方括号中的&lt;strong&gt;5:9&lt;/strong&gt;指的就是这5个变量。
那这小节标题中的lapply呢，它是干什么的。
还是用例子来说明，我还是计算着5个变量的平均值：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lapply(Veg[, 5:9], FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $R
## [1] 9.965517
## 
## $ROCK
## [1] 20.99138
## 
## $LITTER
## [1] 22.85345
## 
## $ML
## [1] 1.086207
## 
## $BARESOIL
## [1] 17.59483&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现差异了吗？sapply输出结果是个向量，而lapply输出的结果却是个列表（list）。
这里要注意一点，lappy和sapply中包含数据的变量（对，没看错，中文版就是这么写的，其实指的就是那个&lt;strong&gt;x&lt;/strong&gt;）必须是个&lt;strong&gt;数据框&lt;/strong&gt;，要是这么写，就错了：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sapply(cbind(Veg$R, Veg$ROCK, Veg$LITTER, Veg$ML, Veg$BARESOIL), FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1]  8.0  6.0  8.0  8.0 10.0  7.0  6.0  5.0  8.0  6.0  6.0  6.0  6.0  6.0  7.0
##  [16] 10.0  8.0 18.0 12.0 11.0  7.0 10.0  8.0  9.0  6.0 12.0 13.0 10.0  8.0  8.0
##  [31] 13.0 16.0  9.0 14.0 11.0 13.0 11.0 12.0  9.0 10.0 14.0 14.0 10.0 14.0  9.0
##  [46] 12.0 11.0 12.0 14.0  9.0  5.0 12.0  9.0 10.0 16.0 12.0 10.0 14.0 27.0 26.0
##  [61] 30.0 18.0 23.0 26.0 39.0 25.0 24.0 21.0 18.0 19.0 10.5 26.0 56.0 45.0 28.0
##  [76] 27.0 10.0 17.0 26.5 36.0 53.0 59.0 45.0 41.0 35.0 44.0 53.5 59.0 15.0 20.0
##  [91]  4.0  8.0  5.0  4.0  2.0  8.0  5.0  7.0  5.0  6.0  3.0  2.0  3.0  0.0 20.0
## [106]  7.0 11.0  6.0  0.0 15.0 25.0 23.0 14.0 11.0  8.0 13.0 30.0 20.0 24.0 35.0
## [121] 22.0 26.0 19.0 26.0 24.0 16.0 25.0 28.0 41.5 18.0 17.0  7.0 14.0 15.0 37.0
## [136] 17.0 14.0 19.0 10.0  5.0  9.0 12.0 24.0 10.0 18.0  9.0 23.0 21.0 51.0 34.0
## [151] 28.0 30.0 32.0 29.0 32.0 20.0 29.0 19.0 23.0 32.0 22.5 28.0 26.0 29.0 23.0
## [166] 40.0 14.5 21.0 24.0 15.0 15.0 18.0 29.0 26.0  0.0  0.0  0.0  0.0  4.0  0.0
## [181]  4.0  0.0  2.0  1.0  0.0  0.0  0.0  2.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
## [196]  1.0  0.0  3.0  1.0  0.0  0.0  0.0  0.0  5.0  0.0  0.0  0.0  2.0  0.0  5.0
## [211]  0.0  7.0  0.0  0.0  3.0  0.0  0.0  6.0  0.0  2.0  1.0  1.0  0.0  0.0  0.0
## [226]  7.0  2.0  4.0  0.0  0.0  0.0  0.0 26.0 28.0 30.0 16.0  9.0 23.0 19.0 33.0
## [241] 29.0 41.0 33.0 14.0 29.0 42.0 16.0 23.0 37.0  7.0  0.0 33.0 17.5  4.0 20.0
## [256] 13.0 30.0  7.0  3.0 12.0  7.5  5.0 20.0 19.0 13.0  2.0  1.0 11.0 11.0  5.0
## [271] 30.0 37.0 12.0 13.0  9.0  4.0 16.5 17.0 27.0 26.0  0.0  0.0 35.0  7.0 20.0
## [286] 20.0 14.0  4.0 27.0 13.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会输出一个很长的向量，根本不是你想要的。原因就在于cbind输出的不是数据框。
可以改成这样：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sapply(data.frame(cbind(Veg$R, Veg$ROCK, Veg$LITTER, Veg$ML, Veg$BARESOIL)), FUN = mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        X1        X2        X3        X4        X5 
##  9.965517 20.991379 22.853448  1.086207 17.594828&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是对比之前的结果，又有不同的地方，这个语句输出的结果中，丢失了变量标签，只有X1什么的。有两种解决方法，一是在运行sapply之前就生成一个合适的数据框，二是在用cbind结合数据后再用colnames函数来加上标签。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;summary函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.3 summary函数&lt;/h2&gt;
&lt;p&gt;这个函数，看名字就知道了，会输出变量信息。相当于统计概要：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Z &amp;lt;- cbind(Veg$R, Veg$ROCK, Veg$LITTER)
colnames(Z) &amp;lt;- c(&amp;quot;R&amp;quot;, &amp;quot;ROCK&amp;quot;, &amp;quot;LITTER&amp;quot;)
summary(Z)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        R               ROCK           LITTER     
##  Min.   : 5.000   Min.   : 0.00   Min.   : 5.00  
##  1st Qu.: 8.000   1st Qu.: 7.25   1st Qu.:17.00  
##  Median :10.000   Median :18.50   Median :23.00  
##  Mean   : 9.966   Mean   :20.99   Mean   :22.85  
##  3rd Qu.:12.000   3rd Qu.:27.00   3rd Qu.:28.75  
##  Max.   :18.000   Max.   :59.00   Max.   :51.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你看结果，最小值，第一四分位数，中位数，平均值，第三四分位数，最大值都出来了。
下面的语句也可以输出这样的结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(Veg[, c(&amp;quot;R&amp;quot;, &amp;quot;ROCK&amp;quot;, &amp;quot;LITTER&amp;quot;)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        R               ROCK           LITTER     
##  Min.   : 5.000   Min.   : 0.00   Min.   : 5.00  
##  1st Qu.: 8.000   1st Qu.: 7.25   1st Qu.:17.00  
##  Median :10.000   Median :18.50   Median :23.00  
##  Mean   : 9.966   Mean   :20.99   Mean   :22.85  
##  3rd Qu.:12.000   3rd Qu.:27.00   3rd Qu.:28.75  
##  Max.   :18.000   Max.   :59.00   Max.   :51.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(Veg[, c(5, 6, 7)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        R               ROCK           LITTER     
##  Min.   : 5.000   Min.   : 0.00   Min.   : 5.00  
##  1st Qu.: 8.000   1st Qu.: 7.25   1st Qu.:17.00  
##  Median :10.000   Median :18.50   Median :23.00  
##  Mean   : 9.966   Mean   :20.99   Mean   :22.85  
##  3rd Qu.:12.000   3rd Qu.:27.00   3rd Qu.:28.75  
##  Max.   :18.000   Max.   :59.00   Max.   :51.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;道理是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;table函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.4 table函数&lt;/h2&gt;
&lt;p&gt;这里以第二章的习题1和7为例，引入鹿的数据，这些数据来源于不同的农场、月份、年份和性别。这项研究的一个目的就是找出寄生虫&lt;em&gt;E.cervi&lt;/em&gt;的数量和动物长度的关系（对，你没看出，中文版就是动物长度），而这种关系可能与农场、月份、年份和性别都有关系（对，就是关系与什么什么有关系，中文版就是这么写的），为了验证这一点，统计模型中就要有相互作用。但是，如果某些年份没有进行雌性的抽样，或者某些年份一些农场没有提供抽样，就会出现问题，因为这就形成了缺失值。
tabble函数的作用就是用来了解每个农场提供抽样动物的数量，每个性别和年份观察值的数量。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Deer &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\Deer.txt&amp;quot;, header = TRUE, fill=TRUE)
head(Deer, n = 20L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Farm Month Year Sex clas1_4 LCT   KFI  Ecervi Tb
## 1    AL    10    0   1       4 191 20.45  0.0000  0
## 2    AL    10    0   1       4 180 16.40  0.0000  0
## 3    AL    10    0   1       3 192 15.90  2.3800  0
## 4    AL    10    0   1       4 196 17.30  0.0000  0
## 5    AL    10    0   1       4 204    NA  0.0000 NA
## 6    AL    10    0   1       4 190 16.30  0.0000  0
## 7    AL    10    0   1       4 196 22.20  1.2100 NA
## 8    AL    10    0   1       4 200 14.70  0.0000  1
## 9    AL    10    0   1       4 197 13.50  0.8000  0
## 10   AL    10    0   1       4 208 15.15  0.0000  0
## 11   AL    10    0   1       4 216 15.20  0.0000  0
## 12   AL    10    0   1       4 199 14.50  0.9000  1
## 13   AL    10    0   1       4 178 11.55 53.6000  1
## 14   AL    10    0   1       4 206 14.00 14.3700  0
## 15   AL    11    2   2       3 164 24.52  0.0000  0
## 16   AU    12   99   1       3 173    NA 27.7554  0
## 17   AU    12   99   1       3 172 26.00  5.4846  0
## 18   AU    12   99   1       4 184 16.10  5.4846  0
## 19   AU    12   99   1       3 170    NA  0.0000 NA
## 20   AU    12   99   1       3 155    NA  0.0000 NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(Deer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Farm&amp;quot;    &amp;quot;Month&amp;quot;   &amp;quot;Year&amp;quot;    &amp;quot;Sex&amp;quot;     &amp;quot;clas1_4&amp;quot; &amp;quot;LCT&amp;quot;     &amp;quot;KFI&amp;quot;    
## [8] &amp;quot;Ecervi&amp;quot;  &amp;quot;Tb&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(Deer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    1182 obs. of  9 variables:
##  $ Farm   : Factor w/ 28 levels &amp;quot;R\xd1\t02&amp;quot;,&amp;quot;R\xd1\t12&amp;quot;,..: 3 3 3 3 3 3 3 3 3 3 ...
##  $ Month  : int  10 10 10 10 10 10 10 10 10 10 ...
##  $ Year   : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Sex    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ clas1_4: num  4 4 3 4 4 4 4 4 4 4 ...
##  $ LCT    : num  191 180 192 196 204 190 196 200 197 208 ...
##  $ KFI    : num  20.4 16.4 15.9 17.3 NA ...
##  $ Ecervi : num  0 0 2.38 0 0 0 1.21 0 0.8 0 ...
##  $ Tb     : int  0 0 0 0 NA 0 NA 1 0 0 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文中这个命令并没有&lt;strong&gt;fill=TRUE&lt;/strong&gt;这个参数，我为什么要加上呢，因为没有的话会报错：“Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 657 did not have 9 elements”，其实文件中第657行是有9个元素的，所以我加上这个参数让它忽略掉。
变量中，农场分别采用AL、AU等表示，就是字符串，而其他变量都是数值或者整数型向量。那每个农场的观测值数量就可以这么来获得：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Deer$Farm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## R\xd1\t02 R\xd1\t12        AL        AU        BA        BE        CB       CRC 
##        10        15        15        37        98        19        93        16 
##        HB       LCV        LN       MAN        MB        MO        NC        NV 
##        35         2        34        76        41       278        32        35 
##        PA        PN        QM        RF        RO       SAL       SAU        SE 
##        11        45        75        34        44         1         3        26 
##        TI        TN      VISO        VY 
##        21        31        15        40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，有的农场（MO）抽取了278个样本，而有的农场（SAL）仅抽取了1个样本。
然后再看看性别和年份：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(Deer$Sex, Deer$Year)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    
##       0   1   2   3   4   5  99
##   1 100  88 157  72  78  34  21
##   2  76  41 198 116  60  35   0
##   3   0   9   1   0   0   0   0
##   4   0   5   2   0   0   0   0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个结果中横向的0，1，2，3，4，5，99代表2000，2001，2002，2003，2004，2005和1999年，纵向的1和2代表性别。
可以发现在1999年，只有一种性别的鹿被检测了。如果不知道这个，在后续处理中包含性别/年份交互作用项的数据就会报错。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;我们学习了哪些函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.5 我们学习了哪些函数&lt;/h2&gt;
&lt;p&gt;自己去整理去。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;习题&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.6 习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;使用tapply，sapply和lappy函数来计算每个月的平均值：
文件&lt;em&gt;temperature.xls&lt;/em&gt;包含了荷兰海岸线上31个不同地点的温度观测值。抽样开始于1990年，结束于2005年12月，为期16年，根据季节的不同，抽样频率为每月0-4次。
以月为单位计算所有观测点的温度平均值，最终结果应该是一个16×12的变量。再计算每个月的观测值得标准差和数量。&lt;/li&gt;
&lt;li&gt;使用table函数来处理温度数据：
使用习题1中的数据，确定每个观测点的观测值数量。每年记录了多少个观测值？每个观测点每年记录了多少观测值？&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言初学者指南-第三章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97-%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>


&lt;p&gt;时隔半年，我终于又开始写这个博客了。
话不多说，言归正传。&lt;/p&gt;
&lt;div id=&#34;第三章-访问变量和处理数据子集&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第三章 访问变量和处理数据子集&lt;/h1&gt;
&lt;p&gt;在学习上一章导入数据，这一章节来学习对变量的访问和数据子集的处理。&lt;/p&gt;
&lt;div id=&#34;访问数据框变量&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.1 访问数据框变量&lt;/h2&gt;
&lt;p&gt;当确认导入数据无误后，就可以按照自己的需求开始对数据进行删除部分数据，选取部分数据也就是数据子集了。
以上一章的鱿鱼数据为例。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#导入数据，并生成一个数据框
Squid &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\squid.txt&amp;quot;, header = TRUE)
#查看数据框中的变量名
names(Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Sample&amp;quot;   &amp;quot;Year&amp;quot;     &amp;quot;Month&amp;quot;    &amp;quot;Location&amp;quot; &amp;quot;Sex&amp;quot;      &amp;quot;GSI&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;str函数&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.1.1 str函数&lt;/h3&gt;
&lt;p&gt;这个函数主要是告诉我们这个&lt;strong&gt;Squid&lt;/strong&gt;数据框中5个变量的属性。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    2644 obs. of  6 variables:
##  $ Sample  : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Year    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ Month   : int  1 1 1 1 1 1 1 1 1 2 ...
##  $ Location: int  1 3 1 1 1 1 1 3 3 1 ...
##  $ Sex     : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ GSI     : num  10.44 9.83 9.74 9.31 8.99 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如这个结果所示，变量样本、年份、月份、位置和性别都是整数型即&lt;strong&gt;int&lt;/strong&gt;，GSI是数值型即&lt;strong&gt;num&lt;/strong&gt;。
为什么建议在读入数据形成数据框之后，用str函数看一下变量属性呢，因为如果在读入数据时使用了错误的分割符号：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#设定分割符号是&amp;quot;,&amp;quot;
Squid2 &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\squid.txt&amp;quot;, dec = &amp;quot;,&amp;quot;, header = TRUE)
#查看数据框中的变量属性
str(Squid2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    2644 obs. of  6 variables:
##  $ Sample  : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Year    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ Month   : int  1 1 1 1 1 1 1 1 1 2 ...
##  $ Location: int  1 3 1 1 1 1 1 3 3 1 ...
##  $ Sex     : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ GSI     : Factor w/ 2472 levels &amp;quot;0.0064&amp;quot;,&amp;quot;0.007&amp;quot;,..: 1533 2466 2462 2445 2428 2407 2379 2308 2288 2247 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候GSI就是个因子即&lt;strong&gt;factor&lt;/strong&gt;，当后续处理时，R就会报错。
后续我们将对GSI这个变量进行统计分析，值得注意的是，GSI存在于Squid这个数据框中，而没有存在于R的内存中，也就是说，在直接访问GSI的时候，R会报错。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#我注释掉了，因为不这样的话，会卡在报错那里
#GSI&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;函数中的数据参数&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.1.2 函数中的数据参数&lt;/h3&gt;
&lt;p&gt;这一节说的是啥呢，书上翻译的感觉啰嗦，其实就是在有些函数中指定数据集。毕竟你想做个线性回归什么的，你得告诉R要用到哪个数据集。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;N1 &amp;lt;- lm(GSI~factor(Location)+factor(Year),
         data = Squid)
N1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = GSI ~ factor(Location) + factor(Year), data = Squid)
## 
## Coefficients:
##       (Intercept)  factor(Location)2  factor(Location)3  factor(Location)4  
##            1.3939            -2.2178            -0.1417             0.3138  
##     factor(Year)2      factor(Year)3      factor(Year)4  
##            1.3548             0.9564             1.2270&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是有些函数的参数没有这个&lt;strong&gt;data=……&lt;/strong&gt;，比如mean()函数。这个时候可以用attach()函数绑定数据集。这个可以在之后讨论。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;符号&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.1.3 $符号&lt;/h3&gt;
&lt;p&gt;上文说到有的函数没有data参数，还有一个办法是用&lt;strong&gt;$&lt;/strong&gt;符号。比如：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个命令输出结果太多
#Squid$GSI
#于是我用了head显示前几行
head(Squid$GSI)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4432  9.8331  9.7356  9.3107  8.9926  8.7707&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个方法，就是按列选择，观察数据框可以得知，GSI这个变量在Squid数据集的第6列，那么：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(Squid[,6])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4432  9.8331  9.7356  9.3107  8.9926  8.7707&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，我不推荐这种方法，还得查第几列，麻烦。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;attach函数&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.1.4 attach函数&lt;/h3&gt;
&lt;p&gt;你看，之前提到了这个函数吧。这个函数可以把数据集添加到R的搜索路径中，这样，就可以直接访问数据集中的变量。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(Squid)
#直接访问变量GSI
head(GSI)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.4432  9.8331  9.7356  9.3107  8.9926  8.7707&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#然后可以画图了
boxplot(GSI)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-03-11-r-chapter3_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#或者运算
mean(GSI)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.187034&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#当想要解绑的时候
detach(Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意哈，一次绑定一个数据，当想绑定其他数据集的时候，建议最好先解绑前一个数据集，避免有同名的变量干扰。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;访问数据子集&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.2 访问数据子集&lt;/h2&gt;
&lt;p&gt;Squid这个数据集里面有个sex变量，别想多了，是性别。此时，我只想对雄性的数据进行处理，可以这么做：
首先需要知道性别是如何编码的：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unique(Squid$Sex)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里是这么表示的，雄性是1，雌性是2。
接下来访问所有的雄性数据，并存储在SquidM的数据框中：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Se1 &amp;lt;- Squid$Sex == 1
SquidM &amp;lt;- Squid[Se1,]
head(SquidM)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sample Year Month Location Sex    GSI
## 24     24    1     5        1   1 5.2970
## 48     48    1     5        3   1 4.2968
## 58     58    1     6        1   1 3.5008
## 60     60    1     6        1   1 3.2487
## 61     61    1     6        1   1 3.2304
## 62     62    1     5        3   1 3.2263&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面讲下这段代码的逻辑：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;第一行生成一个与变量Sex具有相同长度的逻辑向量Se1，如果Sex值为1，则该变量的值是TRUE，反之则为FALSE。这样的变量也被称为&lt;strong&gt;布尔向量&lt;/strong&gt;，可以用来选择&lt;strong&gt;行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;接下来选择Squid中Se1等于TRUE的行，并存储在SquidM中。
至此，雄性数据选择完毕。
当然，这个代码也可以简化为：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidM &amp;lt;- Squid[Squid$Sex == 1,]
head(SquidM)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sample Year Month Location Sex    GSI
## 24     24    1     5        1   1 5.2970
## 48     48    1     5        3   1 4.2968
## 58     58    1     6        1   1 3.5008
## 60     60    1     6        1   1 3.2487
## 61     61    1     6        1   1 3.2304
## 62     62    1     5        3   1 3.2263&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#雌性的数据
SquidF &amp;lt;- Squid[Squid$Sex == 2,]
head(SquidF)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Sample Year Month Location Sex     GSI
## 1      1    1     1        1   2 10.4432
## 2      2    1     1        3   2  9.8331
## 3      3    1     1        1   2  9.7356
## 4      4    1     1        1   2  9.3107
## 5      5    1     1        1   2  8.9926
## 6      6    1     1        1   2  8.7707&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面讲一下布尔运算符的用法：或“|”,与“&amp;amp;”，非“!”。
先看一下Location变量有什么编码值：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unique(Squid$Location)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 3 4 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我只想要Location为1，2，3的数据，注意这个是&lt;strong&gt;并集&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Squid123 &amp;lt;- Squid[Squid$Location == 1 | 
                  Squid$Location == 2 |
                  Squid$Location == 3,]
Squid123 &amp;lt;- Squid[Squid$Location != 4, ]
Squid123 &amp;lt;- Squid[Squid$Location &amp;lt; 4, ]
Squid123 &amp;lt;- Squid[Squid$Location &amp;lt;= 3, ]
Squid123 &amp;lt;- Squid[Squid$Location &amp;gt;= 1 &amp;amp;
                  Squid$Location &amp;lt;= 3,]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上语句都是一个意思。
额，写完才发现，我选用的是Cascadia code字体，这样的话……绝对等于也就是两个等于号是&lt;strong&gt;==&lt;/strong&gt;，不等于应该是&lt;strong&gt;！=&lt;/strong&gt;，而这里显示的是&lt;strong&gt;!=&lt;/strong&gt;，同样的，小于等于和大于等于的形式都发生变化了。
然后，接下来，我想进一步从雄性数据集中提取出Location为1的数据集：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidM.1 &amp;lt;- Squid[Squid$Sex == 1 &amp;amp;
                  Squid$Location == 1,]&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;数据排序&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2.1 数据排序&lt;/h3&gt;
&lt;p&gt;有的时候想对数据集根据某一个变量进行排序，从大到小啊或者从小到大，在excel中很好操作，在R中要这样：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#按月份排序
head(Squid[order(Squid$Month),], n=30L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Sample Year Month Location Sex     GSI
## 1        1    1     1        1   2 10.4432
## 2        2    1     1        3   2  9.8331
## 3        3    1     1        1   2  9.7356
## 4        4    1     1        1   2  9.3107
## 5        5    1     1        1   2  8.9926
## 6        6    1     1        1   2  8.7707
## 7        7    1     1        1   2  8.2576
## 8        8    1     1        3   2  7.4045
## 9        9    1     1        3   2  7.2156
## 11      11    1     1        1   2  6.3882
## 14      14    1     1        1   2  6.0726
## 18      18    1     1        1   2  5.7757
## 198    198    1     1        1   1  1.2610
## 204    204    1     1        1   1  1.1997
## 244    244    1     1        1   1  0.8373
## 255    255    1     1        1   2  0.6716
## 264    264    1     1        1   2  0.5758
## 271    271    1     1        3   1  0.5518
## 279    279    1     1        1   1  0.4921
## 281    281    1     1        1   1  0.4808
## 292    292    1     1        3   2  0.3828
## 302    302    1     1        1   1  0.3289
## 317    317    1     1        1   1  0.2758
## 329    329    1     1        1   1  0.2506
## 352    352    1     1        1   2  0.2092
## 373    373    1     1        1   2  0.1792
## 381    381    1     1        3   1  0.1661
## 387    387    1     1        1   2  0.1618
## 393    393    1     1        1   1  0.1543
## 394    394    1     1        1   1  0.1541&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为处理的是Squid中行，所以放在了逗号的前面。也可以对一个变量进行排序：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(Squid$GSI[order(Squid$Month)], n=30L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 10.4432  9.8331  9.7356  9.3107  8.9926  8.7707  8.2576  7.4045  7.2156
## [10]  6.3882  6.0726  5.7757  1.2610  1.1997  0.8373  0.6716  0.5758  0.5518
## [19]  0.4921  0.4808  0.3828  0.3289  0.2758  0.2506  0.2092  0.1792  0.1661
## [28]  0.1618  0.1543  0.1541&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;使用相同的标识符组合两个数据集&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.3 使用相同的标识符组合两个数据集&lt;/h2&gt;
&lt;p&gt;书里这段说的很啰嗦，其实就是在实际使用中，我们可能会导入很多个excel文件，而这些文件里面的样本是一样的。简单来说，举个例子，我用了10只小鼠，样本命名为1，2，3，……，10，第一个excel文件里记载了每只老鼠血清的甘三酯（TG）含量，第二个excel文件里，记载了每只老鼠肝脏的TG含量，这两个文件分别导入到R中，生成两个数据集，而这两个数据集，样本名是一致的。
以书中的例子而言，是这样的，Squid1.txt文件里记载了样本和对应的GSI，Squid2.txt文件里记载了样本和其他的对应变量，比如年份、月份、位置、性别。
下面来读入这两个数据：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Sq1 &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\Squid1.txt&amp;quot;, header = TRUE)
Sq2 &amp;lt;- read.table(file = &amp;quot;F:\\database\\RBook\\Squid2.txt&amp;quot;, header = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后根据这两个数据集具有一致的样本进行合并，采用merge函数：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidMerged &amp;lt;- merge(Sq1, Sq2, by = &amp;quot;Sample&amp;quot;)
head(SquidMerged, n=30L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sample     GSI YEAR MONTH Location Sex
## 1       1 10.4432    1     1        1   2
## 2       2  9.8331    1     1        3   2
## 3       3  9.7356    1     1        1   2
## 4       5  8.9926    1     1        1   2
## 5       6  8.7707    1     1        1   2
## 6       7  8.2576    1     1        1   2
## 7       8  7.4045    1     1        3   2
## 8       9  7.2156    1     1        3   2
## 9      10  6.8372    1     2        1   2
## 10     11  6.3882    1     1        1   2
## 11     12  6.3672    1     6        1   2
## 12     13  6.2998    1     2        1   2
## 13     14  6.0726    1     1        1   2
## 14     15  5.8395    1     6        1   2
## 15     16  5.8070    1     6        1   2
## 16     17  5.7774    1     6        3   2
## 17     18  5.7757    1     1        1   2
## 18     19  5.6484    1     5        3   2
## 19     20  5.6141    1     5        1   2
## 20     21  5.6017    1     5        3   2
## 21     22  5.5510    1     6        1   2
## 22     23  5.3110    1     5        1   2
## 23     24  5.2970    1     5        1   1
## 24     25  5.2253    1     6        1   2
## 25     26  5.1667    1     6        1   2
## 26     27  5.1405    1     6        1   2
## 27     28  5.1292    1     6        1   2
## 28     29  5.0782    1     6        1   2
## 29     30  5.0612    1     6        1   2
## 30     31  5.0097    1     5        1   2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个&lt;strong&gt;by = “Sample”&lt;/strong&gt;就是说，Sq1和Sq2以Sample作为相同的标识符来合并。
另外merge这个函数还有一个参数是&lt;strong&gt;all = TRUE/FALSE&lt;/strong&gt;，默认情况下，这个值是FALSE，什么意思呢，就是说Sq1和Sq2的行如果有缺失值的话，就会被忽略掉，这个样本就不存在于SquidMerged数据集中，反之，则用NA填充。下面举个&lt;strong&gt;all = TRUE&lt;/strong&gt;的例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidMerged2 &amp;lt;- merge(Sq1, Sq2, by = &amp;quot;Sample&amp;quot;,
                      all = TRUE)
head(SquidMerged2, n=30L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sample     GSI YEAR MONTH Location Sex
## 1       1 10.4432    1     1        1   2
## 2       2  9.8331    1     1        3   2
## 3       3  9.7356    1     1        1   2
## 4       4  9.3107   NA    NA       NA  NA
## 5       5  8.9926    1     1        1   2
## 6       6  8.7707    1     1        1   2
## 7       7  8.2576    1     1        1   2
## 8       8  7.4045    1     1        3   2
## 9       9  7.2156    1     1        3   2
## 10     10  6.8372    1     2        1   2
## 11     11  6.3882    1     1        1   2
## 12     12  6.3672    1     6        1   2
## 13     13  6.2998    1     2        1   2
## 14     14  6.0726    1     1        1   2
## 15     15  5.8395    1     6        1   2
## 16     16  5.8070    1     6        1   2
## 17     17  5.7774    1     6        3   2
## 18     18  5.7757    1     1        1   2
## 19     19  5.6484    1     5        3   2
## 20     20  5.6141    1     5        1   2
## 21     21  5.6017    1     5        3   2
## 22     22  5.5510    1     6        1   2
## 23     23  5.3110    1     5        1   2
## 24     24  5.2970    1     5        1   1
## 25     25  5.2253    1     6        1   2
## 26     26  5.1667    1     6        1   2
## 27     27  5.1405    1     6        1   2
## 28     28  5.1292    1     6        1   2
## 29     29  5.0782    1     6        1   2
## 30     30  5.0612    1     6        1   2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比这两个组合数据集，就可以发现样本4的差别。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;输出数据&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.4 输出数据&lt;/h2&gt;
&lt;p&gt;上文提到我为了研究需要，将雄性鱿鱼的数据给提取出来了，并存储于SquidM的数据集中，下面，我想把这个数据集给导出来，方便我发给小伙伴们。这个时候就会用到write.table函数：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidM &amp;lt;- Squid[Squid$Sex == 1,]
write.table(SquidM, file = &amp;quot;F:\\database\\RBook\\MaleSquid.txt&amp;quot;,
            sep = &amp;quot; &amp;quot;, quote = FALSE,
            append = FALSE, na = &amp;quot;NA&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样在我的文件夹中就会出现&lt;strong&gt;MaleSquid.txt&lt;/strong&gt;文件。接下来，逐个讲解这个函数中各参数的含义：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;首先要指明要导出的数据集，本例中是SquidM；&lt;/li&gt;
&lt;li&gt;然后需要告诉R，我要以什么名称，在什么位置来导出这个数据集，本例中是file = “F:\database\RBook\MaleSquid.txt”；&lt;/li&gt;
&lt;li&gt;sep = &#34; &#34;是告诉R我要将数据用空格隔开，注意引号里面是空格；&lt;/li&gt;
&lt;li&gt;quote = FALSE是要取消字符串的引号标志，也就是标题的引号；&lt;/li&gt;
&lt;li&gt;append = FALSE嘛……说实话，书中说&#34;为FALSE的话，就会打开一个新的文件，如果为TRUE，它会将变量SquidM添加到一个已经存在的文件的尾部“，我压根就没看懂，等哪天找到英文原版看一下是不是翻译的问题；&lt;/li&gt;
&lt;li&gt;na = “NA”的意思就简单了，SquidM的缺失值我就用&lt;strong&gt;NA&lt;/strong&gt;来代替。
看一下输出来的文件长什么样：
&lt;img src=&#34;https://rmarkdown.s3-cn-east-1.qiniucs.com/20200310212039.jpg&#34; /&gt;
可以发现，按照变量名将下面的数据逐个对应后，第一列没有名字，这个就是R的问题，如果要导入到excel中，需要将第一行的所有变量名向右移一格。说到这里，我又想吐槽了，书中是这么说的：“需要把第一行转移到右侧一列”，你瞅瞅，能理解不。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;重新编码分类变量&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.5 重新编码分类变量&lt;/h2&gt;
&lt;p&gt;首先说下什么是分类变量，结合例子，在前文，我们用str(Squid)命令查看了各变量的类型：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    2644 obs. of  6 variables:
##  $ Sample  : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Year    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ Month   : int  1 1 1 1 1 1 1 1 1 2 ...
##  $ Location: int  1 3 1 1 1 1 1 3 3 1 ...
##  $ Sex     : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ GSI     : num  10.44 9.83 9.74 9.31 8.99 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量Location编码为1，2，3，4，变量Sex编码为1，2。这样的变量就是分类变量，或者叫做名义变量。
虽然说这种编码方式可以将一些字符串什么的转换为数字，但是，除了数据集所有者自己，谁也不知道Location的1，2，3，4分别是什么，随着时间的变迁，所有者自己都会忘掉。
所以就有了将这类分类变量重编码的需要。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Squid$fLocation &amp;lt;- factor(Squid$Location)
Squid$fSex &amp;lt;- factor(Squid$Sex)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两句的意思是，分别在Squid数据框中生成新变量&lt;strong&gt;fLocation&lt;/strong&gt;和&lt;strong&gt;fSex&lt;/strong&gt;，这里用到了R中的因子概念。
那我们看一下这两个新变量长什么样子，比如说fSex：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(Squid$fSex, n=100L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2
##  [38] 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 2 2 2 1 2 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1
##  [75] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1
## Levels: 1 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意最后一行：&lt;strong&gt;Levels: 1 2&lt;/strong&gt;，这告诉我们，fSex有两个水平，下面将这两个水平重新编码为&lt;strong&gt;“雄性”&lt;/strong&gt;和&lt;strong&gt;“雌性”&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Squid$fSex &amp;lt;- factor(Squid$Sex, levels = c(1,2),
                     labels = c(&amp;quot;M&amp;quot;, &amp;quot;F&amp;quot;))
head(Squid$fSex, n=100L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] F F F F F F F F F F F F F F F F F F F F F F F M F F F F F F F F F F F F F
##  [38] F F F F F F F F F F M F F F F F F F F F M F M M M M F M M M M M M M M M M
##  [75] M F M M M M M M M M M M M M M M M M F M M M M M M M
## Levels: M F&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里levels = c(1,2)和labels = c(“M”, “F”)就一一对应起来，1对应M也就是雄性，2对应F也就是雌性。
现在试试用新变量fSex来做个图或者来个线性回归：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boxplot(GSI ~ fSex, data = Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-03-11-r-chapter3_files/figure-html/unnamed-chunk-25-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;M1 &amp;lt;- lm(GSI ~ fSex, data = Squid)
M1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = GSI ~ fSex, data = Squid)
## 
## Coefficients:
## (Intercept)        fSexF  
##       1.226        2.047&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面，我们看一下FLocation：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(Squid$fLocation, n=100L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 1 3 1 1 1 1 1 3 3 1 1 1 1 1 1 1 3 1 3 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [38] 1 1 3 1 1 1 1 3 1 1 3 1 1 1 1 1 1 1 3 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1
##  [75] 1 3 1 1 3 1 1 3 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 3 1 3
## Levels: 1 2 3 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boxplot(GSI ~ fLocation, data = Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-03-11-r-chapter3_files/figure-html/unnamed-chunk-26-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;注意到，这个名义变量有四个水平，这种情况下，水平值由小到大进行排序，这意味着，在盒形图里，位置为1的数据与位置为2的数据相邻，位置为2的与位置为3的相邻等等。
但是如果我把这个默认的由小到大的排序改了呢：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Squid$fLocation &amp;lt;- factor(Squid$Location, levels = c(2,3,1,4))
head(Squid$fLocation, n=100L)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] 1 3 1 1 1 1 1 3 3 1 1 1 1 1 1 1 3 1 3 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [38] 1 1 3 1 1 1 1 3 1 1 3 1 1 1 1 1 1 1 3 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1
##  [75] 1 3 1 1 3 1 1 3 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 3 1 3
## Levels: 2 3 1 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，最后一行显示的是：&lt;strong&gt;Levels: 2 3 1 4&lt;/strong&gt;，我用这个重编码过的fLocation画个图，大家看下差别：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;boxplot(GSI ~ fLocation, data = Squid)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2020-03-11-r-chapter3_files/figure-html/unnamed-chunk-28-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;另外，在本章开始的时候选择雄性数据，我是这么做的：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidM &amp;lt;- Squid[Squid$Sex == 1,]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那我想用fSex选择雄性呢，是一样的吗，答案是否定的：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;SquidM &amp;lt;- Squid[Squid$fSex == &amp;quot;1&amp;quot;,]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于fSex而言，编码数字1必须用双引号括起来，因为fSex是个因子（factor）。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;本章学了哪些r函数&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.6 本章学了哪些R函数&lt;/h2&gt;
&lt;p&gt;自己整合去。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;习题&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.7 习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;使用流行病学数据练习使用read.table函数并访问其中的变量：
文件为&lt;em&gt;BirdFlu.xls&lt;/em&gt;，这是一个WHO报道的每年人类感染禽流感A（H5N1)的病例。&lt;/li&gt;
&lt;li&gt;使用深海研究数据练习使用read.table函数并访问其中的变量：
这个来源于第二张的习题6，做完之后，从&lt;em&gt;ISIT.xls&lt;/em&gt;文件载入数据。&lt;/li&gt;
&lt;li&gt;使用深海研究数据练习使用write.table函数：
提取4月份并且深度超过2000米的测量数据，并输出。&lt;/li&gt;
&lt;li&gt;使用深海研究数据练习使用factor函数并访问数据框中的子集：
站点1-5是2001年4月抽样，站点6-11是2001年8月抽样，站点12-15是2002年3月抽样，站点16-19是2002年10月抽样，在R里生成两个新变量确定月份和年份。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第四章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;section&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第四章&lt;/h1&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第三章-2</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0-2/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0-2/</guid>
      <description>


&lt;div id=&#34;section&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.5 变量的重命名&lt;/h2&gt;
&lt;p&gt;继续接上期。上期讲到啥了~~&lt;/p&gt;
&lt;p&gt;算了，根据标题来。这一节主要讲如何修改变量的名称。一般来说，可以通过交互式或者编程的方法来实现。&lt;/p&gt;
&lt;p&gt;假设希望将变量名manager变为managerID。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#fix(leader)
#在弹出的界面单击manager就可以修改了&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是交互式修改，下面介绍如何用命令行修改。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;manager &amp;lt;- c(1,2,3,4,5)
date &amp;lt;- c(&amp;quot;10/20/08&amp;quot;,&amp;quot;10/21/08&amp;quot;,&amp;quot;10/10/08&amp;quot;,&amp;quot;10/19/08&amp;quot;,&amp;quot;6/1/09&amp;quot;)
country &amp;lt;- c(&amp;quot;US&amp;quot;,&amp;quot;UK&amp;quot;,&amp;quot;US&amp;quot;,&amp;quot;UK&amp;quot;,&amp;quot;US&amp;quot;)
gender &amp;lt;- c(&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;M&amp;quot;)
age &amp;lt;- c(32,43,26,38,99)
q1 &amp;lt;- c(5,3,3,3,2)
q2 &amp;lt;- c(4,5,5,3,2)
q3 &amp;lt;- c(5,2,5,4,1)
q4 &amp;lt;- c(5,5,5,NA,1)
q5 &amp;lt;- c(5,5,2,NA,1)
leader &amp;lt;- data.frame(manager,date,country,gender,age,
                     q1,q2,q3,q4,q5,
                     stringsAsFactors = FALSE)
#首先调用reshape包
library(reshape)
#修改manager和date变量名
#这里书上出现了个错误。managerID应该用双引号括起来
leader &amp;lt;- rename(leader, c(manager=&amp;quot;managerID&amp;quot;,
                           date=&amp;quot;testDate&amp;quot;))
leader&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   managerID testDate country gender age q1 q2 q3 q4 q5
## 1         1 10/20/08      US      M  32  5  4  5  5  5
## 2         2 10/21/08      UK      F  43  3  5  2  5  5
## 3         3 10/10/08      US      M  26  3  5  5  5  2
## 4         4 10/19/08      UK      F  38  3  3  4 NA NA
## 5         5   6/1/09      US      M  99  2  2  1  1  1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以通过names()函数来重命名变量
#比如讲q1-q5变为item1-item5
names(leader)[6:10] &amp;lt;- c(&amp;quot;item1&amp;quot;,&amp;quot;item2&amp;quot;,&amp;quot;item3&amp;quot;,
                         &amp;quot;item4&amp;quot;,&amp;quot;item5&amp;quot;)
leader&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   managerID testDate country gender age item1 item2 item3 item4 item5
## 1         1 10/20/08      US      M  32     5     4     5     5     5
## 2         2 10/21/08      UK      F  43     3     5     2     5     5
## 3         3 10/10/08      US      M  26     3     5     5     5     2
## 4         4 10/19/08      UK      F  38     3     3     4    NA    NA
## 5         5   6/1/09      US      M  99     2     2     1     1     1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，就这么简单。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.6 缺失值&lt;/h2&gt;
&lt;p&gt;说起缺失值，很烦的好不好。在实际的数据处理中，经常会遇到缺失值的出现。有些是因为某些样本并没有这个变量（指标），也有些是因为测量过程中出现问题导致的。&lt;/p&gt;
&lt;p&gt;缺失值的存在对后续的数据处理是个很大的问题。在R中，缺失值用NA表示。可以用函数is.na()检测缺失值是否存在。它将返回逻辑值。出现NA就用TRUE，反之则是FALSE。看下面的例子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(1,2,NA,3,4)
is.na(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE FALSE  TRUE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在将这个函数应用在leader数据框上：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.na(leader[6:10])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      item1 item2 item3 item4 item5
## [1,] FALSE FALSE FALSE FALSE FALSE
## [2,] FALSE FALSE FALSE FALSE FALSE
## [3,] FALSE FALSE FALSE FALSE FALSE
## [4,] FALSE FALSE FALSE  TRUE  TRUE
## [5,] FALSE FALSE FALSE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么问题来了，现在已经检测到缺失值了，要怎么处理呢？&lt;/p&gt;
&lt;p&gt;第一种方法是删除这些缺失值，用其余的数据进行之后的运算&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#先构建几个向量
a &amp;lt;- c(1,NA,2,3,4)
b &amp;lt;- c(10,20,NA,30,40)
z &amp;lt;- a+b
z&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11 NA NA 33 44&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- a[1]+a[2]+a[3]+a[4]+a[5]
d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e &amp;lt;- sum(a)
e&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以看出e算不出来，在sum函数中加入na.rm=TRUE删掉缺失值
e &amp;lt;- sum(a,na.rm = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以用函数na.omit()来移除所有含有缺失值的观测，也就是变量，它将删除所有含有缺失值的行。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leader&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   managerID testDate country gender age item1 item2 item3 item4 item5
## 1         1 10/20/08      US      M  32     5     4     5     5     5
## 2         2 10/21/08      UK      F  43     3     5     2     5     5
## 3         3 10/10/08      US      M  26     3     5     5     5     2
## 4         4 10/19/08      UK      F  38     3     3     4    NA    NA
## 5         5   6/1/09      US      M  99     2     2     1     1     1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata &amp;lt;- na.omit(leader)
newdata&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   managerID testDate country gender age item1 item2 item3 item4 item5
## 1         1 10/20/08      US      M  32     5     4     5     5     5
## 2         2 10/21/08      UK      F  43     3     5     2     5     5
## 3         3 10/10/08      US      M  26     3     5     5     5     2
## 5         5   6/1/09      US      M  99     2     2     1     1     1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看见少了两行。要注意的是，这个函数尽量不要用，因为它作用太强了。&lt;/p&gt;
&lt;p&gt;那么问题又来了，不能用这个函数，还能用什么呢。&lt;/p&gt;
&lt;p&gt;在其他地方看到，可以用填补法把缺失值填上去（不影响原有数据的分布）。不过现在忘了在哪里看到了，等有空了再补上。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.8 类型转换&lt;/h2&gt;
&lt;p&gt;嗯，我就是跳过了3.7节，也就是日期值的内容。有兴趣的话自己去看看吧。&lt;/p&gt;
&lt;p&gt;类型转换包括数值型、字符型等的互转，数据框、矩阵等的互转。见下表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;判断&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;转换&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.numeric()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.numeric()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.character()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as..character()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.vector()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.vector()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.matrix()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.matrix()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.data.frame()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.data.frame()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.factor()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.factor()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;is.logical()&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;as.logical()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一般来说，先判断类型，再根据需求转换。例子我就不举了，以后会用到。
算了，讲一个吧。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xyz &amp;lt;- c(2,4,5,6,7)
is.numeric(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.vector(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.character(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xyz &amp;lt;- as.character(xyz)
is.numeric(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.vector(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.character(xyz)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-3&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.9 数据排序&lt;/h2&gt;
&lt;p&gt;排序嘛，很好理解。举个栗子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#用order()函数
newdata1 &amp;lt;- leader[order(leader$age)]
newdata1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   country managerID gender testDate age
## 1      US         1      M 10/20/08  32
## 2      UK         2      F 10/21/08  43
## 3      US         3      M 10/10/08  26
## 4      UK         4      F 10/19/08  38
## 5      US         5      M   6/1/09  99&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(leader)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked _by_ .GlobalEnv:
## 
##     age, country, gender&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata2 &amp;lt;- leader[order(gender,age)]
newdata2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   gender testDate country managerID age
## 1      M 10/20/08      US         1  32
## 2      F 10/21/08      UK         2  43
## 3      M 10/10/08      US         3  26
## 4      F 10/19/08      UK         4  38
## 5      M   6/1/09      US         5  99&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-4&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.10 数据集的合并&lt;/h2&gt;
&lt;p&gt;说实话，我觉得应该先讲数据集的拆分，不过无所谓了。&lt;/p&gt;
&lt;p&gt;数据集的合并可以看成在原来的数据集上添加行或者列。多数情况下，两个&lt;strong&gt;数据框&lt;/strong&gt;是通过一个或多个共有变量进行联结的，叫做内联结（inner join）。
merge()函数是用来&lt;strong&gt;横向&lt;/strong&gt;合并数据集的，即&lt;strong&gt;列合并&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;total &amp;lt;- merge(dataframe1,datafame2,by=“ID”)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面看下具体的例子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(multilevel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 载入需要的程辑包：nlme&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 载入需要的程辑包：MASS&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(cohesion)
cohesion&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01 COH02 COH03 COH04 COH05
## 1  1044B     1ST     4     5     5     5     5
## 2  1044B     1ST     3    NA     5     5     5
## 3  1044B     1ST     2     3     3     3     3
## 4  1044B     2ND     3     4     3     4     4
## 5  1044B     2ND     4     4     3     4     4
## 6  1044B     2ND     3     3     2     2     1
## 7  1044C     1ST     3     3     3     3     3
## 8  1044C     1ST     3     1     4     3     4
## 9  1044C     2ND     3     3     3     3     3
## 10 1044C     2ND     2     2     2     3     2
## 11 1044C     2ND     1     1     1     3     3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#现在新建一个数据框group.size
group.size &amp;lt;- data.frame(
  UNIT=c(&amp;quot;1044B&amp;quot;,&amp;quot;1044B&amp;quot;,&amp;quot;1044C&amp;quot;,&amp;quot;1044C&amp;quot;),
  PLATOON=c(&amp;quot;1ST&amp;quot;,&amp;quot;2ND&amp;quot;,&amp;quot;1ST&amp;quot;,&amp;quot;2ND&amp;quot;),
  PSIZE=c(3,3,2,3)
  )
group.size&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    UNIT PLATOON PSIZE
## 1 1044B     1ST     3
## 2 1044B     2ND     3
## 3 1044C     1ST     2
## 4 1044C     2ND     3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;new.cohesion &amp;lt;- merge(cohesion,group.size,
                      by=c(&amp;quot;UNIT&amp;quot;,&amp;quot;PLATOON&amp;quot;))
new.cohesion&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01 COH02 COH03 COH04 COH05 PSIZE
## 1  1044B     1ST     4     5     5     5     5     3
## 2  1044B     1ST     3    NA     5     5     5     3
## 3  1044B     1ST     2     3     3     3     3     3
## 4  1044B     2ND     3     4     3     4     4     3
## 5  1044B     2ND     4     4     3     4     4     3
## 6  1044B     2ND     3     3     2     2     1     3
## 7  1044C     1ST     3     3     3     3     3     2
## 8  1044C     1ST     3     1     4     3     4     2
## 9  1044C     2ND     3     3     3     3     3     3
## 10 1044C     2ND     2     2     2     3     2     3
## 11 1044C     2ND     1     1     1     3     3     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，&lt;strong&gt;纵向&lt;/strong&gt;合并也就是&lt;strong&gt;行&lt;/strong&gt;合并怎么弄呢。用rbind()函数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;total &amp;lt;- rbind(dataframe1,datafame2)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意一点，两个数据框必须拥有相同的变量，顺序倒是无所谓。如果A数据框含有B数据框没有的变量，那么就采取下面两种方法：
1. 将它删除；&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在B中追加这个变量并将其值设置为NA。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;section-5&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.11 数据集取子集&lt;/h2&gt;
&lt;p&gt;这节的内容就是在解决第三章开头的第5个问题。&lt;/p&gt;
&lt;p&gt;在实际操作中，经常会出现导入的数据集包含了太多样本以及变量，而仅仅只想针对某些样本或者变量来展开研究。下面一一介绍取子集的方法。&lt;/p&gt;
&lt;div id=&#34;section-6&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.11.1 选入样本&lt;/h3&gt;
&lt;p&gt;见例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(cohesion)
cohesion&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01 COH02 COH03 COH04 COH05
## 1  1044B     1ST     4     5     5     5     5
## 2  1044B     1ST     3    NA     5     5     5
## 3  1044B     1ST     2     3     3     3     3
## 4  1044B     2ND     3     4     3     4     4
## 5  1044B     2ND     4     4     3     4     4
## 6  1044B     2ND     3     3     2     2     1
## 7  1044C     1ST     3     3     3     3     3
## 8  1044C     1ST     3     1     4     3     4
## 9  1044C     2ND     3     3     3     3     3
## 10 1044C     2ND     2     2     2     3     2
## 11 1044C     2ND     1     1     1     3     3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#选择第一到第三行并命名为newdata3数据集
#注意方括号的用法&amp;quot;[行, 列]&amp;quot;
newdata3 &amp;lt;- cohesion[1:3,]
#按条件筛选
#注意绝对等于“==”以及连接符“&amp;amp;”
newdata4 &amp;lt;- cohesion[which(cohesion$UNIT==&amp;quot;1044B&amp;quot;
                           &amp;amp;
                             cohesion$COH03&amp;gt;=4),]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这个方法不唯一，subset()函数也可以。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-7&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.11.2 选入变量&lt;/h3&gt;
&lt;p&gt;同样见例子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(cohesion)
cohesion&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01 COH02 COH03 COH04 COH05
## 1  1044B     1ST     4     5     5     5     5
## 2  1044B     1ST     3    NA     5     5     5
## 3  1044B     1ST     2     3     3     3     3
## 4  1044B     2ND     3     4     3     4     4
## 5  1044B     2ND     4     4     3     4     4
## 6  1044B     2ND     3     3     2     2     1
## 7  1044C     1ST     3     3     3     3     3
## 8  1044C     1ST     3     1     4     3     4
## 9  1044C     2ND     3     3     3     3     3
## 10 1044C     2ND     2     2     2     3     2
## 11 1044C     2ND     1     1     1     3     3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#选择cohesion数据集中第一个到第三个变量，也就是列
newdata5 &amp;lt;- cohesion[1:3]
newdata5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01
## 1  1044B     1ST     4
## 2  1044B     1ST     3
## 3  1044B     1ST     2
## 4  1044B     2ND     3
## 5  1044B     2ND     4
## 6  1044B     2ND     3
## 7  1044C     1ST     3
## 8  1044C     1ST     3
## 9  1044C     2ND     3
## 10 1044C     2ND     2
## 11 1044C     2ND     1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#等价于
v &amp;lt;- c(&amp;quot;UNIT&amp;quot;,&amp;quot;PLATOON&amp;quot;,&amp;quot;COH01&amp;quot;)
newdata6 &amp;lt;- cohesion[v]
newdata6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH01
## 1  1044B     1ST     4
## 2  1044B     1ST     3
## 3  1044B     1ST     2
## 4  1044B     2ND     3
## 5  1044B     2ND     4
## 6  1044B     2ND     3
## 7  1044C     1ST     3
## 8  1044C     1ST     3
## 9  1044C     2ND     3
## 10 1044C     2ND     2
## 11 1044C     2ND     1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-8&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.11.3 剔除变量&lt;/h3&gt;
&lt;p&gt;捡栗子，不对，见例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;myvariable &amp;lt;- names(cohesion) %in%
  c(&amp;quot;COH01&amp;quot;,&amp;quot;COH03&amp;quot;,&amp;quot;COH05&amp;quot;)
newdata7 &amp;lt;- cohesion[!myvariable]
newdata7&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH02 COH04
## 1  1044B     1ST     5     5
## 2  1044B     1ST    NA     5
## 3  1044B     1ST     3     3
## 4  1044B     2ND     4     4
## 5  1044B     2ND     4     4
## 6  1044B     2ND     3     2
## 7  1044C     1ST     3     3
## 8  1044C     1ST     1     3
## 9  1044C     2ND     3     3
## 10 1044C     2ND     2     3
## 11 1044C     2ND     1     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面讲解一下：
&amp;gt;names(cohesion)产生一个包含所有变量名的字符向量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;names(cohesion) %in% c(“COH01”,“COH03”,“COH05”)返回一个逻辑向量，names(cohesion)中每个匹配这三个变量的元素的值为TRUE，反之为FALSE。即c(FALSE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;运算符非（即“！”）将逻辑值翻转即c(TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cohesion[c(TRUE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE)]选了TRUE的列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是COH01，COH03，COH05被删除了。
当然也可以根据这三个变量的位置来操作。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata8 &amp;lt;- cohesion[c(-3,-5,-7)]
newdata8&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     UNIT PLATOON COH02 COH04
## 1  1044B     1ST     5     5
## 2  1044B     1ST    NA     5
## 3  1044B     1ST     3     3
## 4  1044B     2ND     4     4
## 5  1044B     2ND     4     4
## 6  1044B     2ND     3     2
## 7  1044C     1ST     3     3
## 8  1044C     1ST     1     3
## 9  1044C     2ND     3     3
## 10 1044C     2ND     2     3
## 11 1044C     2ND     1     3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;subset&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.11.4 subset()函数&lt;/h3&gt;
&lt;p&gt;前面提到了这个函数，举个例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata9 &amp;lt;- subset(cohesion, COH02&amp;gt;=4 | COH02&amp;lt;=1,
                   select=c(COH01,COH02,COH03,COH04,COH05))
newdata9&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    COH01 COH02 COH03 COH04 COH05
## 1      4     5     5     5     5
## 4      3     4     3     4     4
## 5      4     4     3     4     4
## 8      3     1     4     3     4
## 11     1     1     1     3     3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata10 &amp;lt;- subset(cohesion, UNIT==&amp;quot;1044B&amp;quot; &amp;amp; COH02&amp;gt;=4,
                    select=c(COH01,COH02,COH03,COH04,COH05))
newdata10&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   COH01 COH02 COH03 COH04 COH05
## 1     4     5     5     5     5
## 4     3     4     3     4     4
## 5     4     4     3     4     4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，这章就结束了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第三章-1</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0-1/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0-1/</guid>
      <description>


&lt;div id=&#34;section&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第三章 基本数据管理&lt;/h1&gt;
&lt;p&gt;前面讲了一些常用的函数以及数据的输入，在数据处理过程中，在数据输入之后还要对数据进行筛选啊拆分啊什么的，这一章主要讲的就是这个。&lt;/p&gt;
&lt;p&gt;下面讲一个例子：
某项研究想确定男性和女性在领导各自企业方式上的不同，主要的问题如下：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;处于管理岗位的男性和女性在听从上级的程度上是否不同；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这种情况是否依国家不同而不同，或者由性别导致的不同是否普遍存在。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这两个问题，让多个国家的经理人的上司对其服从程度打分：
这位经理人在做出决策之前会询问我的意见。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;态度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;分数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;非常不同意&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;不同意&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;中立&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;同意&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;非常同意&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在这里，每位上司根据这个对某一名经理人进行评分，为简化，一共5个经理人，5个上司。因此，上司的评分就有q1到q5，共5个向量。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;manager &amp;lt;- c(1,2,3,4,5)
date &amp;lt;- c(&amp;quot;10/20/08&amp;quot;,&amp;quot;10/21/08&amp;quot;,&amp;quot;10/10/08&amp;quot;,&amp;quot;10/19/08&amp;quot;,&amp;quot;6/1/09&amp;quot;)
country &amp;lt;- c(&amp;quot;US&amp;quot;,&amp;quot;UK&amp;quot;,&amp;quot;US&amp;quot;,&amp;quot;UK&amp;quot;,&amp;quot;US&amp;quot;)
gender &amp;lt;- c(&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;M&amp;quot;)
age &amp;lt;- c(32,43,26,38,99)
q1 &amp;lt;- c(5,3,3,3,2)
q2 &amp;lt;- c(4,5,5,3,2)
q3 &amp;lt;- c(5,2,5,4,1)
q4 &amp;lt;- c(5,5,5,NA,1)
q5 &amp;lt;- c(5,5,2,NA,1)
leader &amp;lt;- data.frame(manager,date,country,gender,age,
                     q1,q2,q3,q4,q5,
                     stringsAsFactors = FALSE)
leader&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   manager     date country gender age q1 q2 q3 q4 q5
## 1       1 10/20/08      US      M  32  5  4  5  5  5
## 2       2 10/21/08      UK      F  43  3  5  2  5  5
## 3       3 10/10/08      US      M  26  3  5  5  5  2
## 4       4 10/19/08      UK      F  38  3  3  4 NA NA
## 5       5   6/1/09      US      M  99  2  2  1  1  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为从这些数据里分析出东西来，就要对这些数据进行管理。比如；&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;5个评分（q1到q5）需要组合起来，即为每位经理人生成一个平均服从程度得分；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从上面可以看出，有些得分出现了NA缺失值，同时也需要为99岁这样的数据重编码为缺失值，因为99岁这明显不对啊。因此需要一种处理不完整数据的方法；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在某些数据集中往往包含了数百个变量，而我们可能只对一些感兴趣，因此希望创建一个只包含那些变量的新数据集；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在本例中，领导行为可能随经理人的年龄而改变，即二者存在某种函数关系。要检验这种观点，需要将当前的年龄数值重编码为类别型的年龄组（比如，年轻，中年，年长）；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;领导行为可能随时间推移而发生变化，我们可能想重点研究最近全球金融危机期间的服从行为。那么，需要将研究范围限定在某一个特定的时间段（比如1/1/09到12/31/09）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题怎么解决呢，下面将一一介绍。&lt;/p&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.1 创建新变量&lt;/h2&gt;
&lt;p&gt;创建新变量很简单，重点在于如何将新变量整合到原来的数据集中：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y1 &amp;lt;- c(1,2,3,4,5)
y2 &amp;lt;- c(12,13,15,16,17)
newdata &amp;lt;- data.frame(y1,y2)
head(newdata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   y1 y2
## 1  1 12
## 2  2 13
## 3  3 15
## 4  4 16
## 5  5 17&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建新变量
sumy &amp;lt;- newdata$y1+newdata$y2
meany &amp;lt;- (newdata$y1+newdata$y2)/2
sumy&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13 15 18 20 22&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;meany&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  6.5  7.5  9.0 10.0 11.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以看出只是创建了新变量，但是不在newdata中
#整合到newdata数据框中
#方法一
newdata1 &amp;lt;- data.frame(newdata, sumy, meany)
head(newdata1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   y1 y2 sumy meany
## 1  1 12   13   6.5
## 2  2 13   15   7.5
## 3  3 15   18   9.0
## 4  4 16   20  10.0
## 5  5 17   22  11.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#方法二
newdata2 &amp;lt;- transform(newdata,
                     sumy=y1+y2,
                     meany=(y1+y2)/2)
head(newdata2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   y1 y2 sumy meany
## 1  1 12   13   6.5
## 2  2 13   15   7.5
## 3  3 15   18   9.0
## 4  4 16   20  10.0
## 5  5 17   22  11.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#方法三
newdata3 &amp;lt;- newdata
attach(newdata3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked _by_ .GlobalEnv:
## 
##     y1, y2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newdata3$sumy &amp;lt;- y1+y2
newdata3$meany &amp;lt;- (y1+y2)/2
detach(newdata3)
head(newdata3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   y1 y2 sumy meany
## 1  1 12   13   6.5
## 2  2 13   15   7.5
## 3  3 15   18   9.0
## 4  4 16   20  10.0
## 5  5 17   22  11.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.2 向量运算&lt;/h2&gt;
&lt;div id=&#34;section-3&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2.1 添加或删除向量&lt;/h3&gt;
&lt;p&gt;在R中，向量一旦建立起来，里面的元素就已经确定了。因此，如果想添加或删除元素，就需要重新给向量赋值。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;qwe &amp;lt;- c(12,13,14,23,78)
#在中间添加一个元素，数值56
qwe &amp;lt;- c(qwe[1:3],56,qwe[4:5])
qwe&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 12 13 14 56 23 78&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-4&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2.2 向量运算&lt;/h3&gt;
&lt;p&gt;这部分就是线性代数的内容。嗯……不讲了。看例子吧&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(2,3,4)
y &amp;lt;- c(2,5,7)
x+y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  4  8 11&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x*y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  4 15 28&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-5&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2.3 用: 运算符创建向量&lt;/h3&gt;
&lt;p&gt;：运算符用于生成指定范围内数值构成的向量。
看例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;5:8&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5 6 7 8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;5:1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5 4 3 2 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#要注意运算符的优先级
i &amp;lt;- 2
#冒号的优先级高于减号，所以先计算i:i，变成个一元向量，然后再减1
i:i-1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#括号的优先级高于冒号，所以先计算i-1，于是就相当于计算2:1
i:(i-1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意了，这个地方书上说的不对，解释的也是乱七八糟。它的结果是：
i:i-1的结果是“0 1”，i:(i-1)的结果是“1”。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;seqrep&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.2.4 使用seq()以及rep()函数创建向量&lt;/h3&gt;
&lt;p&gt;比上面那个冒号“：”运算符更常用的是seq()函数。它用来生成等差数列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(from=10,to=30,by=3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10 13 16 19 22 25 28&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;?seq()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## starting httpd help server ... done&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;seq(10,30,3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10 13 16 19 22 25 28&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rep()函数可以把同一常数放在向量中，语法是：&lt;/p&gt;
&lt;p&gt;rep(x, times, each)，前两个参数很好理解，最后的each参数是指定x交替重复的次数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- rep(7,5)
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7 7 7 7 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y &amp;lt;- rep(c(1,2,3),3)
y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 1 2 3 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(c(2,6,12),each=3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  2  2  2  6  6  6 12 12 12&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;section-6&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.3 处理数据对象的常用函数&lt;/h2&gt;
&lt;p&gt;这一部分就不再写了，用的时候自然就知道了。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-7&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.4 变量的重编码&lt;/h2&gt;
&lt;p&gt;现在解决前言中的问题2：
&amp;gt; 2. 从上面可以看出，有些得分出现了NA缺失值，同时也需要为99岁这样的数据重编码为缺失值，因为99岁这明显不对啊。因此需要一种处理不完整数据的方法。&lt;/p&gt;
&lt;p&gt;现在将连续型变量age重编码为类别型变量：agecat(Young,Middle Aged,Elder)。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#首先把99岁的年龄值编码成缺失值。
leader$age[leader$age == 99] &amp;lt;- NA
#然后创建agecat向量
leader$agecat[leader$age &amp;gt;= 75] &amp;lt;- &amp;quot;Elder&amp;quot;
leader$agecat[leader$age &amp;lt; 75 &amp;amp; leader$age &amp;gt;=55] &amp;lt;- &amp;quot;Middle Aged&amp;quot;
leader$agecat[leader$age &amp;lt; 55] &amp;lt;- &amp;quot;Young&amp;quot;
leader&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   manager     date country gender age q1 q2 q3 q4 q5 agecat
## 1       1 10/20/08      US      M  32  5  4  5  5  5  Young
## 2       2 10/21/08      UK      F  43  3  5  2  5  5  Young
## 3       3 10/10/08      US      M  26  3  5  5  5  2  Young
## 4       4 10/19/08      UK      F  38  3  3  4 NA NA  Young
## 5       5   6/1/09      US      M  NA  2  2  1  1  1   &amp;lt;NA&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然这个方法不唯一。&lt;/p&gt;
&lt;p&gt;嗯……今天就到这里。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第二章-3</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-3/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-3/</guid>
      <description>


&lt;p&gt;书接上文，上回讲到了因子，现在继续讲&lt;strong&gt;列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;6.列表&lt;/p&gt;
&lt;p&gt;列表就是个大杂烩，可以整合很多对象到单个对象下面。比如，某个&lt;strong&gt;列表&lt;/strong&gt;可能包含了很多&lt;strong&gt;向量&lt;/strong&gt;，&lt;strong&gt;矩阵&lt;/strong&gt;，&lt;strong&gt;数据框&lt;/strong&gt;什么的，甚至可以包含其他列表。创建列表使用list()函数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#当然这个只是个实例，肯定运行不出东西的
#为避免Rmd报错，注释掉好了
#Mylist &amp;lt;- list(object1, object2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面这个才是栗子（没错，就是栗子）：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- &amp;quot;list example&amp;quot;
x &amp;lt;- c(1,2,3,4,5)
matrix &amp;lt;- matrix(1:20,nrow = 5,byrow = FALSE)
k &amp;lt;- c(&amp;quot;one&amp;quot;,&amp;quot;two&amp;quot;,&amp;quot;four&amp;quot;)
mylist &amp;lt;- list(a,x,matrix,k)
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;list example&amp;quot;
## 
## [[2]]
## [1] 1 2 3 4 5
## 
## [[3]]
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
## 
## [[4]]
## [1] &amp;quot;one&amp;quot;  &amp;quot;two&amp;quot;  &amp;quot;four&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#想要查询某个元素怎么办
#使用双重方括号，在方括号里面指明某个成分的数字或者名称
mylist[[3]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个等价于
mylist$matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mylist[[&amp;quot;matrix&amp;quot;]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个例子就是创建了一个包含字符串（a），数值型向量（x），矩阵（matrix）以及字符型向量（k）的列表（mylist）。&lt;/p&gt;
&lt;p&gt;下面是补充内容咯：&lt;/p&gt;
&lt;p&gt;这时应该会有人觉得，诶？不是可以通过指明某个成分的名称来查询吗，但是最后两条语句为什么会出现“NULL”的返回值呢。
这是应为没有给各个成分起名字。列表的成分可以通过列表中成分的&lt;strong&gt;索引&lt;/strong&gt;访问。在&lt;strong&gt;命名列表&lt;/strong&gt;的情况下，它也可以使用名称来访问。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#给个成分命名
names(mylist) &amp;lt;- c(&amp;quot;a&amp;quot;,&amp;quot;x&amp;quot;,&amp;quot;matrix&amp;quot;,&amp;quot;k&amp;quot;)
#再用名字查询下试试
mylist$matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mylist[[&amp;quot;matrix&amp;quot;]]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看，这回成功了吧。
这个问题解决，开始下一部分。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第二章-4</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-4/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-4/</guid>
      <description>


&lt;div id=&#34;r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1.2 R运算符&lt;/h3&gt;
&lt;p&gt;这个部分相对简单些。R中的运算符分为&lt;strong&gt;算数运算符&lt;/strong&gt;、&lt;strong&gt;比较算符&lt;/strong&gt;、&lt;strong&gt;逻辑算符&lt;/strong&gt;。&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;算数运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就是指加减乘除等等啦，见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;算数算符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;*&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;乘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;/&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;^&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;幂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;%%&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;模运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;%/%&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;整数除法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;比较算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就是大于、小于、不等于等等啦，见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;比较算符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;==&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;!=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;=&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;+&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;逻辑算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实就是数学中的或与非啦，见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;逻辑算符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;标量的“与”运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&amp;amp;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;向量的“与”运算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;!&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;非&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于这个就不啰嗦了，或与非其实是高中数学内容了。
大家应该注意到上面说到了&lt;strong&gt;标量&lt;/strong&gt;这个词，在R中，表面上没有&lt;strong&gt;标量&lt;/strong&gt;的类型，但实际上它可以看做是含有一个元素的向量。下面的例子可以看出逻辑运算符对标量和向量的区别：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(TRUE,FALSE,TRUE)
y &amp;lt;- c(TRUE,TRUE,FALSE)
x &amp;amp; y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  TRUE FALSE FALSE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x[1] &amp;amp;&amp;amp; y[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;amp;&amp;amp; y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (x[1] &amp;amp;&amp;amp; y[1])
  print(&amp;quot;both true&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;both true&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (x &amp;amp; y)
  print(&amp;quot;both true&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in if (x &amp;amp; y) print(&amp;quot;both true&amp;quot;): 条件的长度大于一，因此只能用其第
## 一元素&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;both true&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到最后一条语句报错了“the condition has length &amp;gt; 1 and only the first element will be used”。
这是因为if结构判断语句的取值，只能是一个逻辑值，而不是逻辑值的&lt;strong&gt;向量&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;运算次序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个~&lt;del&gt;没啥好讲的&lt;/del&gt;~&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;r-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2 R常用函数及其应用&lt;/h2&gt;
&lt;p&gt;嗯~~前面讲了很多R的基本结构，向量啦，矩阵啦什么的，现在再进一步，开始讲一下R的常用函数。&lt;/p&gt;
&lt;div id=&#34;section&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.1 数学函数&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#绝对值
abs(-1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#平方根
sqrt(36)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;25^(0.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#不小于x的最小整数
ceiling(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#不大于x的最大整数
floor(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#向0的方向截取x中的整数部分
trunc(5.99)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#将x舍入为指定位数的小数
round(3.1415926, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.14&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#将x舍入为指定位数的有效数字
signif(3.1415926, digits = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#一些三角函数
cos(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sin(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.358979e-08&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tan(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -5.358979e-08&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;acos(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in acos(3.1415926): 产生了NaNs&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NaN&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;asin(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in asin(3.1415926): 产生了NaNs&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NaN&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;atan(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.262627&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#双曲余弦
cosh(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11.59195&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#双曲正弦
sinh(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11.54874&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#反双曲余弦、正弦
acosh(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.811526&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;asinh(3.1415926)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.862296&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#log(x, base=n)，对x取以n为底的对数
log(8,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#取自然对数
log(8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.079442&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#常用对数
log10(8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.90309&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log(8,10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.90309&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#指数函数
exp(2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7.389056&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.2 样本统计函数&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#平均数
mean(c(1,2,3,4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#中位数
median(c(1,2,3,4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;median(c(1,2,3,4,5))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#标准差
sd(c(1,2,3,4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.290994&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#方差
var(c(1,2,3,4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.666667&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#绝对中位差
mad(c(1,2,3,4))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.4826&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#quantile(x,probs)，求分位数，x为待求分位数的数值型向量
#probs为一个由[0,1]之间的概率组成的数值向量
#求向量x的第25和75百分位数
quantile(c(1,2,3,4,5,6,7), c(.25,.75))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 25% 75% 
## 2.5 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#求值域
range(c(1,2,3,4,5,6,7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#求和
sum(c(1,2,3,4,5,6,7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 28&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#最大值
max(c(1,2,3,4,5,6,7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#最小值
min(c(1,2,3,4,5,6,7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#scale(x,center=TRUE,scale=TRUE)
#将数据对象x按列进行中心化（center=TRUE）
#或标准化（center=TRUE,scale=TRUE）
#默认情况下，这个函数对矩阵或数据框的指定列进行均值为0
#标准差为1的标准化
mydata &amp;lt;- matrix(c(1,2,3,4,5,6), nrow = 2)
scale(mydata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            [,1]       [,2]       [,3]
## [1,] -0.7071068 -0.7071068 -0.7071068
## [2,]  0.7071068  0.7071068  0.7071068
## attr(,&amp;quot;scaled:center&amp;quot;)
## [1] 1.5 3.5 5.5
## attr(,&amp;quot;scaled:scale&amp;quot;)
## [1] 0.7071068 0.7071068 0.7071068&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#要对每一列进行任意均值和标准差的标准化
#可以采用下面的语句：mydata &amp;lt;- scale(mydata)*SD+M
#其中M是想要的均值，SD是想要的标准差
scale(mydata)*0.25+3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          [,1]     [,2]     [,3]
## [1,] 2.823223 2.823223 2.823223
## [2,] 3.176777 3.176777 3.176777
## attr(,&amp;quot;scaled:center&amp;quot;)
## [1] 1.5 3.5 5.5
## attr(,&amp;quot;scaled:scale&amp;quot;)
## [1] 0.7071068 0.7071068 0.7071068&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.4 字符处理函数&lt;/h3&gt;
&lt;p&gt;前面讲了很多函数，不过都是数值型的，现在接下来要讲的是有关字符处理的函数。
字符处理函数可以从文本型数据中抽取信息，或者为打印输出和生成报告重设文本的格式。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#返回字符串x的字符数量
x &amp;lt;- c(&amp;quot;ab&amp;quot;,&amp;quot;cde&amp;quot;,&amp;quot;dsdesd&amp;quot;)
length(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nchar(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2 3 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nchar(x[3])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#substr(x, start, stop)返回字符串x中指定位置范围的子字符串
x &amp;lt;- &amp;quot;abcdefghij&amp;quot;
substr(x, 2, 4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;bcd&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;substr(x, 2, 4) &amp;lt;- &amp;quot;22222&amp;quot;
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;a222efghij&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#grep(pattern, x, ignore.case=FALSE, fixed=FALSE)
#在字符串x中搜索给定的子字符串pattern。
#若fixed=FALSE，则pattern为一个正则表达式
#若fixed=TRUE，则pattern为一个文本字符串，返回值为匹配的下标
grep(&amp;quot;A&amp;quot;,c(&amp;quot;b&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;c&amp;quot;), fixed = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;grep(&amp;quot;A&amp;quot;,c(&amp;quot;b&amp;quot;,&amp;quot;A&amp;quot;,&amp;quot;c&amp;quot;), fixed = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#sub(pattern, replacement, x, ignore.case=FALSE, fixed=FALSE)在x中搜索pattern，并以文本replacement将其替换。
#若fixed=FALSE，则pattern为一个正则表达式
#若fixed=TRUE，则pattern为一个文本字符串
#下例中“\s”是一个查找空白的正则表达式
#使用“\\s”而不是“\”的原因在于后者是R中的转义字符
sub(&amp;quot;\\s&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;Hello There&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Hello.There&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#strsplit(x,split,fixed=FALSE)将在以split处分割字符向量x中
#将元素拆分为若干个子字符串，返回这些子字符串的列表
#若fixed=FALSE，则pattern为一个正则表达式
#若fixed=TRUE，则pattern为一个文本字符串
y &amp;lt;- strsplit(&amp;quot;abc&amp;quot;,&amp;quot;&amp;quot;)
y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;unlist(y)[2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;b&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sapply(y,&amp;quot;[&amp;quot;,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;b&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;strsplit(&amp;quot;6-16-2011&amp;quot;,split = &amp;quot;-&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] &amp;quot;6&amp;quot;    &amp;quot;16&amp;quot;   &amp;quot;2011&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#paste(……, sep=&amp;quot;&amp;quot;)把若干个字符串拼接在一起，分隔符为sep
paste(&amp;quot;x&amp;quot;, 1:3, sep = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x1&amp;quot; &amp;quot;x2&amp;quot; &amp;quot;x3&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;x&amp;quot;, 1:3, sep = &amp;quot;M&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;xM1&amp;quot; &amp;quot;xM2&amp;quot; &amp;quot;xM3&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;Today is&amp;quot;, date())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Today is Fri Apr 19 20:30:41 2019&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;North&amp;quot;, &amp;quot;Pole&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;North Pole&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;North&amp;quot;, &amp;quot;Pole&amp;quot;, sep = &amp;quot; &amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;North Pole&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;North&amp;quot;, &amp;quot;Pole&amp;quot;, sep = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;NorthPole&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;North&amp;quot;, &amp;quot;Pole&amp;quot;, sep = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;North.Pole&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;paste(&amp;quot;North&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;Pole&amp;quot;, &amp;quot;South&amp;quot;, sep = &amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;NorthandPoleSouth&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#大写转换
toupper(&amp;quot;abc&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ABC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#小写转换
tolower(&amp;quot;ABC&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;abc&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#regexpr(pattern,x)在字符串x中寻找pattern
#返回与pattern匹配的第一个子字符串的起始字符位置
regexpr(&amp;quot;uat&amp;quot;, &amp;quot;Equator&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3
## attr(,&amp;quot;match.length&amp;quot;)
## [1] 3
## attr(,&amp;quot;index.type&amp;quot;)
## [1] &amp;quot;chars&amp;quot;
## attr(,&amp;quot;useBytes&amp;quot;)
## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#gregexpr(pattern,x)与前一个功能一样
#不过它会寻找与pattern匹配的全部子字符串的起始位置
gregexpr(&amp;quot;iss&amp;quot;, &amp;quot;Missppiissist&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 2 8
## attr(,&amp;quot;match.length&amp;quot;)
## [1] 3 3
## attr(,&amp;quot;index.type&amp;quot;)
## [1] &amp;quot;chars&amp;quot;
## attr(,&amp;quot;useBytes&amp;quot;)
## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gregexpr(&amp;quot;uat&amp;quot;, &amp;quot;Equator&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [1] 3
## attr(,&amp;quot;match.length&amp;quot;)
## [1] 3
## attr(,&amp;quot;index.type&amp;quot;)
## [1] &amp;quot;chars&amp;quot;
## attr(,&amp;quot;useBytes&amp;quot;)
## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;section-3&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.5 其他实用函数&lt;/h3&gt;
&lt;p&gt;对象x的长度：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(1,2,3,4,5,6)
length(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成一个序列：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mysequ &amp;lt;- seq(1,20,3)
mysequ&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1  4  7 10 13 16 19&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将x重复n次：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(&amp;quot;ABC&amp;quot;,3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;ABC&amp;quot; &amp;quot;ABC&amp;quot; &amp;quot;ABC&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(1:3,3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 1 2 3 1 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将连续型变量x分割为有着n个水平的因子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(1:1000)
cut(x, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    [1] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##    [6] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [11] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [16] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [21] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [26] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [31] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [36] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [41] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [46] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [51] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [56] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [61] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [66] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [71] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [76] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [81] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [86] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [91] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##   [96] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [101] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [106] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [111] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [116] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [121] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [126] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [131] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [136] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [141] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [146] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [151] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [156] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [161] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [166] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [171] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [176] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [181] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [186] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [191] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [196] (0.001,201] (0.001,201] (0.001,201] (0.001,201] (0.001,201]
##  [201] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [206] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [211] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [216] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [221] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [226] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [231] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [236] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [241] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [246] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [251] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [256] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [261] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [266] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [271] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [276] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [281] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [286] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [291] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [296] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [301] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [306] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [311] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [316] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [321] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [326] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [331] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [336] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [341] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [346] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [351] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [356] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [361] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [366] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [371] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [376] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [381] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [386] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [391] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [396] (201,401]   (201,401]   (201,401]   (201,401]   (201,401]  
##  [401] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [406] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [411] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [416] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [421] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [426] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [431] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [436] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [441] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [446] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [451] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [456] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [461] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [466] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [471] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [476] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [481] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [486] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [491] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [496] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [501] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [506] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [511] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [516] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [521] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [526] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [531] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [536] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [541] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [546] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [551] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [556] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [561] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [566] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [571] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [576] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [581] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [586] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [591] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [596] (401,600]   (401,600]   (401,600]   (401,600]   (401,600]  
##  [601] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [606] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [611] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [616] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [621] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [626] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [631] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [636] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [641] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [646] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [651] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [656] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [661] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [666] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [671] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [676] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [681] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [686] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [691] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [696] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [701] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [706] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [711] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [716] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [721] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [726] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [731] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [736] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [741] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [746] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [751] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [756] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [761] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [766] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [771] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [776] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [781] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [786] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [791] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [796] (600,800]   (600,800]   (600,800]   (600,800]   (600,800]  
##  [801] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [806] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [811] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [816] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [821] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [826] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [831] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [836] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [841] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [846] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [851] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [856] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [861] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [866] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [871] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [876] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [881] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [886] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [891] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [896] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [901] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [906] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [911] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [916] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [921] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [926] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [931] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [936] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [941] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [946] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [951] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [956] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [961] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [966] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [971] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [976] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [981] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [986] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [991] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
##  [996] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03] (800,1e+03]
## Levels: (0.001,201] (201,401] (401,600] (600,800] (800,1e+03]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建美观的分割点。通过选取n+1个等间距的取整值，将一个连续型变量x分割为n个区间：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- pretty(c(-3,3), 30)
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] -3.0 -2.8 -2.6 -2.4 -2.2 -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4
## [15] -0.2  0.0  0.2  0.4  0.6  0.8  1.0  1.2  1.4  1.6  1.8  2.0  2.2  2.4
## [29]  2.6  2.8  3.0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第二章-5</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-5/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-5/</guid>
      <description>


&lt;div id=&#34;section&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.3 数据的输入&lt;/h2&gt;
&lt;p&gt;前面讲了好多的函数以及R的基础知识，但是没有数据怎么办呢?
下面就介绍几种输入数据的方法。&lt;/p&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.3.1 使用键盘输入数据&lt;/h3&gt;
&lt;p&gt;这是最简单的了，不过只适用于少量的数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#newdata &amp;lt;- data.frame(age=numeric(),sex=character(),weight=numeric())
#newdata &amp;lt;- edit(newdata)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面创建了一个数据框newdata，其中包含两个数值型变量age以及weight，一个字符型变量sex。
然后用edit()命令调用文本编辑器，输入数据。
图我就不展示了，总之就是可以直接用键盘输入数据了。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.3.2 数据集的导入&lt;/h3&gt;
&lt;p&gt;前文说到直接用键盘输入数据只适用于少量的数据，那么，大量的数据怎么办。
也只能导入咯~这是一句废话。&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;从带分隔符的文本文件导入数据
用read.table()就可以了，导入数据之后，保存为数据框。
命令语法是这样的：
&amp;gt; read.table(file, header=TRUE, sep=“delimiter”,row.names=“names”)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里面，file就是要导入的ASCII文本文件；
header是一个表明首行是否包含了变量名的逻辑值；
sep用来指定分割数据的分隔符；
row.names是一个可选参数，用于指定一个或多个表示&lt;strong&gt;行标识符&lt;/strong&gt;的变量。&lt;/p&gt;
&lt;p&gt;下面是个例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Example2_1 &amp;lt;- read.table(&amp;quot;example2_1.csv&amp;quot;,                         header = TRUE,sep = &amp;quot;,&amp;quot;)
#Example2_1
#参数中的sep，可以用sep=&amp;quot;\t&amp;quot;来读取制表符分割的文件
#此参数的默认值为sep=&amp;quot;&amp;quot;，即表示分隔符可以是一个或多个空格
#或者制表符，换行符以及回车符&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;导入excel数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，对于一般不做生信的人来说，csv文件其实不常见，常用的excel的数据。
对于这种文件用下面的方法导入，当然方法很多，这只是其中一个：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#install.packages(&amp;quot;RODBC&amp;quot;)
#library(RODBC)
#Example2_2 &amp;lt;- odbcConnectExcel(&amp;quot;example2_2.xls&amp;quot;)
#mydata &amp;lt;- sqlFetch(Example2_2, &amp;quot;sheet1&amp;quot;)
#odbcClose(Example2_2)&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;导入SPSS数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见的格式还是SPSS数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#library(Hmisc)
#use.value.labels=TRUE这个参数让函数将带有值标签的标量
#导入为R中水平对应的因子。
#mydata &amp;lt;- spss.get(&amp;quot;mydata.sav&amp;quot;, use.value.labels=TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，就这样了，第二章断断续续地结束了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第二章-2</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-2/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-2/</guid>
      <description>


&lt;p&gt;Hello，大家好，Dr.二哈又回来了。可能没什么人看，嗯，就说给自己听吧。 去年本来想继续更新的，结果12月初开题，从预开题开始就被训的不行，一直忙的焦头烂额。好不容易开题过了，结果后院又起火了，找师姐帮忙灭火之后，又开始重新处理之前的数据，还要忙着我爸妈和我老婆的父母见面~&lt;/p&gt;
&lt;p&gt;汗~&lt;/p&gt;
&lt;p&gt;不过现在稍微轻松点了，该弄的都差不多了。 于是我又回来了。 闲话不多说，继续去年未完成的第二章。&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;因子 变量可以分成三种，名义型，有序型以及连续型。名义型就是没有顺序之分的&lt;strong&gt;类别变量&lt;/strong&gt;。而有序型则表示存在一种顺序关系，而非数量关系。连续型则可以呈现为某个范围内的任意值，并且可以同时表示&lt;strong&gt;顺序&lt;/strong&gt;和&lt;strong&gt;数量&lt;/strong&gt;。比如年龄就是一个连续型变量。 类别（名义型）以及有序类别（有序型）变量，在R中，被称为&lt;strong&gt;因子&lt;/strong&gt;。它的思想来源于统计学中的名义变量或分类变量，这些变量本质上不是数字，而是对应分类。例如&lt;strong&gt;血型&lt;/strong&gt;，尽管可以用数字对其编码，但它还是分类的。 函数factor()可以以一个整数向量的形式存储&lt;strong&gt;类别值&lt;/strong&gt;，将一个由字符串（原始值）组成的内部向量映射到这些整数上。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;hypertention &amp;lt;- c(&amp;quot;yes&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;yes&amp;quot;)
#下面这个语句将原来的hypertention向量存储为（2,1,1,2）
#并在内部将其关联为1=no，2=yes（根据字幕顺序而定）
#因此，针对向量hypertention进行的任何分析都会将其作为名义型变量对待
hypertention &amp;lt;- factor(hypertention)
hypertention&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] yes no  no  yes
## Levels: no yes&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(hypertention)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Factor w/ 2 levels &amp;quot;no&amp;quot;,&amp;quot;yes&amp;quot;: 2 1 1 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在R中，因子可以简单地理解为一个附加更多信息的向量。这额外的信息包括向量中不同值的记录，被称为&lt;strong&gt;“水平”&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- c(5, 12, 13, 12)
x &amp;lt;- factor(x)
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5  12 13 12
## Levels: 5 12 13&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Factor w/ 3 levels &amp;quot;5&amp;quot;,&amp;quot;12&amp;quot;,&amp;quot;13&amp;quot;: 1 2 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，x中不同数值（5，12，13）就是水平。x的核心是（1，2，3，2），意味着这个数据是由水平1，水平2和水平3的&lt;strong&gt;值&lt;/strong&gt;构成的。因此，数据已经重新编码成水平，当然，水平本身也被记录下来。要注意的是，因子的长度被定义为数据的长度，而不是水平的个数。 要表示有序型变量，需要为factor()指定参数ordered=TRUE。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;severity &amp;lt;- c(&amp;quot;high&amp;quot;, &amp;quot;middle&amp;quot;, &amp;quot;low&amp;quot;, &amp;quot;middle&amp;quot;)
#下面这个语句将向量编码为（1,3,2,3），并在内部将这些值关联为1=high，2=low以及3=middle
severity &amp;lt;- factor(severity, ordered = TRUE)
severity&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] high   middle low    middle
## Levels: high &amp;lt; low &amp;lt; middle&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;str(severity)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Ord.factor w/ 3 levels &amp;quot;high&amp;quot;&amp;lt;&amp;quot;low&amp;quot;&amp;lt;&amp;quot;middle&amp;quot;: 1 3 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的一点是，对于字符型向量，因子的水平默认按字母顺序创建，所以水平“high”，“middle”，“low”的排序与逻辑顺序不一致。 可以通过指定levels选项来覆盖默认排序。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;severity &amp;lt;- factor(severity, ordered = TRUE, levels = c(&amp;quot;low&amp;quot;, &amp;quot;middle&amp;quot;,&amp;quot;high&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就会按逻辑顺序排列了。 下面的一段代码将展示因子如何影响数据分析结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;IDnumber &amp;lt;- c(101, 102, 103, 104)
age &amp;lt;- c(24, 78, 56, 45)
hypertention &amp;lt;- c(&amp;quot;yes&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;yes&amp;quot;)
severity &amp;lt;- c(&amp;quot;high&amp;quot;, &amp;quot;middle&amp;quot;, &amp;quot;low&amp;quot;, &amp;quot;middle&amp;quot;)
hypertention &amp;lt;- factor(hypertention)
severity &amp;lt;- factor(severity, ordered = TRUE)
patientdata &amp;lt;- data.frame(IDnumber, age, hypertention, severity)
str(patientdata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;data.frame&amp;#39;:    4 obs. of  4 variables:
##  $ IDnumber    : num  101 102 103 104
##  $ age         : num  24 78 56 45
##  $ hypertention: Factor w/ 2 levels &amp;quot;no&amp;quot;,&amp;quot;yes&amp;quot;: 2 1 1 2
##  $ severity    : Ord.factor w/ 3 levels &amp;quot;high&amp;quot;&amp;lt;&amp;quot;low&amp;quot;&amp;lt;&amp;quot;middle&amp;quot;: 1 3 2 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(patientdata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     IDnumber          age        hypertention   severity
##  Min.   :101.0   Min.   :24.00   no :2        high  :1  
##  1st Qu.:101.8   1st Qu.:39.75   yes:2        low   :1  
##  Median :102.5   Median :50.50                middle:2  
##  Mean   :102.5   Mean   :50.75                          
##  3rd Qu.:103.2   3rd Qu.:61.50                          
##  Max.   :104.0   Max.   :78.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯~~今天就到这里了。 有点短哈，不过反正也只是给自己看看的，这话说着好心酸啊。 自己学到了就好了。 再练会钢笔字就回寝室。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计分析与应用-第二章-1</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-1/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0-1/</guid>
      <description>


&lt;p&gt;写在前面的话，R语言统计分析与应用这本书的第一章是讲的怎么下载与安装R，这里就不再赘述了。下面开始第二章。 这本书我决定不再像之前那本书一样，照着书上写，这本书会加入自己的吐槽，只不过在代码上保持一致。 # 第二章 R编程入门 在学习R的时候，总会发现，自己编写一些函数还是比较爽的。在介绍编程之前，首先回顾下R的基础知识。 ## 2.1.1 数据集的概念 这个数据集，对于R语言而言非常重要，在我日常处理的时候，往往因为数据集的问题而导致R报错。看来基础知识还是要掌握地扎实才可以。 1. 向量 这个是R组基础的东西了，是一系列元素的组合，可以存储数值型、字符型或者逻辑型的数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建一个向量
#数值型
a &amp;lt;- c(1,2,3,4,10,-9,20)
#字符型
b &amp;lt;- c(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;)
#逻辑型
c &amp;lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE)
#字符型
d &amp;lt;- c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有的时候想查询某个向量中的某个元素，可以这样做：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- c(1,3,5,9,7,10,23,21,17)
#查询第二个元素
d[2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第二到第五个元素
d[2:5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3 5 9 7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询某几个元素
d[c(1,2,6,7)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1  3 10 23&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;矩阵 矩阵就是线性代数里的概念，是个二维数组，每个元素是相同的类型（同为数值、同为字符或者同为逻辑），可通过函数matrix创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建一个4行，5列的矩阵，数值排列为按列
x &amp;lt;- matrix(21:40, nrow = 4, ncol = 5, byrow = FALSE)
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4] [,5]
## [1,]   21   25   29   33   37
## [2,]   22   26   30   34   38
## [3,]   23   27   31   35   39
## [4,]   24   28   32   36   40&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建一个含有列名标签的矩阵，并按行排列数值
fourcell &amp;lt;- c(1,2,3,10,20,30)
rnames &amp;lt;- c(&amp;quot;R1&amp;quot;, &amp;quot;R2&amp;quot;)
cnames &amp;lt;- c(&amp;quot;C1&amp;quot;, &amp;quot;C2&amp;quot;, &amp;quot;C3&amp;quot;)
mymatrix &amp;lt;- matrix(fourcell, nrow = 2, ncol = 3, byrow = TRUE,
                   dimnames = list(rnames, cnames))
mymatrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    C1 C2 C3
## R1  1  2  3
## R2 10 20 30&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建一个含有列名标签的矩阵，并按列排列数值
mymatrix1 &amp;lt;- matrix(fourcell, nrow = 2, ncol = 3, byrow = FALSE,
                   dimnames = list(rnames, cnames))
mymatrix1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    C1 C2 C3
## R1  1  3 20
## R2  2 10 30&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似于向量，矩阵也可以用类似的方式查询某行某列的元素。 不过要从向量的一维推广到矩阵的二维。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;aa &amp;lt;- matrix(1:20, nrow = 5)
aa&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第三行
aa[3,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  3  8 13 18&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第三列
aa[,3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 11 12 13 14 15&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第三行的第三、第四列元素
aa[3,c(3,4)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13 18&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第三行第三列元素
aa[3,3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 13&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第三、第四列元素
aa[,c(3,4)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]   11   16
## [2,]   12   17
## [3,]   13   18
## [4,]   14   19
## [5,]   15   20&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;数组 矩阵只能是二维的，这是必须的&lt;sub&gt;~&lt;/sub&gt;，而要创建2维以上的，则要用到数组了创建函数是array(vector, dimensions, dimnames)，其中的参数vector是数组中的数据，dimensions是一个数值型向量，给出了各个维度下标的最大值，而dimnames则是各维度名称的列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dim1 &amp;lt;- c(&amp;quot;X1&amp;quot;, &amp;quot;X2&amp;quot;)
dim2 &amp;lt;- c(&amp;quot;Y1&amp;quot;, &amp;quot;Y2&amp;quot;, &amp;quot;Y3&amp;quot;)
dim3 &amp;lt;- c(&amp;quot;Z1&amp;quot;, &amp;quot;Z2&amp;quot;, &amp;quot;Z3&amp;quot;, &amp;quot;Z4&amp;quot;)
#这个数组中c(4,3,2)代表着，与dimnames对应，dim3最多有4个数值，dim2最多有3个数值，dim1最多有2个数值
xyz &amp;lt;- array(1:24, c(4,3,2), dimnames = list(dim3, dim2, dim1))
xyz&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## , , X1
## 
##    Y1 Y2 Y3
## Z1  1  5  9
## Z2  2  6 10
## Z3  3  7 11
## Z4  4  8 12
## 
## , , X2
## 
##    Y1 Y2 Y3
## Z1 13 17 21
## Z2 14 18 22
## Z3 15 19 23
## Z4 16 20 24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的查询方式与矩阵类似。为方便理解，将X定义为“长”，Y定义为“宽”，Z则定义为“高”.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询高下标为1，宽下标为2的元素
xyz[1,2,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## X1 X2 
##  5 17&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询高下标为1，宽下标为3的元素
xyz[1,3,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## X1 X2 
##  9 21&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询宽下标为2，长下标为2的元素
xyz[,2,2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Z1 Z2 Z3 Z4 
## 17 18 19 20&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询高下标为3，宽下标为2，长下标为1的元素
xyz[3,2,1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;数据框 这个数据框与SPSS中看到的数据集类似。不同的列可以包含不同类型的元素（数值型、字符型等）。这也是R中最常见的数据结构。有些时候，矩阵不够用的情况下，这个数据框就会起很大作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;IDnumber &amp;lt;- c(101,102,103,104)
age &amp;lt;- c(24,78,56,45)
hypertention &amp;lt;- c(&amp;quot;yes&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;no&amp;quot;, &amp;quot;yes&amp;quot;)
severity &amp;lt;- c(&amp;quot;high&amp;quot;, &amp;quot;middle&amp;quot;, &amp;quot;low&amp;quot;, &amp;quot;middle&amp;quot;)
patientdata &amp;lt;- data.frame(IDnumber, age, hypertention, severity)
patientdata&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   IDnumber age hypertention severity
## 1      101  24          yes     high
## 2      102  78           no   middle
## 3      103  56           no      low
## 4      104  45          yes   middle&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据框中选取元素可以用很多种方式，既可以用矩阵、数组的下标方法，也可以直接指定列名。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第一列也就是IDnumber
patientdata[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   IDnumber
## 1      101
## 2      102
## 3      103
## 4      104&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询第一列以及第二列，也就是IDnumber和age
patientdata[1:2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   IDnumber age
## 1      101  24
## 2      102  78
## 3      103  56
## 4      104  45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询age这一列
patientdata[&amp;quot;age&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   age
## 1  24
## 2  78
## 3  56
## 4  45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询age和severity
patientdata[&amp;quot;age&amp;quot;, &amp;quot;sverity&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查询age中的元素
patientdata$age&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 24 78 56 45&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个“$”符号是比较常用的使用方法，它被用来选取一个给定数据框的某个特定变量。也可以联合使用attach()和detach()函数，或者单独使用with()函数来简化代码……&lt;/p&gt;
&lt;p&gt;书上是这么说的，但我觉得，“$”这个符号在日后阅读代码时比较好理解。&lt;/p&gt;
&lt;p&gt;attach()函数可以将数据框添加到R的搜索路径中。而detach()函数将数据框从搜索路径中移除。下面的代码获取年龄（age）变量的描述性统计，并分别绘制age变量与收缩压（hypertention）的散点图。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;systolic &amp;lt;- c(120,130,140,150,160)
age &amp;lt;- c(20,30,40,50,55)
hypertention &amp;lt;- data.frame(systolic, age)
hypertention&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   systolic age
## 1      120  20
## 2      130  30
## 3      140  40
## 4      150  50
## 5      160  55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(hypertention$age)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      20      30      40      39      50      55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(hypertention$systolic)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     120     130     140     140     150     160&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(hypertention$age, hypertention$systolic)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-12-03-r语言统计分析与应用_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#上面代码也可以简化为
attach(hypertention)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked _by_ .GlobalEnv:
## 
##     age, systolic&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(age)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      20      30      40      39      50      55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(systolic)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     120     130     140     140     150     160&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(systolic, age)
detach(hypertention)
#或者
with(hypertention,{
  summary(age)
  summary(systolic)
  plot(systolic, age)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-12-03-r语言统计分析与应用_files/figure-html/unnamed-chunk-9-2.png&#34; width=&#34;672&#34; /&gt; 但是with()函数有一个特殊情况需要注意，如果出现with()里要对某个不在原数据框中的变量赋值，那这个变量若不注意赋值格式，则会出现下面的问题。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;with(hypertention, {
  stat &amp;lt;- summary(age)
  stat
})&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      20      30      40      39      50      55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个时候如果输入stat，则会出现“找不到对象‘stat’”&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个问题就出在赋值符号&amp;lt;-上，如果要创建在with()结构以外存在的对象，则要用“&amp;lt;&amp;lt;-”符号代替“&amp;lt;-”。这样，这个对象就可以保存在with()之外的全局环境中。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;with(hypertention, {
  stat &amp;lt;&amp;lt;- summary(age)
})
#这个时候stat就成为全局变量了
stat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##      20      30      40      39      50      55&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第十一章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第十一章 多元回归&lt;/h1&gt;
&lt;p&gt;终于到了在统计中最常见的多元回归了~这本书之前都在讲什么&lt;/p&gt;
&lt;p&gt;首先介绍下多元回归的基本模型： &lt;span class=&#34;math display&#34;&gt;\[
y=\beta_0+\beta_1x_1+\cdot\cdot\cdot+\beta_kx_k+\epsilon
\]&lt;/span&gt; 其中，&lt;span class=&#34;math inline&#34;&gt;\(x_1,...,x_k\)&lt;/span&gt;等是解释变量（也叫作预测变量）；模型参数&lt;span class=&#34;math inline&#34;&gt;\(\beta_1,...,\beta_k\)&lt;/span&gt;可通过最小二乘法估计得出（具体参见6.1节）。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;11.1 多维数据绘图&lt;/h2&gt;
&lt;p&gt;下面以Altman（1991）提到的一个关于囊胞性纤维症患者肺功能的研究为例子。数据包含在ISwR包内的cystfibr数据框中。&lt;/p&gt;
&lt;p&gt;使用pairs函数可以绘制数据集中任意两个变量间的散点图：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
par(mex = 0.5)
pairs(cystfibr, gap = 0, cex.labels = 0.9)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-09-10-r语言统计入门-第十一章_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在这个代码中，参数gap和cex.lables用来控制图形的外观。前者用来移除各个子图之间的图间距，后者用来缩放图中的字号，而绘图命令mex则用来减少图形边界的行间距。&lt;/p&gt;
&lt;p&gt;用plot命令也能做出类似的图：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(cystfibr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-09-10-r语言统计入门-第十一章_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;用pairs命令得到的那个图，各个子图相对较小，不适合直接放在论文中。不过，这种图形可以清晰的看到多维数据的整体情况，比如，就可以看到age、height和weight具有强相关关系。&lt;/p&gt;
&lt;p&gt;为了便于直接引用cystfibr数据集中的变量。可以将该数据集加入到当前的搜索路径中：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(cystfibr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from package:ISwR:
## 
##     tlc&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;11.2 模型设定和模型输出&lt;/h2&gt;
&lt;p&gt;多元回归分析的模型是通过在模型公式中的解释变量（~应该就是自变量）之间添加+号来实现：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意一点，在之前分工作目录中可能会存在名称相同的变量，比如age这个变量，因此在运行这个命令前，需要清空工作目录。
lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc+tlc)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1 + 
##     rv + frc + tlc)
## 
## Coefficients:
## (Intercept)          age          sex       height       weight  
##    176.0582      -2.5420      -3.7368      -0.4463       2.9928  
##         bmp         fev1           rv          frc          tlc  
##     -1.7449       1.0807       0.1970      -0.3084       0.1886&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个公式意思就是，pemax这个变量可由一个包含变量age、sex等组成的模型来描述（pemax是患者的最大呼气压力）。&lt;/p&gt;
&lt;p&gt;与前面一样，lm函数返回的结果有限，然而，借助summary函数可以得到更多有趣的结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc+tlc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1 + 
##     rv + frc + tlc)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -37.338 -11.532   1.081  13.386  33.405 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)
## (Intercept) 176.0582   225.8912   0.779    0.448
## age          -2.5420     4.8017  -0.529    0.604
## sex          -3.7368    15.4598  -0.242    0.812
## height       -0.4463     0.9034  -0.494    0.628
## weight        2.9928     2.0080   1.490    0.157
## bmp          -1.7449     1.1552  -1.510    0.152
## fev1          1.0807     1.0809   1.000    0.333
## rv            0.1970     0.1962   1.004    0.331
## frc          -0.3084     0.4924  -0.626    0.540
## tlc           0.1886     0.4997   0.377    0.711
## 
## Residual standard error: 25.47 on 15 degrees of freedom
## Multiple R-squared:  0.6373, Adjusted R-squared:  0.4197 
## F-statistic: 2.929 on 9 and 15 DF,  p-value: 0.03195&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，这个结果表明所有变量对应的 &lt;em&gt;t&lt;/em&gt; 值都不显著，但是，联合 &lt;em&gt;F&lt;/em&gt; 检验的结果却是显著的，这一定是有原因的。&lt;/p&gt;
&lt;p&gt;这个原因就在于，&lt;em&gt;t&lt;/em&gt; 检验说明的是仅仅是，当从模型中删除某个变量而保留其他变量时模型的变化结果；对于变量在简化模型中是否统计显著，则没有做出说明；值得注意的是，&lt;em&gt;t&lt;/em&gt; 检验认为&lt;strong&gt;没有一个变量&lt;/strong&gt;是&lt;strong&gt;不能&lt;/strong&gt;从模型中删除的。&lt;/p&gt;
&lt;p&gt;注意，输出结果中未调整R&lt;sup&gt;2&lt;/sup&gt;（Multiple R-squared）和调整后R&lt;sup&gt;2&lt;/sup&gt;（Adjusted R-squared）有较大差异，这归咎于模型中较多的变量个数，而这个与方差的自由度密切相关。前者表示的是与空模型相对的残差平方和的变化，后者对应的是残差方差的类似变化：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1-25.5^2/var(pemax)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.4183949&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，25.5这个数字取自summary函数输出结果中的&lt;strong&gt;残差标准误（Residual standard error）&lt;/strong&gt;。通过anova函数可以得到多元回归分析对应的方差分析表，该表给出了一个截然不同的模型结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc+tlc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: pemax
##           Df  Sum Sq Mean Sq F value   Pr(&amp;gt;F)   
## age        1 10098.5 10098.5 15.5661 0.001296 **
## sex        1   955.4   955.4  1.4727 0.243680   
## height     1   155.0   155.0  0.2389 0.632089   
## weight     1   632.3   632.3  0.9747 0.339170   
## bmp        1  2862.2  2862.2  4.4119 0.053010 . 
## fev1       1  1549.1  1549.1  2.3878 0.143120   
## rv         1   561.9   561.9  0.8662 0.366757   
## frc        1   194.6   194.6  0.2999 0.592007   
## tlc        1    92.4    92.4  0.1424 0.711160   
## Residuals 15  9731.2   648.7                    
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，除了最后一行（对应于变量tlc）之外，这里的 &lt;em&gt;F&lt;/em&gt; 检验结果与summary函数输出的 &lt;em&gt;t&lt;/em&gt; 检验结果几乎完全相悖。这里，age变量的检验结果变得显著了，导致这种结果的原因在于这里的检验过程是逐步进行的；具体而言，对应于（从下至上）将变量逐个从模型中移除，直至剩下age变量。在该过程中，变量bmp的检验结果一度接近5%的临界点，但考虑到检验的个数，这一结果几乎不显著。&lt;/p&gt;
&lt;p&gt;在8次独立的检验中，结果给出小于等于0.053的 &lt;em&gt;p&lt;/em&gt; 值的概率仅仅略高于35%。虽然ANOVA表中的检验并非完全独立，但是其近似结果还是不错的。&lt;/p&gt;
&lt;p&gt;ANOVA表的输出结果表明在模型已包含age变量的情况下，再添加其他变量，模型准确度并未得到显著的提高。可以进行联合检验，看看是否可以将age以外的变量全部去掉，做法是求贡献值的平方和加，再对总和进行 &lt;em&gt;F&lt;/em&gt; 检验：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;955.4+155.0+632.3+2862.2+1549.1+561.9+194.6+92.4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7002.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;7002.9/8&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 875.3625&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;875.36/648.7&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.349407&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1-pf(1.349407, 8,15)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.2935148&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应于去掉边框线的表格，它看起来是这样的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Df&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Sum Sq&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Mean Sq&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;F&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Pr(&amp;gt;F)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;age&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10098.5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10098.5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15.566&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.00130&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;others&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7002.9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;875.4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.349&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.29351&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Residual&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9731.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;648.7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这个表格是自己根据数据整理的~不是系统的输出。&lt;/p&gt;
&lt;p&gt;如要直接得到上述结果，可运行：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;m1 &amp;lt;- lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc+tlc)
m2 &amp;lt;- lm(pemax~age)
anova(m1, m2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Model 1: pemax ~ age + sex + height + weight + bmp + fev1 + rv + frc + 
##     tlc
## Model 2: pemax ~ age
##   Res.Df     RSS Df Sum of Sq      F Pr(&amp;gt;F)
## 1     15  9731.2                           
## 2     23 16734.2 -8   -7002.9 1.3493 0.2936&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;11.3 模型筛选&lt;/h2&gt;
&lt;p&gt;R有一个按照赤池信息准则（Akaike Information Criterion）进行模型筛选的函数step()。而这个本书不讲~~&lt;/p&gt;
&lt;p&gt;本书只使用一种较为简单的人工向后消元法。&lt;/p&gt;
&lt;p&gt;下面是一个模型降阶的例子，注意，为减少输出结果占用的空间，对输出信息进行了编辑：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#书上是只保留了Coefficients这一项
summary(lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc+tlc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1 + 
##     rv + frc + tlc)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -37.338 -11.532   1.081  13.386  33.405 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)
## (Intercept) 176.0582   225.8912   0.779    0.448
## age          -2.5420     4.8017  -0.529    0.604
## sex          -3.7368    15.4598  -0.242    0.812
## height       -0.4463     0.9034  -0.494    0.628
## weight        2.9928     2.0080   1.490    0.157
## bmp          -1.7449     1.1552  -1.510    0.152
## fev1          1.0807     1.0809   1.000    0.333
## rv            0.1970     0.1962   1.004    0.331
## frc          -0.3084     0.4924  -0.626    0.540
## tlc           0.1886     0.4997   0.377    0.711
## 
## Residual standard error: 25.47 on 15 degrees of freedom
## Multiple R-squared:  0.6373, Adjusted R-squared:  0.4197 
## F-statistic: 2.929 on 9 and 15 DF,  p-value: 0.03195&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;人工进行模型降阶的优点在于该模型引入逻辑结构。在本利中，很自然地会先想到去掉肺功能的指标。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+sex+height+weight+bmp+fev1+rv+frc))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1 + 
##     rv + frc)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -38.072 -10.067   0.113  13.526  36.990 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 221.8055   185.4350   1.196   0.2491  
## age          -3.1346     4.4144  -0.710   0.4879  
## sex          -4.6933    14.8363  -0.316   0.7558  
## height       -0.5428     0.8428  -0.644   0.5286  
## weight        3.3157     1.7672   1.876   0.0790 .
## bmp          -1.9403     1.0047  -1.931   0.0714 .
## fev1          1.0183     1.0392   0.980   0.3417  
## rv            0.1857     0.1887   0.984   0.3396  
## frc          -0.2605     0.4628  -0.563   0.5813  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 24.78 on 16 degrees of freedom
## Multiple R-squared:  0.6339, Adjusted R-squared:  0.4508 
## F-statistic: 3.463 on 8 and 16 DF,  p-value: 0.01649&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+sex+height+weight+bmp+fev1+rv))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1 + 
##     rv)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -39.425 -12.391   3.834  14.797  36.693 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 166.71822  154.31294   1.080   0.2951  
## age          -1.81783    3.66773  -0.496   0.6265  
## sex           0.10239   11.89990   0.009   0.9932  
## height       -0.40981    0.79257  -0.517   0.6118  
## weight        2.87386    1.55120   1.853   0.0814 .
## bmp          -1.94971    0.98415  -1.981   0.0640 .
## fev1          1.41526    0.74788   1.892   0.0756 .
## rv            0.09567    0.09798   0.976   0.3425  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 24.28 on 17 degrees of freedom
## Multiple R-squared:  0.6266, Adjusted R-squared:  0.4729 
## F-statistic: 4.076 on 7 and 17 DF,  p-value: 0.008452&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+sex+height+weight+bmp+fev1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp + fev1)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -43.238  -7.403  -0.081  15.534  36.028 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 260.6313   120.5215   2.163   0.0443 *
## age          -2.9062     3.4898  -0.833   0.4159  
## sex          -1.2115    11.8083  -0.103   0.9194  
## height       -0.6067     0.7655  -0.793   0.4384  
## weight        3.3463     1.4719   2.273   0.0355 *
## bmp          -2.3042     0.9136  -2.522   0.0213 *
## fev1          1.0274     0.6329   1.623   0.1219  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 24.24 on 18 degrees of freedom
## Multiple R-squared:  0.6057, Adjusted R-squared:  0.4743 
## F-statistic: 4.608 on 6 and 18 DF,  p-value: 0.00529&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+sex+height+weight+bmp))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + sex + height + weight + bmp)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -43.194  -9.412  -2.425   9.157  40.112 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 280.4482   124.9556   2.244   0.0369 *
## age          -3.0750     3.6352  -0.846   0.4081  
## sex         -11.5281    10.3720  -1.111   0.2802  
## height       -0.6853     0.7962  -0.861   0.4001  
## weight        3.5546     1.5281   2.326   0.0312 *
## bmp          -1.9613     0.9263  -2.117   0.0476 *
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 25.27 on 19 degrees of freedom
## Multiple R-squared:  0.548,  Adjusted R-squared:  0.429 
## F-statistic: 4.606 on 5 and 19 DF,  p-value: 0.006388&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上上述结果看，去掉4个肺功能相关的变量没什么不妥，接下来尝试删除那些描述病人身体发育状态或尺寸信息的变量。在开始时，尽量避免删除weight和bmp变量，因为它们对应的 &lt;em&gt;p&lt;/em&gt; 值很接近5%的显著性界限。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+height+weight+bmp))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + height + weight + bmp)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -41.501 -15.460  -2.838  11.082  42.991 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 274.5307   125.5745   2.186   0.0409 *
## age          -3.0832     3.6566  -0.843   0.4091  
## height       -0.6985     0.8008  -0.872   0.3934  
## weight        3.6338     1.5354   2.367   0.0282 *
## bmp          -1.9621     0.9317  -2.106   0.0480 *
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 25.41 on 20 degrees of freedom
## Multiple R-squared:  0.5186, Adjusted R-squared:  0.4223 
## F-statistic: 5.386 on 4 and 20 DF,  p-value: 0.004137&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~height+weight+bmp))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ height + weight + bmp)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -41.794 -11.764  -1.218  13.202  43.631 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)  
## (Intercept) 245.3936   119.8927   2.047   0.0534 .
## height       -0.8264     0.7808  -1.058   0.3019  
## weight        2.7717     1.1377   2.436   0.0238 *
## bmp          -1.4876     0.7375  -2.017   0.0566 .
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 25.24 on 21 degrees of freedom
## Multiple R-squared:  0.5015, Adjusted R-squared:  0.4302 
## F-statistic: 7.041 on 3 and 21 DF,  p-value: 0.00187&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~weight+bmp))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ weight + bmp)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -42.924 -13.399   4.361  16.642  48.404 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) 124.8297    37.4786   3.331 0.003033 ** 
## weight        1.6403     0.3900   4.206 0.000365 ***
## bmp          -1.0054     0.5814  -1.729 0.097797 .  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 25.31 on 22 degrees of freedom
## Multiple R-squared:  0.4749, Adjusted R-squared:  0.4271 
## F-statistic: 9.947 on 2 and 22 DF,  p-value: 0.0008374&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~weight))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ weight)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -44.30 -22.69   2.23  15.91  48.41 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  63.5456    12.7016   5.003 4.63e-05 ***
## weight        1.1867     0.3009   3.944 0.000646 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 26.38 on 23 degrees of freedom
## Multiple R-squared:  0.4035, Adjusted R-squared:  0.3776 
## F-statistic: 15.56 on 1 and 23 DF,  p-value: 0.0006457&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，一旦删除age和height变量，变量bmp就不再显著了。在原文献（Altman，1991）中，变量weight、feval和bmp在最终结果中对应的 &lt;em&gt;p&lt;/em&gt;值都低于5%。然而，并非所有模型降阶过程都是如此。&lt;/p&gt;
&lt;p&gt;特别关注变量age、weight和height是个不错的想法，因为在处理儿童和青少年对应的数据时，这些变量表现出很强的相关性。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+height+weight))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + height + weight)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -43.675 -21.566   3.229  16.274  48.068 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)
## (Intercept) 64.65555   82.40935   0.785    0.441
## age          1.56755    3.14363   0.499    0.623
## height      -0.07608    0.80278  -0.095    0.925
## weight       0.86949    0.85922   1.012    0.323
## 
## Residual standard error: 27.41 on 21 degrees of freedom
## Multiple R-squared:  0.4118, Adjusted R-squared:  0.3278 
## F-statistic: 4.901 on 3 and 21 DF,  p-value: 0.009776&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age+height))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age + height)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -44.817 -17.883   3.815  18.275  53.824 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)
## (Intercept)  17.8600    68.2493   0.262    0.796
## age           2.7178     2.9325   0.927    0.364
## height        0.3397     0.6900   0.492    0.627
## 
## Residual standard error: 27.43 on 22 degrees of freedom
## Multiple R-squared:  0.3831, Adjusted R-squared:  0.3271 
## F-statistic: 6.832 on 2 and 22 DF,  p-value: 0.00492&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~age))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ age)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -48.666 -17.174   6.209  16.209  51.334 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)   
## (Intercept)   50.408     16.657   3.026  0.00601 **
## age            4.055      1.088   3.726  0.00111 **
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 26.97 on 23 degrees of freedom
## Multiple R-squared:  0.3764, Adjusted R-squared:  0.3492 
## F-statistic: 13.88 on 1 and 23 DF,  p-value: 0.001109&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(pemax~height))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = pemax ~ height)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -43.876 -19.306   1.787  18.170  61.464 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)   
## (Intercept) -33.2757    40.0445  -0.831  0.41453   
## height        0.9319     0.2596   3.590  0.00155 **
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 27.34 on 23 degrees of freedom
## Multiple R-squared:  0.3591, Adjusted R-squared:  0.3312 
## F-statistic: 12.89 on 1 and 23 DF,  p-value: 0.001549&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的结果可以看出，对于变量weight、height和age，没有证据表明哪个比另外两个好。上面所用的消元方法之所以在最后仅留下了weight作为自变量，完全是出于偶然。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在数据集secher中，对出生体重、腰围和二项骨的直径变量进行对数变换后可得到很好的数据分析结果。请拟合出生体重的预测表达式。在模型中同时纳入腹部直径和二项骨直径时，模型结果如何，模型中两个回归系数之和约为3，如何对其进行解释。&lt;/li&gt;
&lt;li&gt;数据集tlc有一个同名变量tlc，这不是一个很好的命名方式，请解释原因。用数据集中的其余变量来解释tlc变量，并对模型的有效性进行解释。&lt;/li&gt;
&lt;li&gt;数据集cystfibr的分析过程设计sex变量，它是一个二元变量，如何解释回归结果中对应的系数。&lt;/li&gt;
&lt;li&gt;考虑juul2数据集，并筛选出该数据集中年龄超过25岁的子集，用age变量对&lt;span class=&#34;math inline&#34;&gt;\(\sqrt{igfl}\)&lt;/span&gt;变量进行回归分析。在扩展模型中加入变量height和变量weight，计算扩展模型对应的方差分析表，有没有意想不到的结果出现，为什么会这样呢。&lt;/li&gt;
&lt;li&gt;使用多远回归模型，分析冰结师kfmdata数据集中各个解释变量对牛奶摄入量的影响。注意，这里的sex变量是因子型变量，这对分析过程有什么影响？&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第十章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%8D%81%E7%AB%A0/</link>
      <pubDate>Fri, 07 Sep 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%8D%81%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第十章 数据处理的高级技术&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;10.1 变量的重编码&lt;/h2&gt;
&lt;div id=&#34;cut&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.1.1 cut函数&lt;/h3&gt;
&lt;p&gt;有的时候可能需要将一个变量转换成一个分组因子。比如将数据分成5个年龄组进行展示，但是数据集中的年龄是一个定量变量，该变量的值对应的记录单位是整数年或者更细分的时间单位。这个时候就需要cut函数了。&lt;/p&gt;
&lt;p&gt;这个函数有两个基本参数：一个数值向量和一个节点向量。后者的作用是定义一系列数据区间以对变量进行分组。对于每一个区间，都得指定左右两个端点值——也就是说，节点的数目必须等于所有区间数目再加一。一个常见的错误是认为数据区间最外层的节点可以省略及所有区间外的点会被设定为NA。最外层的节点值可用-Inf和Inf来表示。&lt;/p&gt;
&lt;p&gt;默认情况下，数据区间是左开右闭的。也就是说，每个区间都包括右节点。除非设置include.lowest=TRUE使第一个区间成为闭区间，否则，第一个区间不会包含最小节点。&lt;/p&gt;
&lt;p&gt;在流行病学领域，人们可能更多地按照“40-49岁”这种年龄区间来对数据进行分组。这种与默认区间闭合方向相反的分组方式可以通过设置right=FALSE来得到。&lt;/p&gt;
&lt;p&gt;当然，当使用左闭右开类型的区间时，丢失最外区间端点的问题就转移到了最大节点那一端。此时，设定include.lowest事实上将使最大节点值包含到区间里面来。在下面的例子中，区别就在于区间结果是否包含两个年龄刚好16岁的样本。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
age &amp;lt;- subset(juul, age &amp;gt;= 10 &amp;amp; age &amp;lt;=16)$age
range(age)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 10.01 16.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agegr &amp;lt;- cut(age, seq(10, 16, 2),right = F, include.lowest = T)
length(age)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 502&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(agegr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## agegr
## [10,12) [12,14) [14,16] 
##     190     168     144&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;agegr2 &amp;lt;- cut(age, seq(10, 16, 2), right = F)
table(agegr2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## agegr2
## [10,12) [12,14) [14,16) 
##     190     168     142&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时候想要把数据进行等距分组。此时，可用4.1节中介绍过的quantile函数来生成区间节点。比如，可以运行如下的代码：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;q &amp;lt;- quantile(age, c(0, 0.25, 0.50, 0.75, 1))
q&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      0%     25%     50%     75%    100% 
## 10.0100 11.3825 12.6400 14.2275 16.0000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ageQ &amp;lt;- cut(age, q, include.lowest = T)
table(ageQ)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ageQ
##   [10,11.4] (11.4,12.6] (12.6,14.2]   (14.2,16] 
##         126         125         125         126&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时，cut函数返回的水平名字非常难看。好在可以方便地对其进行调整。如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;levels(ageQ) &amp;lt;- c(&amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, &amp;quot;4th&amp;quot;)
levels(agegr) &amp;lt;- c(&amp;quot;10-11&amp;quot;, &amp;quot;12-13&amp;quot;, &amp;quot;14-15&amp;quot;)
table(ageQ)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ageQ
## 1st 2nd 3rd 4th 
## 126 125 125 126&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(agegr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## agegr
## 10-11 12-13 14-15 
##   190   168   144&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附：Hmisc包中有一个cut2函数，该函数能对上述操作进行简化。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.1.2 处理因子&lt;/h3&gt;
&lt;p&gt;在1.2.8节中，使用levels &amp;lt;-…… 来改变因子的因子水平集合。&lt;/p&gt;
&lt;p&gt;本小节将继续讨论一些相关内容。&lt;/p&gt;
&lt;p&gt;首先，要注意到，将数值输入转化为因子以及对因子水平进行重命名的操作可以进一步完成：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pain &amp;lt;- c(0, 3, 2, 2, 1)
fpain &amp;lt;- factor(pain, levels = 0:3, labels = c(&amp;quot;none&amp;quot;, &amp;quot;mild&amp;quot;, &amp;quot;medium&amp;quot;, &amp;quot;severe&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意levels与labels之间的区别。后者指的是输出结果的因子水平，而前者对应的是对输入向量的编码（这里对应的是变量pain）。更准确地说，levels指代的是函数输入，而lables指代的是函数的输出。&lt;/p&gt;
&lt;p&gt;若未指明levels参数，函数会将向量中出现的剔除重复项的值排序后作为因子水平。这种操作有时不尽人意，比如，对于文本型变量，系统默认按照“字典顺序”对其进行排序。考虑下面的例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;text.pain &amp;lt;- c(&amp;quot;none&amp;quot;, &amp;quot;severe&amp;quot;, &amp;quot;medium&amp;quot;, &amp;quot;medium&amp;quot;, &amp;quot;mild&amp;quot;)
factor(text.pain)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none   severe medium medium mild  
## Levels: medium mild none severe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;factor函数把因子当做字符型向量来处理，因而，，可以按照下面的方式来对因子水平的顺序进行重排。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ftpain &amp;lt;- factor(text.pain)
ftpain2 &amp;lt;- factor(ftpain, levels = c(&amp;quot;none&amp;quot;, &amp;quot;mild&amp;quot;, &amp;quot;medium&amp;quot;, &amp;quot;severe&amp;quot;))
ftpain&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none   severe medium medium mild  
## Levels: medium mild none severe&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ftpain2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none   severe medium medium mild  
## Levels: none mild medium severe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种典型的操作是将两个或多个因子水平进行合并。当各个分组内样本数目太少，无法进行有效的统计分析时，长长需要这样做。比如，可能想将上例中的“medium”水平合并成一个叫“intermediate”的因子水平。为了实现这个目的，levels的赋值形式允许右边是一个列表。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ftpain3 &amp;lt;- ftpain2
levels(ftpain3) &amp;lt;- list(none = &amp;quot;none&amp;quot;, intermediate = c(&amp;quot;mild&amp;quot;, &amp;quot;medium&amp;quot;), severe = &amp;quot;severe&amp;quot;)
ftpain3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none         severe       intermediate intermediate intermediate
## Levels: none intermediate severe&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，直接改变水平名字，给不同的组赋予相同的名字常常更为便捷：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ftpain4 &amp;lt;- ftpain2
levels(ftpain4) &amp;lt;- c(&amp;quot;none&amp;quot;, &amp;quot;intermediate&amp;quot;, &amp;quot;intermediate&amp;quot;, &amp;quot;severe&amp;quot;)
ftpain4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none         severe       intermediate intermediate intermediate
## Levels: none intermediate severe&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.1.3 日期的使用&lt;/h3&gt;
&lt;p&gt;在流行病学和生存数据领域，经常要处理按日历日期格式表示的时间变量。世界上各地使用的日期格式不同，有时，需要读取一些与我们所在地区的时间不同的日期数据。R中的“Date”类以及相关的转换程序可以方便地处理这些问题。&lt;/p&gt;
&lt;p&gt;下面以爱沙尼亚的中风研究数据为例。一个经过预处理的数据保存在数据框stroke中。原始数据保存在ISwR包中的rawdata文件夹中，运行下面的代码可以读入原始数据：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stroke &amp;lt;- read.csv2(
  system.file(&amp;quot;rawdata&amp;quot;, &amp;quot;stroke.csv&amp;quot;, package = &amp;quot;ISwR&amp;quot;),
  na.strings = &amp;quot;.&amp;quot;
)
names(stroke) &amp;lt;- tolower(names(stroke))
head(stroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex       died       dstr age dgn coma diab minf han
## 1   1  7.01.1991  2.01.1991  76 INF    0    0    1   0
## 2   1       &amp;lt;NA&amp;gt;  3.01.1991  58 INF    0    0    0   0
## 3   1  2.06.1991  8.01.1991  74 INF    0    0    1   1
## 4   0 13.01.1991 11.01.1991  77 ICH    0    1    0   1
## 5   0 23.01.1996 13.01.1991  76 INF    0    1    0   1
## 6   1 13.01.1991 13.01.1991  48 ICH    1    0    0   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的数据集中，两个日期变量died和dstr（date of stroke）被存储为因子型变量，这是read.table函数的默认输出结果。使用函数as.Date将他们转换为“Date”类。这种做法简单明了，但需要特别注意日期的格式。&lt;/p&gt;
&lt;p&gt;本例中使用的格式是用点号分割的（日，月份，年份）格式，其中，年份是用四位数字表示的。这种格式非标准格式，因此，需要明确指出：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这里使用百分号表示日期的各个组成部分
#%d表示某天
#%m表示某月
#%Y则是用四位数格式表示年份，注意Y是大写
stroke &amp;lt;- transform(stroke, 
                    died = as.Date(died, format=&amp;quot;%d.%m.%Y&amp;quot;),
                    dstr = as.Date(dstr, format = &amp;quot;%d.%m.%Y&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对日期可以进行算术操作，也就是说，它们的操作方式跟数值向量类似：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(stroke$died)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         Min.      1st Qu.       Median         Mean      3rd Qu. 
## &amp;quot;1991-01-07&amp;quot; &amp;quot;1992-03-14&amp;quot; &amp;quot;1993-01-23&amp;quot; &amp;quot;1993-02-15&amp;quot; &amp;quot;1993-11-04&amp;quot; 
##         Max.         NA&amp;#39;s 
## &amp;quot;1996-02-22&amp;quot;        &amp;quot;338&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(stroke$dstr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         Min.      1st Qu.       Median         Mean      3rd Qu. 
## &amp;quot;1991-01-02&amp;quot; &amp;quot;1991-11-08&amp;quot; &amp;quot;1992-08-12&amp;quot; &amp;quot;1992-07-27&amp;quot; &amp;quot;1993-04-30&amp;quot; 
##         Max. 
## &amp;quot;1993-12-31&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(stroke$died-stroke$dstr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   Length    Class     Mode 
##      829 difftime  numeric&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意结果的单位是天
head(stroke$died-stroke$dstr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Time differences in days
## [1]    5   NA  145    2 1836    0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在数据文件中，死亡日期对应为NA的记录表示病人没有在该项研究的结束日，即1996年1月1日前死亡。根据记录，共有6个病人死亡于该日期之后，然而，由于其他病人中很可能存在着死亡未被记录的情况，我们不得不舍弃这些死亡日期，将这些病人的状况记录为存活至研究结束日。 应当将上述数据进行转换，以使得每个病人都对应于一个结束日期以及显示病人在该结束日期时是存活还是死亡的指标。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#pmin函数用于计算最小值，但与只返回一个值的min函数不同，它并行地对多个向量进行计算
#na.rm参数允许函数在计算过程中忽略NA值
#所以死亡信息缺失或在1996-1-1之后死亡的个体，其死亡日期被记录为1996-1-1，否则就记录病人真正的死亡日期
#dead对象对应的表达式简单明了，但仍需检查缺失数据在处理过程中是否处理正确
stroke &amp;lt;- transform(stroke,
                    end = pmin(died, as.Date(&amp;quot;1991-1-1&amp;quot;, na.rm = T)),
                    dead = !is.na(died) &amp;amp; died &amp;lt; as.Date(&amp;quot;1996-1-1&amp;quot;))
head(stroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex       died       dstr age dgn coma diab minf han        end  dead
## 1   1 1991-01-07 1991-01-02  76 INF    0    0    1   0 1991-01-01  TRUE
## 2   1       &amp;lt;NA&amp;gt; 1991-01-03  58 INF    0    0    0   0       &amp;lt;NA&amp;gt; FALSE
## 3   1 1991-06-02 1991-01-08  74 INF    0    0    1   1 1991-01-01  TRUE
## 4   0 1991-01-13 1991-01-11  77 ICH    0    1    0   1 1991-01-01  TRUE
## 5   0 1996-01-23 1991-01-13  76 INF    0    1    0   1 1991-01-01 FALSE
## 6   1 1991-01-13 1991-01-13  48 ICH    1    0    0   1 1991-01-01  TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#最后，为了得到每个人的观测时长，运行如下代码
stroke &amp;lt;- transform(stroke,
                obstime= as.numeric(end - dstr, units = &amp;quot;days&amp;quot;)/365.25)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.1.4 多变量重编码&lt;/h3&gt;
&lt;p&gt;有时候可能一个数据集包含了大量需要重新编码的变量（比如调查问卷中的数据，可能有很多基于5分打分制的项目）。此时，可以利用数据框具有的列表特性，对数据框应用lapply函数并结合下标选择对数据进行转换。比如，在处理原始中风数据时，可以按照下面的方式来处理数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rawstroke &amp;lt;- read.csv2(
  system.file(&amp;quot;rawdata&amp;quot;, &amp;quot;stroke.csv&amp;quot;, package = &amp;quot;ISwR&amp;quot;),
  na.strings = &amp;quot;.&amp;quot;)
ix &amp;lt;- c(&amp;quot;DSTR&amp;quot;, &amp;quot;DIED&amp;quot;)
rawstroke[ix] &amp;lt;- lapply(rawstroke[ix],
                        as.Date, format = &amp;quot;%d.%m.%Y&amp;quot;)
head(rawstroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   SEX       DIED       DSTR AGE DGN COMA DIAB MINF HAN
## 1   1 1991-01-07 1991-01-02  76 INF    0    0    1   0
## 2   1       &amp;lt;NA&amp;gt; 1991-01-03  58 INF    0    0    0   0
## 3   1 1991-06-02 1991-01-08  74 INF    0    0    1   1
## 4   0 1991-01-13 1991-01-11  77 ICH    0    1    0   1
## 5   0 1996-01-23 1991-01-13  76 INF    0    1    0   1
## 6   1 1991-01-13 1991-01-13  48 ICH    1    0    0   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似的，也可以通过一步操作，将4个二进制变量转换成“No/Yes”型因子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ix &amp;lt;- 6:9
rawstroke[ix] &amp;lt;- lapply(rawstroke[ix],
                        factor, levels = 0:1, labels = c(&amp;quot;No&amp;quot;, &amp;quot;Yes&amp;quot;))
head(rawstroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   SEX       DIED       DSTR AGE DGN COMA DIAB MINF HAN
## 1   1 1991-01-07 1991-01-02  76 INF   No   No  Yes  No
## 2   1       &amp;lt;NA&amp;gt; 1991-01-03  58 INF   No   No   No  No
## 3   1 1991-06-02 1991-01-08  74 INF   No   No  Yes Yes
## 4   0 1991-01-13 1991-01-11  77 ICH   No  Yes   No Yes
## 5   0 1996-01-23 1991-01-13  76 INF   No  Yes   No Yes
## 6   1 1991-01-13 1991-01-13  48 ICH  Yes   No   No Yes&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;10.2 条件计算&lt;/h2&gt;
&lt;p&gt;ifelse函数允许对同一数据集的不同部分做不同计算。下面以10.1.3小节中讨论过的中锋数据的一个子集进行演示。但这里使用的是ISwR包中经过预处理的版本。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;strokesub &amp;lt;- ISwR::stroke[1:10, 2:3]
strokesub&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          died       dstr
## 1  1991-01-07 1991-01-02
## 2        &amp;lt;NA&amp;gt; 1991-01-03
## 3  1991-06-02 1991-01-08
## 4  1991-01-13 1991-01-11
## 5        &amp;lt;NA&amp;gt; 1991-01-13
## 6  1991-01-13 1991-01-13
## 7  1993-12-01 1991-01-14
## 8  1991-12-12 1991-01-14
## 9        &amp;lt;NA&amp;gt; 1991-01-15
## 10 1993-11-10 1991-01-15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为计算存活模型需要的研究时间和时间/检查指数，可以运行下面的代码：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;strokesub &amp;lt;- transform(strokesub,
                       event = !is.na(died))
strokesub &amp;lt;- transform(strokesub,
                       obstime = ifelse(
                         event, died-dstr, as.Date(&amp;quot;1996-1-1&amp;quot;)-dstr)
                       )
strokesub&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          died       dstr event obstime
## 1  1991-01-07 1991-01-02  TRUE       5
## 2        &amp;lt;NA&amp;gt; 1991-01-03 FALSE    1824
## 3  1991-06-02 1991-01-08  TRUE     145
## 4  1991-01-13 1991-01-11  TRUE       2
## 5        &amp;lt;NA&amp;gt; 1991-01-13 FALSE    1814
## 6  1991-01-13 1991-01-13  TRUE       0
## 7  1993-12-01 1991-01-14  TRUE    1052
## 8  1991-12-12 1991-01-14  TRUE     332
## 9        &amp;lt;NA&amp;gt; 1991-01-15 FALSE    1812
## 10 1993-11-10 1991-01-15  TRUE    1030&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ifelse函数的工作机制是这样的：它有3个参数，test，yes，no。3个向量长度相同（如果长度不同，系统会自动循环补齐）。当test为真的时候，返回对应的YES的结果；当test为假的时候，返回对应的NO的结果；当条件为NA时，结果返回NA。该函数的操作结果就是YES和NO的拼接。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;10.3 合并与重构数据框&lt;/h2&gt;
&lt;p&gt;这一节主要是对数据框进行增加记录（垂直）或增加变量合并（水平）的方法。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.3.1 追加数据框&lt;/h3&gt;
&lt;p&gt;当有众多来自于不同数据源的数据框时，往往会需要将它们进行合并构造一个更大的数据框。在这一小节中，将进行“垂直”合并。所有将要合并的数据框必须有一样的变量，但这些变量在各个子数据框中的顺序&lt;strong&gt;不用完全一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为模拟上述情况，可以假设juul数据集对应的数据是对男孩群体和女孩群体单独进行收集的。此时，数据框中可能不会包含变量sex，因为对于单独的全体，各个样本对应的性别是一样的。同时支队单独一个性别有意义的变量在另一个样本中也将被忽略。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(juul)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked _by_ .GlobalEnv:
## 
##     age&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意subset函数中select参数的用法。该参数将数据框的列名替换为序列号，并以返回的序列号对数据框进行引用。负号的作用是移除相应的列，比如，上面的代码将删除juulgrl数据集中的testvol列和sex列。
juulgrl &amp;lt;- subset(juul, sex==2, select=-c(testvol,sex))
juulboy &amp;lt;- subset(juul, sex==1, select=-c(menarche,sex))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了将数据框合并在一起，必须先加入缺少的变量：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;juulgrl$sex &amp;lt;- factor(&amp;quot;F&amp;quot;)
juulgrl$testvol &amp;lt;- NA
juulboy$sex &amp;lt;- factor(&amp;quot;M&amp;quot;)
juulboy$menarche &amp;lt;- NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着，对数据框使用rbind函数即可：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;juulall &amp;lt;- rbind(juulboy, juulgrl)
names(juulall)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;age&amp;quot;      &amp;quot;igf1&amp;quot;     &amp;quot;tanner&amp;quot;   &amp;quot;testvol&amp;quot;  &amp;quot;sex&amp;quot;      &amp;quot;menarche&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，rbind函数在操作过程汇总使用了列名（因此，即使两个数据框中列顺序不同，该函数也不会对不相关的变量进行合并），并且以第一个数据框的变量顺序为参考。最终，结果的变量顺序与juulboy数据集的变量顺序一致。也请注意，rbind函数能够很好地处理合并后的因子水平。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;levels(juulall$sex)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;M&amp;quot; &amp;quot;F&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.3.2 合并数据框&lt;/h3&gt;
&lt;p&gt;有时会拿到一些针对同一批病人的独立数据集。比如说，可能会拿到分别包含患者挂号信息、临床化验数据及问卷调查的数据集。使用cbind函数将数据集&lt;strong&gt;并排&lt;/strong&gt;连在一起有时也可行，只不过这种做法有风险：如果数据集中的数据不够完整或者多出了不在某个数据集中的观测样本，想要避免这种情况发生，必须有一个独特的样本识别码。&lt;/p&gt;
&lt;p&gt;merge函数就可以处理这类问题。它会比较每个数据集中的一个或多个变量。这组变量在两个数据集中默认具有相同的名字（一般而言，有一个叫做&lt;em&gt;ID&lt;/em&gt;的变量标示测试者的身份）。假设在默认情况下，这两个数据集分别称为dfx和dfy，可以简单通过下面来计算合并的数据框：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这里只是举例子~~~并没有数据集~~~所以用#注释掉
#merge(dfx, dfy)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，有可能这两个数据集有多个名字相同的变量。此时，可以引入一个by参数，它指定了比较的变量名，如：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#同上~这里只是举例子~~~
#merge(dfx, dfy, by=&amp;quot;ID&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个数据集中的任何其他变量都会在结果中的名字后加后缀&lt;strong&gt;.x&lt;/strong&gt;或&lt;strong&gt;.y&lt;/strong&gt;。为了安全，在任何时候都应该使用这种格式，这种做法也能增加可读性与明确性。如需要匹配的变量在两个数据框中有不用的名字，则可以使用&lt;strong&gt;by.x&lt;/strong&gt;和&lt;strong&gt;by.y&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面用nickel数据集来解释上述概念。该数据描述了南威尔士一个镍冶炼工人队的信息。数据集ewrates则包含了按照年份和以5年间隔的年龄进行分组的人群死亡率表格。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(nickel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st   agein  ageout
## 1  3   0        5 1889.019 17.4808 45.2273 92.9808
## 2  4 162        5 1885.978 23.1864 48.2684 63.2712
## 3  6 163       10 1881.255 25.2452 52.9917 54.1644
## 4  8 527        9 1886.340 24.7206 47.9067 69.6794
## 5  9 150        0 1879.500 29.9575 54.7465 76.8442
## 6 10 163        2 1889.915 21.2877 44.3314 62.5413&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(ewrates)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   year age lung nasal other
## 1 1931  10    1     0  1269
## 2 1931  15    2     0  2201
## 3 1931  20    6     0  3116
## 4 1931  25   14     0  3024
## 5 1931  30   30     1  3188
## 6 1931  35   68     1  4165&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设想根据进入研究群体的日期值来合并这两个数据集。其中，年龄信息包含在变量agein中，进入数据集的日期可用dob + agein计算得出。可以用下面的代码计算ewrates对应的群体编码：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(nickel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st   agein  ageout
## 1  3   0        5 1889.019 17.4808 45.2273 92.9808
## 2  4 162        5 1885.978 23.1864 48.2684 63.2712
## 3  6 163       10 1881.255 25.2452 52.9917 54.1644
## 4  8 527        9 1886.340 24.7206 47.9067 69.6794
## 5  9 150        0 1879.500 29.9575 54.7465 76.8442
## 6 10 163        2 1889.915 21.2877 44.3314 62.5413&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nickel &amp;lt;- transform(nickel,
                    agr = trunc(agein/5)*5,
                    ygr = trunc((dob + agein-1)/5)*5+1)
head(nickel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st   agein  ageout agr  ygr
## 1  3   0        5 1889.019 17.4808 45.2273 92.9808  45 1931
## 2  4 162        5 1885.978 23.1864 48.2684 63.2712  45 1931
## 3  6 163       10 1881.255 25.2452 52.9917 54.1644  50 1931
## 4  8 527        9 1886.340 24.7206 47.9067 69.6794  45 1931
## 5  9 150        0 1879.500 29.9575 54.7465 76.8442  50 1931
## 6 10 163        2 1889.915 21.2877 44.3314 62.5413  40 1931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;trunc函数将变量的小数部分进行趋零取整。注意，年龄的每个组起始于可以被5整除的数，年份的每个组截止的时间榆次对应；这也就是在前面ygr的表达式中先减去1，再在结尾后加上1的原因（事实上，这个步骤并不重要，因为本例中所有录入日期都是1934、1939、1944或者1949年的4月1日）。需要注意的是，这里并没有使用与ewrates数据集中相同的变量名。这么做的原因在于，变量名age和year在nickel数据中不便于理解。&lt;/p&gt;
&lt;p&gt;定义了年龄和年份组之后，接下来的合并过程就很简单了。这里只需要注意一下两个数据框中变量名不同的问题。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mrg &amp;lt;- merge(nickel, ewrates,
             by.x = c(&amp;quot;agr&amp;quot;, &amp;quot;ygr&amp;quot;), 
             by.y = c(&amp;quot;age&amp;quot;, &amp;quot;year&amp;quot;))
head(mrg, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    agr  ygr  id icd exposure      dob  age1st   agein  ageout lung nasal
## 1   20 1931 273 154        0 1909.500 14.6913 24.7465 55.9302    6     0
## 2   20 1931 213 162        0 1910.129 14.2018 24.1177 63.0493    6     0
## 3   20 1931 546   0        0 1909.500 14.4945 24.7465 72.5000    6     0
## 4   20 1931 574 491        0 1909.729 14.0356 24.5177 70.6592    6     0
## 5   20 1931 110   0        0 1909.247 14.0302 24.9999 72.7534    6     0
## 6   20 1931 325 434        0 1910.500 14.0737 23.7465 43.0343    6     0
## 7   25 1931  56 502        2 1904.500 18.2917 29.7465 51.5847   14     0
## 8   25 1931 690 420        0 1906.500 17.2206 27.7465 55.1219   14     0
## 9   25 1931 443 420        0 1905.326 14.5562 28.9204 65.7616   14     0
## 10  25 1931 137 465        0 1905.386 19.0808 28.8601 74.2794   14     0
##    other
## 1   3116
## 2   3116
## 3   3116
## 4   3116
## 5   3116
## 6   3116
## 7   3024
## 8   3024
## 9   3024
## 10  3024&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;10.3.3 重塑数据框&lt;/h3&gt;
&lt;p&gt;纵向数据有两种格式，一是“宽”格式，其中每个时间点为单独的一列，但每个事件只有一个记录；另一种是“长”格式，其中每个事件都有多余记录，每个时间点有一条记录。因为不需要假设事件都是在相同的时间点被记录的，所以长格式使用更广泛，但在实际应用当中，使用宽格式可能会更容易，而且一些统计函数也需要这种格式的输入。&lt;/p&gt;
&lt;p&gt;在任何一种情况下，都需要从一个格式转换到另一个格式。这就是reshape函数的功用。&lt;/p&gt;
&lt;p&gt;例子如下，病人在罹患乳腺癌之后，采用莫西芬进行治疗。使用病人再次期间的骨代谢的随机化研究数据作为例子。治疗开始之后，碱性磷酸酶在基准日以及治疗开始后的第3、6、9、12、18以及24个月后的浓度数据都被记录了下来。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(alkfos)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   grp  c0  c3  c6  c9 c12 c18 c24
## 1   1 142 140 159 162 152 175 148
## 2   1 120 126 120 146 134 119 116
## 3   1 175 161 168 164 213 194 221
## 4   1 234 203 174 197 289 174 189
## 5   1  94 107 146 124 128  98 114
## 6   1 128  97 113 203  NA  NA  NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在reshape函数最简单使用情况下，它会假设变量名包含了将数据重整为长格式数据所需的必要信息。它默认变量名和测量时间是由&lt;strong&gt;“.”&lt;/strong&gt;来分开的，因此，需要强制修改名字格式来满足这一原则。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a2 &amp;lt;- alkfos
names(a2) &amp;lt;- sub(&amp;quot;c&amp;quot;, &amp;quot;c.&amp;quot;, names(a2))
names(a2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;grp&amp;quot;  &amp;quot;c.0&amp;quot;  &amp;quot;c.3&amp;quot;  &amp;quot;c.6&amp;quot;  &amp;quot;c.9&amp;quot;  &amp;quot;c.12&amp;quot; &amp;quot;c.18&amp;quot; &amp;quot;c.24&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sub函数的作用是在字符串内做替换操作。在这个例子中，其把&lt;strong&gt;“c”&lt;/strong&gt;替换成了&lt;strong&gt;“c.”&lt;/strong&gt;。另外一种方式是通过在reshape命令中加入seq=“”来改变原始名字格式(c0, …, c24)。&lt;/p&gt;
&lt;p&gt;命名好变量名之后，接下来唯一要做的就是指明数据重整的方向以及具有时变性特征的变量整合。这里有一个简介的功能，即后者可以用数据集的列下标来指定，这比使用变量名字引用变量更方便。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a.long &amp;lt;- reshape(a2, varying = 2:8, direction = &amp;quot;long&amp;quot;)
head(a.long)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     grp time   c id
## 1.0   1    0 142  1
## 2.0   1    0 120  2
## 3.0   1    0 175  3
## 4.0   1    0 234  4
## 5.0   1    0  94  5
## 6.0   1    0 128  6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tail(a.long)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       grp time   c id
## 38.24   2   24  95 38
## 39.24   2   24  NA 39
## 40.24   2   24 192 40
## 41.24   2   24  94 41
## 42.24   2   24 194 42
## 43.24   2   24 129 43&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，结果的排列顺序是，先按照time变量继续排序，对每个time变量，再根据ID进行排序。从技术角度而言，这是最方便生成的格式。如果喜欢相反的排列顺序，可以运行下面的代码：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;o &amp;lt;- with(a.long, order(id, time))
head(a.long[o,], 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      grp time   c id
## 1.0    1    0 142  1
## 1.3    1    3 140  1
## 1.6    1    6 159  1
## 1.9    1    9 162  1
## 1.12   1   12 152  1
## 1.18   1   18 175  1
## 1.24   1   24 148  1
## 2.0    1    0 120  2
## 2.3    1    3 126  2
## 2.6    1    6 120  2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用同一个数据集演示一遍相反的操作过程，这次数据集的初始存储格式是长格式。事实上，这个操作过程有点过于简单了，因为reshape已经在它的输出中给出了足够的信息，只需要运行reshape(a.long)命令即可实现向宽格式的转换。为模拟原始数据是长格式的情况，这里先去掉了这些数据当中的“reshape Long”的属性。同时，使用na.omit函数删除数据集中具有缺失数据的记录。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a.long2 &amp;lt;- na.omit(a.long)
attr(a.long2, &amp;quot;reshapeLong&amp;quot;) &amp;lt;- NULL
#使用下面的代码把a.long2转换为宽格式
a.wide2 &amp;lt;- reshape(a.long2, direction = &amp;quot;wide&amp;quot;,
                   v.names = &amp;quot;c&amp;quot;, idvar = &amp;quot;id&amp;quot;,
                   timevar = &amp;quot;time&amp;quot;)
head(a.wide2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     grp id c.0 c.3 c.6 c.9 c.12 c.18 c.24
## 1.0   1  1 142 140 159 162  152  175  148
## 2.0   1  2 120 126 120 146  134  119  116
## 3.0   1  3 175 161 168 164  213  194  221
## 4.0   1  4 234 203 174 197  289  174  189
## 5.0   1  5  94 107 146 124  128   98  114
## 6.0   1  6 128  97 113 203   NA   NA   NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，6号病人对应的缺失记录以NA进行了填充；对他而言，只有前四次的记录。&lt;/p&gt;
&lt;p&gt;参数idvar和timevar指定了结果中变量名包括每次观测对应的ID以及时间的变量名。如它们具有默认的名字，那么，也可以不用指定，但这么做是比较好的做法。参数v.names指明了随时间改变的变量。如果忽略了它，那么grp变量也将被当做时间改变的变量。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;10.4 数据的分组及分案例操作&lt;/h2&gt;
&lt;p&gt;本节的例子包括计算某药物动力学试验中的累计剂量以及各种对数据进行归一化和标准化的方法。&lt;/p&gt;
&lt;p&gt;对于这类问题，最好将数据拆分为包含多个组的列表，接着分别对每个组中包含的列表进行计算，最后将结果放在一起。&lt;/p&gt;
&lt;p&gt;考虑将a.long数据集中碱性磷酸酶值以基准日的观测值为中心进行归一化。可以考虑用split函数生成一个对应于不同测量时间的列表。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这是小写的L不是数字1
l &amp;lt;- split(a.long$c, a.long$id)
l[1:3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`1`
## [1] 142 140 159 162 152 175 148
## 
## $`2`
## [1] 120 126 120 146 134 119 116
## 
## $`3`
## [1] 175 161 168 164 213 194 221&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来，使用lapply函数对列表中的所有元素应用某个特定函数，并将数据保存。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#同样是小写的L
l2 &amp;lt;- lapply(l, function(x) x / x[1])
l2[1:3]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`1`
## [1] 1.0000000 0.9859155 1.1197183 1.1408451 1.0704225 1.2323944 1.0422535
## 
## $`2`
## [1] 1.0000000 1.0500000 1.0000000 1.2166667 1.1166667 0.9916667 0.9666667
## 
## $`3`
## [1] 1.0000000 0.9200000 0.9600000 0.9371429 1.2171429 1.1085714 1.2628571&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，用split的逆操作函数unsplit将各个&lt;em&gt;切片&lt;/em&gt;的结果拼回在一起。请注意，a.long对应的id在time的同一水平下进行了排序，因此，该操作并不是简单地把l2中的元素拼接在一起。第一名病人对应的数据如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a.long$c.adj &amp;lt;- unsplit(l2, a.long$id)
subset(a.long, id==1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      grp time   c id     c.adj
## 1.0    1    0 142  1 1.0000000
## 1.3    1    3 140  1 0.9859155
## 1.6    1    6 159  1 1.1197183
## 1.9    1    9 162  1 1.1408451
## 1.12   1   12 152  1 1.0704225
## 1.18   1   18 175  1 1.2323944
## 1.24   1   24 148  1 1.0422535&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;事实上，有一个将这种分割–修改–合并操作规范化的函数，即ave。它的默认功能是用组的平均值来替换数据。不过，基于该函数能够做很多更一般的转换。下面是另一种可得到上述操作结果的方法：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a.long$c.adj &amp;lt;- ave(a.long$c, a.long$id,
                    FUN = function(x) x / x[1])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在前面的代码中，支队a.long$c进行了操作。当然，也可以使用下面的代码对整个数据框进行&lt;em&gt;切片处理&lt;/em&gt;：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;l &amp;lt;- split(a.long, a.long$id)
l2 &amp;lt;- lapply(l, transform, c.adj = c / c[1])
a.long2 &amp;lt;- unsplit(l2, a.long$id)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意lapply的最后一个参数是如何被传递给transform函数的。我们实际上是对列表1中的每个数据框 x 调用了transform(x, c.adj = c / c[1])操作。这种做法比前一种低效，因为该操作设计太多数据的靠背过程，但它对更复杂的数据操作进行了一般性的概括。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;10.5 时间分割&lt;/h2&gt;
&lt;p&gt;在10.3.2小节中，对nickel和ewrates进行的合并操作不具有太多统计上的意义：只是在死亡率表中并入了对应的个体进入研究群体的年龄。然而，该数据集是关于癌症的，癌症是一种慢性疾病，确诊之后，在20年或更久之后会面临日益增大的风险。加入实验对象一般在50岁左右死亡，那么，对30岁的人来将，群体死亡率几乎和他们无关。&lt;/p&gt;
&lt;p&gt;一个合理的统计研究需要考虑整个后续观察期间的群体死亡率。将这些个体分割成多个&lt;strong&gt;“子个体”&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#在这个数据集中，前六个观测是：
head(nickel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st   agein  ageout agr  ygr
## 1  3   0        5 1889.019 17.4808 45.2273 92.9808  45 1931
## 2  4 162        5 1885.978 23.1864 48.2684 63.2712  45 1931
## 3  6 163       10 1881.255 25.2452 52.9917 54.1644  50 1931
## 4  8 527        9 1886.340 24.7206 47.9067 69.6794  45 1931
## 5  9 150        0 1879.500 29.9575 54.7465 76.8442  50 1931
## 6 10 163        2 1889.915 21.2877 44.3314 62.5413  40 1931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;考虑id==4的个体，该个体在48.2684岁时进入研究群体，死亡于63.2712岁（我去~好精确，怎么做到的）。时序分割方法把这个实验人员当成4个独立的研究对象，一个在46.2684岁时进入此项研究，并在50岁时离开（50岁生日）；其他的研究对象分别包括50-55岁，55-60岁以及60-63.2712岁的时间间隔。前三个对象都是需要被去掉的，因为研究对象并没有死亡。&lt;/p&gt;
&lt;p&gt;如果把这些数据与人口列表合并，就能计算出给定年龄区间中的期望死亡人数，并可以将它与实际死亡人数进行比较。&lt;/p&gt;
&lt;p&gt;利用R语言向量化运算的性质，可以通过对各个年龄区间做循环来很好地解决这个问题，同时，要将每个观测时期都“裁剪”到各个年龄区间内。&lt;/p&gt;
&lt;p&gt;为了将观测时期裁剪到年龄介于60-65岁之间，如果进出这个年龄段的时间在该年龄段范围之外，需要对其进行调整。可以删除那些在该年龄段内没有观测数据的案例。另外，如果擦拭对象在这个年龄段内没有死亡，对应的icd应设定为0.&lt;/p&gt;
&lt;p&gt;最简单的方法是&lt;em&gt;“先射击再定靶”&lt;/em&gt;。调整后的进入和退出时间为：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;entry &amp;lt;- pmax(nickel$agein, 60)
exit &amp;lt;- pmin(nickel$ageout, 65)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而，有时会出现观测对象在60岁前就离开了测试群体，也有人在65岁之后才进入测试群体。在这两种情况下，出错的原因就在于entry &amp;gt; exit，因此，可以通过计算下面的值来对此进行检查：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;valid &amp;lt;- (entry &amp;lt; exit)
entry &amp;lt;- entry[valid]
exit &amp;lt;- exit[valid]
#有效案例对应的审查指标是
cens &amp;lt;- (nickel$ageout[valid] &amp;gt; 65)
#下面的代码可以得到切割后的数据集
nickel60 &amp;lt;- nickel[valid,]
nickel60$icd[cens] &amp;lt;- 0
nickel60$agein &amp;lt;- entry
nickel60$ageout &amp;lt;- exit
nickel60$agr &amp;lt;- 60
nickel60ygr &amp;lt;- with(nickel60, trunc((dob + agein - 1)/5)*5+1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果的第一行是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(nickel60)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st agein  ageout agr  ygr
## 1  3   0        5 1889.019 17.4808    60 65.0000  60 1931
## 2  4 162        5 1885.978 23.1864    60 63.2712  60 1931
## 4  8   0        9 1886.340 24.7206    60 65.0000  60 1931
## 5  9   0        0 1879.500 29.9575    60 65.0000  60 1931
## 6 10 163        2 1889.915 21.2877    60 62.5413  60 1931
## 7 15 334        0 1890.500 23.2836    60 62.0000  60 1931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有几点需要注意：如有人恰好在65岁时死亡，则被记录为在年龄区间（60-65岁）内死亡。与此对应，我们不会将正好在60岁死亡的人纳入该区间，因为那属于55-60岁区间。因为ygr是基于原始的agein变量计算得出的。所以有必要重算ygr的值。&lt;/p&gt;
&lt;p&gt;为得到整个扩展的数据集，可以将每个年龄区间20-25，25-30等重复上述操作，并用rbind函数将结果返回的16个数据框拼接在一起。不过这太麻烦了，而且可能会出错。一个替代方案就是写一个单独的程序。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#首先，将应用到每个组的处理方法封装成函数：
trim &amp;lt;- function(start)
{
  end &amp;lt;- start + 5
  entry &amp;lt;- pmax(nickel$agein, start)
  exit &amp;lt;- pmin(nickel$ageout, end)
  valid &amp;lt;- (entry &amp;lt; exit)
  cens &amp;lt;- (nickel$ageout[valid] &amp;gt; end)
  result &amp;lt;- nickel[valid,]
  result$icd[cens] &amp;lt;- 0
  result$agein &amp;lt;- entry[valid]
  result$ageout &amp;lt;- exit[valid]
  result$agr &amp;lt;- start
  result$ygr &amp;lt;- with(result, trunc((dob + agein - 1)/5)*5+1)
  result
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个典型的专用程序。有雨这个函数依赖于已知的各种变量名，而且把间隔长度强制限制为5，因此，它不能用在别的地方（~这不废话吗）。&lt;/p&gt;
&lt;p&gt;在这个定义下，trim(60)等价于前文中计算过的nickel60：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(trim(60))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   id icd exposure      dob  age1st agein  ageout agr  ygr
## 1  3   0        5 1889.019 17.4808    60 65.0000  60 1946
## 2  4 162        5 1885.978 23.1864    60 63.2712  60 1941
## 4  8   0        9 1886.340 24.7206    60 65.0000  60 1946
## 5  9   0        0 1879.500 29.9575    60 65.0000  60 1936
## 6 10 163        2 1889.915 21.2877    60 62.5413  60 1946
## 7 15 334        0 1890.500 23.2836    60 62.0000  60 1946&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用下面的代码，可得到所有间隔的结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nickel.expand &amp;lt;- do.call(&amp;quot;rbind&amp;quot;, lapply(seq(20, 95, 5), trim))
head(nickel.expand)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      id icd exposure      dob  age1st   agein ageout agr  ygr
## 84  110   0        0 1909.247 14.0302 24.9999     25  20 1931
## 156 213   0        0 1910.129 14.2018 24.1177     25  20 1931
## 197 273   0        0 1909.500 14.6913 24.7465     25  20 1931
## 236 325   0        0 1910.500 14.0737 23.7465     25  20 1931
## 384 546   0        0 1909.500 14.4945 24.7465     25  20 1931
## 400 574   0        0 1909.729 14.0356 24.5177     25  20 1931&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的do.call结构调用了rbind，并给了它一个参数列表。这里参数列表对应的是lapply函数的返回值。而lapply函数的作用是对20，25，……，95等值执行trim函数。上面的代码等价于：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个只是演示~不能运行
#rbind(trim(20), trim(25),.....,trim(95))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，显示一个实验对象，得到的结果如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;subset(nickel.expand, id==4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      id icd exposure      dob  age1st   agein  ageout agr  ygr
## 2     4   0        5 1885.978 23.1864 48.2684 50.0000  45 1931
## 2100  4   0        5 1885.978 23.1864 50.0000 55.0000  50 1931
## 2102  4   0        5 1885.978 23.1864 55.0000 60.0000  55 1936
## 2104  4 162        5 1885.978 23.1864 60.0000 63.2712  60 1941&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后一步，将死亡率表合并，这与10.3.2小节中的步骤一样：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nickel.expand &amp;lt;- merge(nickel.expand, ewrates,
                       by.x = c(&amp;quot;agr&amp;quot;, &amp;quot;ygr&amp;quot;), by.y = c(&amp;quot;age&amp;quot;, &amp;quot;year&amp;quot;))
head(nickel.expand)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   agr  ygr  id icd exposure      dob  age1st   agein ageout lung nasal
## 1  20 1931 325   0        0 1910.500 14.0737 23.7465     25    6     0
## 2  20 1931 273   0        0 1909.500 14.6913 24.7465     25    6     0
## 3  20 1931 110   0        0 1909.247 14.0302 24.9999     25    6     0
## 4  20 1931 574   0        0 1909.729 14.0356 24.5177     25    6     0
## 5  20 1931 213   0        0 1910.129 14.2018 24.1177     25    6     0
## 6  20 1931 546   0        0 1909.500 14.4945 24.7465     25    6     0
##   other
## 1  3116
## 2  3116
## 3  3116
## 4  3116
## 5  3116
## 6  3116&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;生成一个因子，其中thuesen数据中的变量blood.glucose被切分为区间(4,7]、(7,9]、(9,12]、(12,20]。同时，修改因子水平名称为“low”、“intermediate”、“high”和“very high”。&lt;/li&gt;
&lt;li&gt;在bcmort数据集中，四水平因子cohort可以看做两个双水平因子的乘积，比如period和area。如何生成这些变量。&lt;/li&gt;
&lt;li&gt;将ashina数据集转换为长格式。考虑如何编码才能判断vas测量值是是来自第一个还是第二个测量过程。&lt;/li&gt;
&lt;li&gt;将sroke数据按照obsmonths切分到中风后0-0.5、0.5-2、2-12以及12+的时间区间中。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第九章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第九章 功效与样本容量的计算&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;9.1 功效计算原则&lt;/h2&gt;
&lt;p&gt;复习下前面的假设检验的基本原理。 1. 首先定义一个检验统计量； 2. 根据该统计量的值决定是否接受原假设； 在原假设成立的条件下，检验统计量落入拒绝域的概率等于事先给定的显著性水平（α）。基于此，可以构建接受域和拒绝域。 功效是指拒绝错误原假设的可能性大小。&lt;/p&gt;
&lt;div id=&#34;-t--t-&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;9.1.1 单样本 &lt;em&gt;t&lt;/em&gt; 及配对样本 &lt;em&gt;t&lt;/em&gt; 检验的功效&lt;/h3&gt;
&lt;p&gt;考虑下样本均值与给定值进行比较的情形。比如，在一个对比试验中，想用配对样本 &lt;em&gt;t&lt;/em&gt; 检验来验证治疗方案A与B的效果差异是否为零。 令真是差异为&lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt;。在其他模型设定不变的情形下，即使零假设不成立，也能推出检验统计量服从非中心 &lt;em&gt;t&lt;/em&gt; 分布。该分布除了依赖于普通 &lt;em&gt;t&lt;/em&gt; 分布具有的自由度参数外，还依赖于一个非中心参数。对于配对 &lt;em&gt;t&lt;/em&gt; 检验而言，非中心参数 &lt;em&gt;v&lt;/em&gt; 是&lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt;、样本标准差&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;和样本容量 &lt;em&gt;n&lt;/em&gt; 的函数，具体如下： &lt;span class=&#34;math display&#34;&gt;\[
v=\frac{\delta}{\sigma/\sqrt{n}}
\]&lt;/span&gt; 也就是真实差异除以样本均值的标准差。 在R中，通过向pt函数添加ncp参数即可得到非中心 &lt;em&gt;t&lt;/em&gt; 分布的累计分布图，如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#下列语句展示了ncp=3，df=25时的非中心t分布的累计分布图
#图中的垂线表示显著性水平为0.05时双边检验的接受域的上界
curve(pt(x,25,ncp = 3),from = 0,to = 6)
abline(v=qt(.975,25))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-05-07-r语言统计入门-第九章_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以看到，分布曲线的大部分落入了拒绝域。
#其中，垂线和垂线围成的区域面积就是检验统计量落入接受域的概率
#用下面的代码计算这个概率
pt(qt(.975,25),25,ncp = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1779891&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，这个概率约等于0.18，而&lt;strong&gt;功效&lt;/strong&gt;等于1减去这个概率，即为0.82。对于功效而言，其值越接近于1越好。 注意，功效（通常设定为&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;）的取值依赖于&lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;这4个变量。确定其中任意3个变量，便可以通过调整第4个变量的大小来获得给定的功效。也可以通过类似的方式确定某次实验所必需额样本容量：首先确定想要得到的功效（通常令&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.80\)&lt;/span&gt;或&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.90\)&lt;/span&gt;）、显著性水平（通常&lt;span class=&#34;math inline&#34;&gt;\(\alpha=0.05\)&lt;/span&gt;），以及“最小相关差异”（MIREDIF）或者最小有意义差异（SMD）&lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt;，这样就得到一个可用来求解样本容量&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;的方程。对于n值，要取整。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;t&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;9.1.2 两样本&lt;em&gt;t&lt;/em&gt;检验的功效&lt;/h3&gt;
&lt;p&gt;计算两样本&lt;em&gt;t&lt;/em&gt;检验的功效与单样本的差不多，只是计算参数方法略有不同： &lt;span class=&#34;math display&#34;&gt;\[
v=\frac{\delta}{\sigma\sqrt{1/n_1+1/n_2}}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;9.1.3 近似方法&lt;/h3&gt;
&lt;p&gt;为便于手工计算，通常假设标准差已知，从而化简相应的计算公式。此时，可以用对于标准正态分布情况下的检验来代替&lt;em&gt;t&lt;/em&gt;检验。这种做法的优势在于，根据这种算法的公式，能够方便地反解出&lt;em&gt;n&lt;/em&gt;的大小： &lt;span class=&#34;math display&#34;&gt;\[
n=(\frac{\Phi_{\alpha/2}+\Phi_\beta}{\delta/\sigma})^2 \qquad 单样本 \\
n=2\times(\frac{\Phi_{\alpha/2}+\Phi_\beta}{\delta/\sigma})^2\qquad两样本，每组
\]&lt;/span&gt; 其中&lt;span class=&#34;math inline&#34;&gt;\(\Phi_x\)&lt;/span&gt;代表正态分布的&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;分位数。上述公式是针对双边检验的情形，对于单边检验，将&lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;代替&lt;span class=&#34;math inline&#34;&gt;\(\alpha/2\)&lt;/span&gt;即可。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;9.1.4 比较比例的功效&lt;/h3&gt;
&lt;p&gt;假设想要比较两类人群的发病率差异，此时，得先确定从两个群体中进行抽样的样本量。也就是说，要像8.2节prop.test和chisq.test.中所讲的那样对两个二项分布进行比较。 假设两个总体的数量相等，则有如下公式： &lt;span class=&#34;math display&#34;&gt;\[
n=[\frac{\Phi_{\alpha/2}\sqrt{2p(1-p)}+\Phi_\beta\sqrt{p_1(1-p_1)+p_2(1-p_2)}}{\left|p_2-p_1\right|}]^2\\
其中p=(p_1+p_2)/2
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;9.2 两样本问题&lt;/h2&gt;
&lt;p&gt;下面案例取自Altman（1991）。该案例研究了饮食中摄入牛奶对身高的影响。在案例中，令两组样本分别摄入不同的饮食，并分别测量两组样本的身高。那么，当功效为90%，双边检验的显著性水平位1%时，多大的样本量才能够保证当样本所对应的分布，其标准差为2 cm时，检验到的两个总体的差异为0.5 cm？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;power.t.test(delta = 0.5, sd = 2, sig.level = 0.01, power = 0.9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##      Two-sample t test power calculation 
## 
##               n = 477.8021
##           delta = 0.5
##              sd = 2
##       sig.level = 0.01
##           power = 0.9
##     alternative = two.sided
## 
## NOTE: n is number in *each* group&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中delta表示真实差异，sd表示真实标准差。容易看到，上述代码计算得出的样本容量结果是分数。自然，需要对其取整到478.在原文献中，通过诺模图的方法计算，得到的结果是450.导致这种结果差异的原因可能在于，从诺模图上读取数据难度较大，难以精确。运行下面的代码，可以计算出每组样本量为450时，试验对应的检验功效的大小。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;power.t.test(n = 450, delta = 0.5, sd = 2, sig.level = 0.01)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##      Two-sample t test power calculation 
## 
##               n = 450
##           delta = 0.5
##              sd = 2
##       sig.level = 0.01
##           power = 0.8784433
##     alternative = two.sided
## 
## NOTE: n is number in *each* group&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述计算的过程其实是给定5个变量（power，sig.level，delta，sd和n）中的任意4个值，则函数自动计算出未知的那个。除此之外，该函数还有两个可选参数：alternative和type。其中，前者用来指定单边检验，后者用来指定单样本检验。关于前者的例子如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;power.t.test(delta = 0.5, sd = 2, sig.level = 0.01, power = 0.9, alternative = &amp;quot;one.sided&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##      Two-sample t test power calculation 
## 
##               n = 417.898
##           delta = 0.5
##              sd = 2
##       sig.level = 0.01
##           power = 0.9
##     alternative = one.sided
## 
## NOTE: n is number in *each* group&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;9.3 单样本问题及配对样本检验&lt;/h2&gt;
&lt;p&gt;在power.t.test函数中设定参数type=“one.sample”，可以用来对单样本进行检验。同样，设定type=“paired”可以用来进行配对检验。 在研究配对数据时，通常在表述上回遇到一个陷阱：通常把个体间的方差（intra-individual variation）认为是对“相同样本重复测量得到的方差”。试验中，对样本进行多次测量，并计算出个样本间的标准差即可。然而，当指定power.t.test函数的sd参数时，需要将前面得到的标准差乘以&lt;span class=&#34;math inline&#34;&gt;\(\sqrt{2}\)&lt;/span&gt;才行。举个例子，现已知不同样本之间的标准差为10，显著性水平位5%，功效为85%，用下面的代码可以计算出配对检验检测差异为10时所需要的样本量：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;power.t.test(delta = 10, sd = 10*sqrt(2), power = 0.85, type = &amp;quot;paired&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##      Paired t test power calculation 
## 
##               n = 19.96892
##           delta = 10
##              sd = 14.14214
##       sig.level = 0.05
##           power = 0.85
##     alternative = two.sided
## 
## NOTE: n is number of *pairs*, sd is std.dev. of *differences* within pairs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;9.4 比例的比较&lt;/h2&gt;
&lt;p&gt;计算比例比较试验所需要的样本数量和其他相关指标，可以用power.prop.test。该函数的计算过程使用了正态性近似，因而，当对应表格中的频数小于5时，结果可能不太可靠。 power.prop.test函数的用法与power.t.test类似。只是前者用两组总体假定的概率p1和p2来代替后者的delta和sd参数。目前，没法用该函数指定解决单样本检验的问题。 下面的例子取自Altman（1991）。试验中，两组总体中，一组食用含尼古丁的口香糖，另一组没有。试验观测的是一个戒烟与否的二分结果。 给定p1=0.15，p2=0.30。当显著性水平为5%时，用下面的代码可以得到功效为85%时对应的样本容量：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;power.prop.test(power = 0.85, p1 = 0.15, p2 = 0.30)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##      Two-sample comparison of proportions power calculation 
## 
##               n = 137.604
##              p1 = 0.15
##              p2 = 0.3
##       sig.level = 0.05
##           power = 0.85
##     alternative = two.sided
## 
## NOTE: n is number in *each* group&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;9.5 练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;ashina试验要求功效为80%，如果真实治疗差异达到15%，人与人之间效果的标准差为20%。请给出合适的抽样样本量。&lt;/li&gt;
&lt;li&gt;在一个具有二元输出结果的对比试验中，功效为90%时，找出能有效证明病人治愈率从60%升高到75%所需要的病人数目。当功效为80%时，又是多大呢。&lt;/li&gt;
&lt;li&gt;绘制参数ncp=3，df=25的非中心&lt;em&gt;t&lt;/em&gt;分布的密度曲线，并将其与&lt;em&gt;t+3&lt;/em&gt;时的分布曲线进行比较。其中，变量&lt;em&gt;t&lt;/em&gt;服从自由度为25的中心&lt;em&gt;t&lt;/em&gt;分布。&lt;/li&gt;
&lt;li&gt;在双边检验中，有可能出现其值为真，但统计量却落入拒绝域的情形。R语言中，只有设定参数strict=TRUE时，R才会在计算功效时考虑这种情形。请对此进行讨论。&lt;/li&gt;
&lt;li&gt;经常会计算使得某差异显著所需要的合适样本量&lt;em&gt;n&lt;/em&gt;，那么，通过这种方式计算得出的样本量&lt;em&gt;n&lt;/em&gt;对应的功效时多少。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第八章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第八章 表格数据&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;8.1 单比例&lt;/h2&gt;
&lt;p&gt;对单比例的检验基于二项分布。在大样本的情况下，可以用一个均值为&lt;span class=&#34;math inline&#34;&gt;\(Np\)&lt;/span&gt;，方差为&lt;span class=&#34;math inline&#34;&gt;\(Np(1-p)\)&lt;/span&gt;的正态分布来很好的近似。有一个经验结论，在“成功”与“失败”的期望次数都大于5的时候能得到较好的近似。 令&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;表示“成功”的次数，则对假设&lt;span class=&#34;math inline&#34;&gt;\(p=p_0\)&lt;/span&gt;的检验可以基于下式： &lt;span class=&#34;math display&#34;&gt;\[
u=\frac{x-Np_0}{\sqrt{Np_0(1-p_0)}}
\]&lt;/span&gt; 这个统计量近似服从一个均值为0，标准差为1的正态分布，或者说&lt;span class=&#34;math inline&#34;&gt;\(u^2\)&lt;/span&gt;近似服从一个自由度为1的卡方分布。 下面开始讲例子。215名病人的39名被观测到患有哮喘，然后对“随机病人”患有哮喘的概率是0.15这个假设做检验。采用函数prop.test。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个函数的3个参数分别是，正观测数、总数以及想对其做检验的概率参数
#最后这个参数默认值为0.5
prop.test(39,215,0.15)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  1-sample proportions test with continuity correction
## 
## data:  39 out of 215, null probability 0.15
## X-squared = 1.425, df = 1, p-value = 0.2326
## alternative hypothesis: true p is not equal to 0.15
## 95 percent confidence interval:
##  0.1335937 0.2408799
## sample estimates:
##         p 
## 0.1813953&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以用函数binom.test在二项分布下做检验，这时能得到精确地检验概率，所以一般它比上一个函数更受欢迎。不过除了单比例检验，函数prop.test还能做其他事情。为了得到这个&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;值，先计算出&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;取每一个可能值的点概率，然后再将观测到的小于等于&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;的概率加起来。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;binom.test(39,215,.15)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Exact binomial test
## 
## data:  39 and 215
## number of successes = 39, number of trials = 215, p-value = 0.2135
## alternative hypothesis: true probability of success is not equal to 0.15
## 95 percent confidence interval:
##  0.1322842 0.2395223
## sample estimates:
## probability of success 
##              0.1813953&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;8.2 两个独立的比例&lt;/h2&gt;
&lt;p&gt;函数prop.test也能用于比较两个或多个比例。为达到这个目的，参数应该是两个向量，其中第一个表示正观测数，第二个表示每组总数。 以下是例子：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lewitt.machin.success &amp;lt;- c(9,4)
lewitt.machin.total &amp;lt;- c(12,13)
prop.test(lewitt.machin.success,lewitt.machin.total)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  2-sample test for equality of proportions with continuity
##  correction
## 
## data:  lewitt.machin.success out of lewitt.machin.total
## X-squared = 3.2793, df = 1, p-value = 0.07016
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  0.01151032 0.87310506
## sample estimates:
##    prop 1    prop 2 
## 0.7500000 0.3076923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里给出的是&lt;em&gt;比例之差&lt;/em&gt;的置信区间。 也可以不使用Yates连续型修正来计算这个检验，即加入参数correct=F。连续性修正一定程度上让所得置信区间变得更宽，不过注意到这里仍然不包含0。而双边假设检验显示两组之间没有显著差异，所以这里置信区间与其相矛盾。这是因为使用了不同的近似方法导致的，这对于稀疏如此的表尤为重要。 如果希望确认至少&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;值是正确的，可以用Fisher精确检验。用上一节的数据来展示它。这个检验在给定行和列的边际值的情况下计算&lt;span class=&#34;math inline&#34;&gt;\(2\times 2\)&lt;/span&gt;表格的条件分布。这可能难以想象，不过可以这样来看：拿出13个白球和12个黑球（分别是成功与失败），然后不重复地从抽样中得到两个样本量分别为12和13的小组。第一组的白球数量显然足以确定整个表格，而它的分布可以完全转化为一个纯粹的组合问题。这个分布被称为&lt;strong&gt;超几何分布&lt;/strong&gt;。 相关的检验是fisher.test，它要求输入的数据时矩阵形式的，如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;matrix(c(9,4,3,9),2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2]
## [1,]    9    3
## [2,]    4    9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lewitt.machin &amp;lt;- matrix(c(9,4,3,9),2)
fisher.test(lewitt.machin)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Fisher&amp;#39;s Exact Test for Count Data
## 
## data:  lewitt.machin
## p-value = 0.04718
## alternative hypothesis: true odds ratio is not equal to 1
## 95 percent confidence interval:
##   0.9006803 57.2549701
## sample estimates:
## odds ratio 
##   6.180528&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意表格的第二列应该是负结果的次数，不是观测值的总数。 还需注意的是，这里给出了&lt;em&gt;比值比&lt;/em&gt;（odds ratio）的置信区间，即是&lt;span class=&#34;math inline&#34;&gt;\((p_1/(1-p_1))/(p_2/(1-p_2))\)&lt;/span&gt;。可以发现，若&lt;span class=&#34;math inline&#34;&gt;\(p_1\neq p_2\)&lt;/span&gt;，那么表格的条件分布只依赖于比值比，所以这是一个用于衡量Fisher检验中相关程度的自然指标。这个检验的精确分布在比值比不为1的时候可以精确地求出，不过这里与binom.test一样，双边95%置信区间是由两个单边97.5%置信区间并起来的。这导致它的结果与prop.test的不一致：检验的结果刚好显著，但是比值比的置信区间包含1在内。 和fisher.test一样，在chisq.test中的标准&lt;span class=&#34;math inline&#34;&gt;\(\chi^2\)&lt;/span&gt;检验需要矩阵类型的数据。对于一个&lt;span class=&#34;math inline&#34;&gt;\(2\times 2\)&lt;/span&gt;表格来说，这个检验与prop.test的结果是完全一样的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;chisq.test(lewitt.machin)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pearson&amp;#39;s Chi-squared test with Yates&amp;#39; continuity correction
## 
## data:  lewitt.machin
## X-squared = 3.2793, df = 1, p-value = 0.07016&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;k-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;8.3 &lt;em&gt;k&lt;/em&gt; 比例，检验趋势&lt;/h2&gt;
&lt;p&gt;有时候想要比较多于两个部分。但有时数据的分类可能是有序的，所以希望找到一个随着分组序号递增或递减的趋势。 这一节的例子是，一组女性是否使用剖腹产生育孩子，以及鞋子码数的数据。数据集如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
caesar.shoe&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     &amp;lt;4  4 4.5  5 5.5  6+
## Yes  5  7   6  7   8  10
## No  17 28  36 41  46 140&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#为在caesar.shoe这样的数据上使用prop.test函数
#需要将其转换为一个“成功”的向量（在这里和相反的很像）和一个“实验”的向量
caesar.shoe.yes &amp;lt;- caesar.shoe[&amp;quot;Yes&amp;quot;,]
caesar.shoe.total &amp;lt;- margin.table(caesar.shoe,2)
caesar.shoe.yes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  &amp;lt;4   4 4.5   5 5.5  6+ 
##   5   7   6   7   8  10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;caesar.shoe.total&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  &amp;lt;4   4 4.5   5 5.5  6+ 
##  22  35  42  48  54 150&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这样就很容易进行检验
prop.test(caesar.shoe.yes,caesar.shoe.total)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in prop.test(caesar.shoe.yes, caesar.shoe.total): Chi-squared
## approximation may be incorrect&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  6-sample test for equality of proportions without continuity
##  correction
## 
## data:  caesar.shoe.yes out of caesar.shoe.total
## X-squared = 9.2874, df = 5, p-value = 0.09814
## alternative hypothesis: two.sided
## sample estimates:
##     prop 1     prop 2     prop 3     prop 4     prop 5     prop 6 
## 0.22727273 0.20000000 0.14285714 0.14583333 0.14814815 0.06666667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，这个检验的结果是不显著的。但是从细节上说，剖腹产一组的数字太少，让人感觉这有些巧妙的不合理，此外，注意那条警告，它是因为一些格子的期望数小于5。 可以用prop.trend.test来检测不同部分的趋势。这个检测的本质是一个用每组的分数对不同部分进行的加权线性回归，其中对领斜率进行检验，就成为了一个自由度为1的&lt;span class=&#34;math inline&#34;&gt;\(\chi^2\)&lt;/span&gt;检验。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个函数有三个参数，x，n，score
#前两个与prop.test中的一致
#最后一个是赋予每组的分数，默认是简单的1,2，……，k
prop.trend.test(caesar.shoe.yes,caesar.shoe.total)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Chi-squared Test for Trend in Proportions
## 
## data:  caesar.shoe.yes out of caesar.shoe.total ,
##  using scores: 1 2 3 4 5 6
## X-squared = 8.0237, df = 1, p-value = 0.004617&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，若假设鞋子码数是线性的，那么可以看到一个显著的区别。这样的假设并不是为了保证检验的合理所必需的。反之，它表示了这个检验所对应得备择假设。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rc&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;8.4 r×c表格&lt;/h2&gt;
&lt;p&gt;为了分析两边都多于两个类的表格数据，可以用函数chisq.test或fisher.test，不过要注意后者在每一铬数字比较大而且超过两行或两列时的计算量非常大。在一个简单的例子里，已经介绍了chisq.test，不过对于更大的表而言，还有一些其他有趣的特征。 一个&lt;span class=&#34;math inline&#34;&gt;\(r\times c\)&lt;/span&gt;表格看起来像这样：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{array}{cccc|c}
      n_{11} &amp;amp; n_{12} &amp;amp; \cdots &amp;amp; n_{1c} &amp;amp; n_{1.}\\
      n_{21} &amp;amp; n_{22} &amp;amp; \cdots &amp;amp; n_{2c} &amp;amp; n_{2.}\\
      \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots &amp;amp; \vdots\\
      n_{r1} &amp;amp; n_{r2} &amp;amp; \cdots &amp;amp; n_{rc} &amp;amp; n_{r.}\\ 
      \hline
      n_{.1} &amp;amp; n_{.2} &amp;amp; \cdots &amp;amp; n_{.c} &amp;amp; n_{..}\\
\end{array}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样的一个表会导致几种不同的抽样方法，从而对应的表述“行和列之间没有关系”也有不同的含义了。每一行的总和可能是事先确定的，此时可能会检验每列的分布是否在每行上都一样。反之，如果每列的和是固定的，也可能是每一个个体随机地根据行或列来分组的。在后一种情况中，你应该会对检验&lt;em&gt;统计独立性&lt;/em&gt;这个假设感兴趣，即一个个体掉入第&lt;span class=&#34;math inline&#34;&gt;\(ij\)&lt;/span&gt;个格子的概率是边际概率的乘积：&lt;span class=&#34;math inline&#34;&gt;\(p_{i.}p{.j}\)&lt;/span&gt;。不过，这些不同的情况最后都使用了同样的分析方法。 如果行和列之间没有关系，那么每一格的期望值应该是： &lt;span class=&#34;math display&#34;&gt;\[
E_{ij}=\frac{n_{i.}\times n_{.j}}{n_{..}}
\]&lt;/span&gt; 这可以理解为把每一行的总数按照每一列总数的比例（或者反过来）进行分布，或者是将整个表格的总数按照行和列的比例进行分布。 检验统计量 &lt;span class=&#34;math display&#34;&gt;\[
X^2=\sum{\frac{(O-E)^2}{E}}
\]&lt;/span&gt; 服从一个自由度为&lt;span class=&#34;math inline&#34;&gt;\((r-1)\times (c-1)\)&lt;/span&gt;近似的&lt;span class=&#34;math inline&#34;&gt;\(\chi^2\)&lt;/span&gt;分布。这里是对整个表格求和，然后下标&lt;span class=&#34;math inline&#34;&gt;\(ij\)&lt;/span&gt;被省略了。这里&lt;span class=&#34;math inline&#34;&gt;\(O\)&lt;/span&gt;表示观测值，而&lt;span class=&#34;math inline&#34;&gt;\(E\)&lt;/span&gt;表示前文所述的期望值。 下面用4.5节提到的婚姻状况与咖啡因消费情况的表格来计算这个&lt;span class=&#34;math inline&#34;&gt;\(\chi^2\)&lt;/span&gt;检验：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;caff.matital &amp;lt;- matrix(c(652,1537,598,242,36,46,28,21,218
                         ,327,106,67),
                       nrow = 3,byrow = T)
colnames(caff.matital) &amp;lt;- c(&amp;quot;0&amp;quot;,&amp;quot;1-150&amp;quot;,&amp;quot;151-300&amp;quot;,&amp;quot;&amp;gt;300&amp;quot;)
rownames(caff.matital) &amp;lt;- c(&amp;quot;Married&amp;quot;,&amp;quot;Prev.married&amp;quot;,&amp;quot;Single&amp;quot;)
caff.matital&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                0 1-150 151-300 &amp;gt;300
## Married      652  1537     598  242
## Prev.married  36    46      28   21
## Single       218   327     106   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;chisq.test(caff.matital)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pearson&amp;#39;s Chi-squared test
## 
## data:  caff.matital
## X-squared = 47.386, df = 6, p-value = 1.567e-08&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检验结果高度显著，所以可以放心地拒绝独立性的假设。不过，一般来说，也会想知道偏差的程度。为了这个目的，可以仔细查看函数chisq.test的一些额外的返回值。 注意，函数chisq.test（就像函数lm一样）的返回值实际上比显示出来的信息更丰富：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;chisq.test(caff.matital)$expected&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                      0      1-150   151-300     &amp;gt;300
## Married      707.65188 1491.84889 571.74523 257.7540
## Prev.married  30.60495   64.52037  24.72718  11.1475
## Single       167.74317  353.63074 135.52759  61.0985&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;chisq.test(caff.matital)$observed&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                0 1-150 151-300 &amp;gt;300
## Married      652  1537     598  242
## Prev.married  36    46      28   21
## Single       218   327     106   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#接下来便可以对这两个表格进行彻底检查，看看差别在哪里
#检查每个格子对整体χ2的贡献通常是有用的
#这样的表格不能直接被析取，但很容易计算出来
E &amp;lt;- chisq.test(caff.matital)$expected
O &amp;lt;- chisq.test(caff.matital)$observed
(O-E)^2/E&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                       0    1-150   151-300      &amp;gt;300
## Married       4.3766322 1.366507 1.2056296 0.9628887
## Prev.married  0.9510407 5.316215 0.4331815 8.7079428
## Single       15.0572411 2.005471 6.4332189 0.5700246&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有一些格子有很大的贡献，特别是很多“戒除咖啡因”的单身者，同时曾经结过婚的分布方向则被转换为朝向更多的摄入——他们摄入的更多。不过，要在这些数据里找到一个偏离独立性的简单描述仍然是不容易的。 也可以对原始（没有成为列表）数据使用chisq.test，这里用4.5节提到的juul数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(juul)
chisq.test(tanner,sex)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pearson&amp;#39;s Chi-squared test
## 
## data:  tanner and sex
## X-squared = 28.867, df = 4, p-value = 8.318e-06&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对这两个变量检验独立性或许没什么意义，因为Tanner Stage的定义就是与性别有关的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;再来考虑练习题3.3中的情况。其中有连续10个病人进行了手术都没有并发症，而其期望的概率是20%。通过二项分布计算相关的单边检验。需要多大的样本量（仍然完全没有并发症）来使得检验结果变成统计上显著的？&lt;/li&gt;
&lt;li&gt;在美国西部的洛杉矶斑疹热事件中，747例病患死亡了210人，而东部的661例病患中死亡了122人。这个差异在统计上是显著的吗？&lt;/li&gt;
&lt;li&gt;对两种治疗胃溃疡的药物进行比较，结果如下&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;治愈&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;未治愈&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;总计&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;pirenzepin（哌仑西平）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;Trithiozine（三甲硫吗啉）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;31&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;总计&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;61&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;计算&lt;span class=&#34;math inline&#34;&gt;\(\chi^2\)&lt;/span&gt;检验和Fisher精确检验，并讨论它们的不同点。给出治愈率之差的95%置信区间。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;从1968年9月20日至1969年2月1日，一位老师买了254个蛋。他每天都记录在蒸的过程中有多少个蛋破裂到蛋清流出来的程度，以及有多少个蛋破裂但是蛋清没有流出。此外，他还记录了这个蛋尺寸A还是尺寸B。从1969年2月4日至1969你那4月10日，他还买了130个蛋，但是这次他用一个开孔器在蛋上开了个小孔，以防破裂。结果如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;center&#34;&gt;周期&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;大小&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;总计&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;破损&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;破裂&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;9月20日-2月1日&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;54&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;9月20日-2月1日&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;200&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;center&#34;&gt;2月4日-4月10日&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;60&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;center&#34;&gt;2月4日-4月10日&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;70&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;分析一下这样做是否有效果。&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;对于15次试验中有3个成功的现象，在成功概率是&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;的时候进行双边检验，让&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;从0到1以0.001为间隔进行变化，并且对检验的&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;值作图。解释为什么对双边置信区间的定义比较困难。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第七章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%83%E7%AB%A0/</link>
      <pubDate>Fri, 30 Mar 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%83%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-kruskal-wallis&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第七章 方差分析与Kruskal-Wallis检验&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;7.1 单因素方差分析&lt;/h2&gt;
&lt;p&gt;首先说下单因素方差分析的理论。令&lt;span class=&#34;math inline&#34;&gt;\(x_{ij}\)&lt;/span&gt;表示第&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;组的第&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;个观测，&lt;span class=&#34;math inline&#34;&gt;\(\bar x_i\)&lt;/span&gt;是第&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;组的均值，而&lt;span class=&#34;math inline&#34;&gt;\(\bar x_.\)&lt;/span&gt;是所有观测值的均值。 能将一个观测值分解为： &lt;span class=&#34;math display&#34;&gt;\[
x_{ij}=\bar x_.+(\bar x_i-\bar x_.)+(x_{ij}-\bar x_i)
\]&lt;/span&gt; 其中，&lt;span class=&#34;math inline&#34;&gt;\((\bar x_i-\bar x_.)\)&lt;/span&gt;为组内均值与全局均值的差，&lt;span class=&#34;math inline&#34;&gt;\((x_{ij}-\bar x_i)\)&lt;/span&gt;为观测值与组内均值的差。可以不严格地认为这个公式与下面的模型联系起来： &lt;span class=&#34;math display&#34;&gt;\[
X_{ij}=\mu+\alpha_i+\epsilon_{ij}, \epsilon \sim N(0,\sigma^2)
\]&lt;/span&gt; 假设所有组别的均值都是一样的，那么所有的&lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt;都应该是0.注意，假设这里的误差项&lt;span class=&#34;math inline&#34;&gt;\(\epsilon_{ij}\)&lt;/span&gt;是独立且方差相等的。 现在考虑一下括号这一项的平方和，它被成为&lt;em&gt;组内方差&lt;/em&gt;： &lt;span class=&#34;math display&#34;&gt;\[
SSD_W=\sum_{i}\sum_{j}(x_{ij}-\bar x_i)^2
\]&lt;/span&gt; 与组内方差： &lt;span class=&#34;math display&#34;&gt;\[
SSD_B=\sum_{i}\sum_{j}(\bar x_i-\bar x_.)^2=\sum_{i}n_i(\bar x_i-\bar x_.)^2
\]&lt;/span&gt; 可以证明： &lt;span class=&#34;math display&#34;&gt;\[
SSD_B+SSD_W=SSD_{total}=\sum_{i}\sum_{j}(x_{ij}-\bar x_.)^2
\]&lt;/span&gt; 这意味着全局的方差能够被分解为描述组件均值的部分与描述组内数值的部分。 实际上，在组间没有任何系统差距的情况下，应该期望平方和的分割按照每一项的自由度来进行。&lt;span class=&#34;math inline&#34;&gt;\(SSD_B\)&lt;/span&gt;的自由度为&lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt;，而&lt;span class=&#34;math inline&#34;&gt;\(SSD_W\)&lt;/span&gt;的自由度为&lt;span class=&#34;math inline&#34;&gt;\(N-k\)&lt;/span&gt;，其中&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;是组数，&lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt;是所有的观测数。 据此，可以计算&lt;em&gt;平均平方&lt;/em&gt;来正则化平方和：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
MS_W=SSD_W/(N-k)\\
MS_B=SSD_B/(k-1)
\]&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(MS_W\)&lt;/span&gt;是将独立的组内方差集成起来的方差，也就是对&lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;的估计。在没有真正的组间差异时，&lt;span class=&#34;math inline&#34;&gt;\(MS_B\)&lt;/span&gt;也是一个对&lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;的估计，单如果出现了组间差异，那么组件均值的差异和&lt;span class=&#34;math inline&#34;&gt;\(MS_B\)&lt;/span&gt;都会变得更大。所以，这可以成为一个通过对两个估计方差的比较来检查组间均值是否有显著差异的检验。这就是我们的目标是比较各组均值，但是名字称为&lt;em&gt;方差分析&lt;/em&gt;的原因。 简单的方差分析能在R中通过函数lm来做到，这也是回归分析里面的函数。同时，R也提供了函数aov和lme（linear mixed effects models，即线性混合效应模型，来自于nlime包）。 本节主要用来自于Altman的“红细胞叶酸盐”数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
attach(red.cell.folate)
summary(red.cell.folate)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      folate          ventilation
##  Min.   :206.0   N2O+O2,24h:8   
##  1st Qu.:249.5   N2O+O2,op :9   
##  Median :274.0   O2,24h    :5   
##  Mean   :283.2                  
##  3rd Qu.:305.5                  
##  Max.   :392.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，变量ventilation中的属性名称分别表示“24 h内的O&lt;sub&gt;2&lt;/sub&gt;与N&lt;sub&gt;2&lt;/sub&gt;O含量”，“手术中的O&lt;sub&gt;2&lt;/sub&gt;与N&lt;sub&gt;2&lt;/sub&gt;O含量”，以及“24 h内的O&lt;sub&gt;2&lt;/sub&gt;含量”。 接下来要开始做方差分析。通过函数lm得到一个模型对象，然后用函数anova将方差分析表析取出来。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(lm(folate~ventilation))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: folate
##             Df Sum Sq Mean Sq F value  Pr(&amp;gt;F)  
## ventilation  2  15516  7757.9  3.7113 0.04359 *
## Residuals   19  39716  2090.3                  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在结果第一行找到&lt;span class=&#34;math inline&#34;&gt;\(SSD_B\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(MS_B\)&lt;/span&gt;，在第二行可以找到&lt;span class=&#34;math inline&#34;&gt;\(SSD_W\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(MS_W\)&lt;/span&gt;。 值得注意的是，在R中，组间方差用分组属性变量的名字（ventilation）来称呼，而组内方差被称为Residual。 接下来用4.1节提到的juul数据集做下一个例子。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这个数据中的变量tanner是数值向量，而不是属性向量
#对于列出表格而言，这几乎没影响
#但是这可能造成方差分析出现严重错误
attach(juul)
anova(lm(igf1~tanner))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: igf1
##            Df   Sum Sq  Mean Sq F value    Pr(&amp;gt;F)    
## tanner      1 10985605 10985605  686.07 &amp;lt; 2.2e-16 ***
## Residuals 790 12649728    16012                      
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这并没有描述对数据的分组，而是一个对于分组编号的&lt;strong&gt;线性回归&lt;/strong&gt;。变量tanner的自由度为1，这是在提醒我们。 改正如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#重新板顶数据集juul以便使用新的定义
juul$tanner &amp;lt;- factor(juul$tanner,
                      labels = c(&amp;quot;Ⅰ&amp;quot;,&amp;quot;Ⅱ&amp;quot;,&amp;quot;Ⅲ&amp;quot;,&amp;quot;Ⅳ&amp;quot;,&amp;quot;Ⅴ&amp;quot;))
detach(juul)
attach(juul)
summary(tanner)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Ⅰ    Ⅱ    Ⅲ    Ⅳ    Ⅴ NA&amp;#39;s 
##  515  103   72   81  328  240&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(lm(igf1~tanner))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: igf1
##            Df   Sum Sq Mean Sq F value    Pr(&amp;gt;F)    
## tanner      4 12696217 3174054  228.35 &amp;lt; 2.2e-16 ***
## Residuals 787 10939116   13900                      
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个被绑定的数据框是它本身的一个复制品，Df这一列为tanner分配了4个自由度，这是它应得的。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;7.1.1 成对比较和多重检验&lt;/h3&gt;
&lt;p&gt;如果 &lt;em&gt;F&lt;/em&gt; 检验告诉我们组间有差异，那么问题马上升为找出差异在哪里。这时候就有必要对单个组进行比较。 能通过summary析取出回归系数以及它们的标准误和 &lt;em&gt;t&lt;/em&gt; 检验统计量。这些系数的意义并不是通常的回归线斜率，而是有如下的特定解释：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(lm(folate~ventilation))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = folate ~ ventilation)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -73.625 -35.361  -4.444  35.625  75.375 
## 
## Coefficients:
##                      Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)            316.62      16.16  19.588 4.65e-14 ***
## ventilationN2O+O2,op   -60.18      22.22  -2.709   0.0139 *  
## ventilationO2,24h      -38.62      26.06  -1.482   0.1548    
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 45.72 on 19 degrees of freedom
## Multiple R-squared:  0.2809, Adjusted R-squared:  0.2052 
## F-statistic: 3.711 on 2 and 19 DF,  p-value: 0.04359&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些估计值应该这样理解： 截距这一项是第一组（N&lt;sub&gt;2&lt;/sub&gt;O+O&lt;sub&gt;2&lt;/sub&gt;，24 h）的均值，而另外两个是相应组均值与第一组均值的&lt;em&gt;差&lt;/em&gt;。 如果比较所有的组别，应该进行&lt;em&gt;多重检验&lt;/em&gt;的修正。进行多次检验，会增加其中出现一个显著结果的概率，也就是说，这个 &lt;em&gt;p&lt;/em&gt; 值会变得夸张。一个常用的调整方法是&lt;em&gt;Bonferroni修正法&lt;/em&gt;。它基于这个事实：在 &lt;em&gt;n&lt;/em&gt; 个时间里至少观测到一个事件的概率小于每个事件的概率之和。所以，让显著性水平去除或是等价地用 &lt;em&gt;p&lt;/em&gt; 值去乘检验次数，能够得到一个保守的检验，其中显著的结果会少于或等于之前的显著性水平。 函数pairwise.t.test能计算所有的两组比较。它也能针对多重检验做调整，比如这样：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pairwise.t.test(folate,ventilation,p.adj=&amp;quot;bonferroni&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pairwise comparisons using t tests with pooled SD 
## 
## data:  folate and ventilation 
## 
##           N2O+O2,24h N2O+O2,op
## N2O+O2,op 0.042      -        
## O2,24h    0.464      1.000    
## 
## P value adjustment method: bonferroni&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果是一个成对比较的 &lt;em&gt;p&lt;/em&gt; 值表。这里的 &lt;em&gt;p&lt;/em&gt; 值已经通过Bonferroni修正过了，即通过未修正的 &lt;em&gt;p&lt;/em&gt; 值乘上检验的次数3而得到的。如果得到一个大于1的结果，那么调整过程会将调整过的 &lt;em&gt;p&lt;/em&gt; 值设为1。 函数pairwise.t.test的默认设置不是Bonferroni调整法，而是Holm提出的一个变形。在这个方法中，只有最小的 &lt;em&gt;p&lt;/em&gt; 值需要乘以所有检验的次数，而第二小的则乘以&lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt;，以此类推，除非这一步骤让它比前一个数更小了，因为 &lt;em&gt;p&lt;/em&gt; 值的顺序不应该被调整而改变。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pairwise.t.test(folate, ventilation)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pairwise comparisons using t tests with pooled SD 
## 
## data:  folate and ventilation 
## 
##           N2O+O2,24h N2O+O2,op
## N2O+O2,op 0.042      -        
## O2,24h    0.310      0.408    
## 
## P value adjustment method: holm&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;7.1.2 放宽对方差的假设&lt;/h3&gt;
&lt;p&gt;传统的单因素方差分析需要假设所有的组方差相等。不过，有另一个不需要这个假设的方法。函数oneway.test可以实现。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;oneway.test(folate~ventilation)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  One-way analysis of means (not assuming equal variances)
## 
## data:  folate and ventilation
## F = 2.9704, num df = 2.000, denom df = 11.065, p-value = 0.09277&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中，&lt;em&gt;p&lt;/em&gt;值增大到了一个不显著的值，可能是因为看起来与另外两组不等的组别也有着最大的方差。 也可以进行成对 &lt;em&gt;t&lt;/em&gt;检验，使得它们不需要用一个综合的标准差。可以通过参数pool.sd来控制。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pairwise.t.test(folate, ventilation, pool.sd = F)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pairwise comparisons using t tests with non-pooled SD 
## 
## data:  folate and ventilation 
## 
##           N2O+O2,24h N2O+O2,op
## N2O+O2,op 0.087      -        
## O2,24h    0.321      0.321    
## 
## P value adjustment method: holm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以再一次看到，结果在去除对方差的限制后就变得不显著了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;7.1.3 图像表示&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这这里展示一个图形，原始数据用条形图
#然后叠加上均值与SEM的值
xbar &amp;lt;- tapply(folate,ventilation,mean)
s &amp;lt;- tapply(folate,ventilation,sd)
n &amp;lt;- tapply(folate,ventilation,length)
sem &amp;lt;- s/sqrt(n)
#在stripchart函数中设定为小圆点，即pch=16
#并通过vertical=T使长条变成垂直的
stripchart(folate~ventilation,method=&amp;quot;jitter&amp;quot;,
           jitter=0.05,pch=16,vert=T)
#误差线用arrows来添加，这个函数在图上添加箭头，修改下就可以了
#前四个参数表示断点（x1，y1，x2，y2）
#参数angle指的是箭头与箭柄之间的角度，这里为90°
#参数code=3表示两端都要有箭头
#参数length值得是箭头的长度（打印时的尺寸）
arrows(1:3,xbar+sem,1:3,xbar-sem,angle = 90,code = 3,length = .1)
#显示均值与连接线可以通过函数lines来表示
#参数type=“b”表示同时画出点和线，然后在线与线之间给符号留下空间
#参数pch=4是一个交叉十字
#参数cex=2让这些符号变成两倍大
lines(1:3,xbar,pch=4,type = &amp;quot;b&amp;quot;,cex=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-30-r语言统计入门-第七章_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bartlett&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;7.1.4 Bartlett检验&lt;/h3&gt;
&lt;p&gt;可以用Bartlett检验来看看某个变量的分布是否在所有组中都有一样的方差。虽然与 &lt;em&gt;F&lt;/em&gt; 检验一样都能比较两个方差，但它对正态分布的假设是不稳定的。与函数var.test一样，它假设了来自不同组的数据时独立的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bartlett.test(folate~ventilation)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Bartlett test of homogeneity of variances
## 
## data:  folate by ventilation
## Bartlett&amp;#39;s K-squared = 2.0951, df = 2, p-value = 0.3508&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;kruskal-wallis&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;7.2 Kruskal-Wallis检验&lt;/h2&gt;
&lt;p&gt;Kruskal-Wallis是方差分析的非参数版本。基本上与Wilcoxon一样，不过这次检验的计算基于各组与平均秩的离差平方和。我们又一次能够利用分组独立性的假设，这样检验统计量的分布可以变成一个组合的问题，即对一组固定的数字抽样而得的组内秩。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;kruskal.test(folate~ventilation)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Kruskal-Wallis rank sum test
## 
## data:  folate by ventilation
## Kruskal-Wallis chi-squared = 4.1852, df = 2, p-value = 0.1234&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，这个检验没有表现出显著的差异。另外Kruskal-Wallis检验在假设成立的情况下没有参数方法那么高效，虽然它并不总是会给出较大的 &lt;em&gt;p&lt;/em&gt; 值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;7.3 双因素方差分析&lt;/h2&gt;
&lt;p&gt;令&lt;span class=&#34;math inline&#34;&gt;\(x_{ij}\)&lt;/span&gt;表示一个&lt;span class=&#34;math inline&#34;&gt;\(m\times n\)&lt;/span&gt;表的第&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;行第&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;列的观测值。这与单因素方差分析的记号一样，不过现在同一个&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;对应的观测之间都有联系，所以自然会查看每行的均值&lt;span class=&#34;math inline&#34;&gt;\(\bar x_{i.}\)&lt;/span&gt;与每列的均值&lt;span class=&#34;math inline&#34;&gt;\(\bar x_{.j}\)&lt;/span&gt;。 接着，可以查看行间方差： &lt;span class=&#34;math display&#34;&gt;\[
SSD_R=n\sum_{i}(\bar x_{i.}-\bar x_{..})^2
\]&lt;/span&gt; 与列间方差： &lt;span class=&#34;math display&#34;&gt;\[
SSD_C=m\sum_{j}(\bar x_{.j}-\bar x_{..})^2
\]&lt;/span&gt; 从总的方差中减去这两部分，就得到了残差方差： &lt;span class=&#34;math display&#34;&gt;\[
SSD_{res}=\sum_{i}\sum_{j}(x_{ij}-\bar x_{i.}-\bar x_{.j}+\bar x_{..})
\]&lt;/span&gt; 这可以表达为一个统计模型，其中观测由整体水平，行效应，列效应以及噪声项四部分组成： &lt;span class=&#34;math display&#34;&gt;\[
X_{ij}=\mu+\alpha_i+\beta_j+\epsilon_{ij} \qquad \epsilon_{ij}\sim N(0,\sigma^2)
\]&lt;/span&gt; 除非引入一些对参数的限制，否则这个模型中的参数并不是唯一定义的。如果引入&lt;span class=&#34;math inline&#34;&gt;\(\sum \alpha_i=0\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\sum\beta_j=0\)&lt;/span&gt;，那么对&lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\beta_j\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;的估计就变成了&lt;span class=&#34;math inline&#34;&gt;\(\bar x_{i.}-\bar x_{..}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\bar x_{.j}-\bar x_{..}\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\bar x_{..}\)&lt;/span&gt;。 将平方和项厨艺各自的自由度：SSD&lt;sub&gt;R&lt;/sub&gt;的是&lt;span class=&#34;math inline&#34;&gt;\(m-1\)&lt;/span&gt;，SSD&lt;sub&gt;C&lt;/sub&gt;的是 &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt;，SSD&lt;sub&gt;res&lt;/sub&gt;的是&lt;span class=&#34;math inline&#34;&gt;\((m-1)(n-1)\)&lt;/span&gt;：然后我们就得到了一系列平均平方。行影响和列影响的 &lt;em&gt;F&lt;/em&gt; 检验可以通过用对应的平均平方除以残差平均平方进行。 双因素方差分析需要将数据放在一个向量中，以及与其平行的两个分类属性。以一个使用enalaprilate之后的心率数据作为例子，即数据集heart.rate。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(heart.rate)
heart.rate&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     hr subj time
## 1   96    1    0
## 2  110    2    0
## 3   89    3    0
## 4   95    4    0
## 5  128    5    0
## 6  100    6    0
## 7   72    7    0
## 8   79    8    0
## 9  100    9    0
## 10  92    1   30
## 11 106    2   30
## 12  86    3   30
## 13  78    4   30
## 14 124    5   30
## 15  98    6   30
## 16  68    7   30
## 17  75    8   30
## 18 106    9   30
## 19  86    1   60
## 20 108    2   60
## 21  85    3   60
## 22  78    4   60
## 23 118    5   60
## 24 100    6   60
## 25  67    7   60
## 26  74    8   60
## 27 104    9   60
## 28  92    1  120
## 29 114    2  120
## 30  83    3  120
## 31  83    4  120
## 32 118    5  120
## 33  94    6  120
## 34  71    7  120
## 35  74    8  120
## 36 102    9  120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果打开程序包ISwR里data路径下的heart.rate.R文件，就会看到数据框的实际定义是这样的：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;heart.rate &amp;lt;- data.frame(hr = c(96,110,89,95,128,100,72,79,100,
                                92,106,86,78,124,98,68,75,106,
                                86,108,85,78,118,100,67,74,104,
                                92,114,83,83,118,94,71,74,102),
                         subj=gl(9,1,36),
                         time=gl(4,9,36,labels=c(0,30,60,120)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数gl（generate levels）能生成模式属性，专门为平衡的试验涉及而出现。它有3个参数：水平的数目，每块长度（每一水平重复多少次），以及结果的总长度。所以数据框的两个模式就是：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gl(9,1,36)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8
## [36] 9
## Levels: 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gl(4,9,36,labels=c(0,30,60,120))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0   0   0   0   0   0   0   0   0   30  30  30  30  30  30  30  30 
## [18] 30  60  60  60  60  60  60  60  60  60  120 120 120 120 120 120 120
## [35] 120 120
## Levels: 0 30 60 120&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦变量被定义好了，双因素方差分析就可以简单地如下计算：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(lm(hr~subj+time))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: hr
##           Df Sum Sq Mean Sq F value    Pr(&amp;gt;F)    
## subj       8 8966.6 1120.82 90.6391 4.863e-16 ***
## time       3  151.0   50.32  4.0696   0.01802 *  
## Residuals 24  296.8   12.37                      
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在模式方程（hr~subj+time）中交换subj和time能产生一模一样的分析结果，除了方差分析表中两行的顺序有变化。这是因为在处理一个平衡的设计（一个没有缺失值的完全双因素表）。在不平衡的情况下，属性的顺序会有很大影响。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;7.3.1 重复试验的图像&lt;/h3&gt;
&lt;p&gt;在给自己用的时候，做一个意大利面图是很有用的。在这种图中，来自同一个个体的数据被线段连在了仪器。可以使用函数interaction.plot。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#interaction.plot这个函数以一个属性为横轴，将另一个属性的数据画出来并用线段标记轨迹
interaction.plot(time,subj,hr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-30-r语言统计入门-第七章_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#实际上还有第四个参数，用来指示程序怎么处理不止一个观测的格子
#默认情况下，它会选择去平均数
#这就是为什么这个图中y周意义为hr均值
#如果更喜欢依照擦亮的时序来画图，可以修改如下：
interaction.plot(ordered(time),subj,hr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-30-r语言统计入门-第七章_files/figure-html/unnamed-chunk-17-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;friedman&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;7.4 Friedman检验&lt;/h2&gt;
&lt;p&gt;双因素方差分析在每格含有一个观测的情况下有一个非参数版本。Friedman的检验基于每行观测的秩。如果没有列间效应的影响，那么每一行的秩应该都是一样的。一个基于每列平方和的检验可以通过计算与正规化变为一个服从卡方分布的统计量。 在两列的情况下，Friedman检验与符号检验是等价的，这时可以通过二项分布来检验正号对以及负号对的概率是否相等&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意，区组属性在模型方程中用垂直线标明了，这种记法可被读成在subj情况下的time
friedman.test(hr~time | subj,data = heart.rate)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Friedman rank sum test
## 
## data:  hr and time and subj
## Friedman chi-squared = 8.5059, df = 3, p-value = 0.03664&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;7.5 回归分析中的方差分析表&lt;/h2&gt;
&lt;p&gt;单因素方差分析中的组间和组内波动可以被推广为&lt;em&gt;模型方差&lt;/em&gt;和残差方差&lt;em&gt;： &lt;span class=&#34;math display&#34;&gt;\[
SSD_{model}=\sum_{i}(\hat y_i-\hat y_.)^2 \\
SSD_{res}=\sum_{i}(y_i-\hat y_i)^2
\]&lt;/span&gt; 这两部分分割了整体的波动&lt;span class=&#34;math inline&#34;&gt;\(\sum_{i}(\hat y_i-\hat y_.)^2\)&lt;/span&gt;。这仅在模型含有一个截距项的时候成立。 与7.1节中的相似，可以用一个 &lt;/em&gt;F* 检验对模型的显著性做检验。在简单线性回归中，这与检验回归系数是否为0是等价的。 与单因素和双因素方差分析一样，能用函数anova将一个回归分析的方差分析表导出来。在thuesen中，可以这样操作：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(thuesen)
lm.velo &amp;lt;- lm(short.velocity~blood.glucose)
anova(lm.velo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: short.velocity
##               Df  Sum Sq  Mean Sq F value Pr(&amp;gt;F)  
## blood.glucose  1 0.20727 0.207269   4.414 0.0479 *
## Residuals     21 0.98610 0.046957                 
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;数据zelazo的格式是一个由向量构成的列表，它们分别代表四个组。将这个数据转化为函数lm可用的形式，然后进行相关性检验。考虑用 &lt;em&gt;t&lt;/em&gt;检验比较选择的两个组，或者是先将组合并。&lt;/li&gt;
&lt;li&gt;在数据lung中，三种不同的测量方法是否给出了系统性不同的结果，如果是，那么是哪个组表现的不同。&lt;/li&gt;
&lt;li&gt;用非参数方法对数据zelazo和lung重复前两个练习。&lt;/li&gt;
&lt;li&gt;数据juul中的变量igf1有明显的偏斜，并且与Tanner组的方差不一样，尝试通过对数变换与平方根变换来补偿这一点，以及使用Welch检验，即便如此，这个分析仍有问题，为什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第六章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%85%AD%E7%AB%A0/</link>
      <pubDate>Tue, 20 Mar 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%85%AD%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第六章 回归于相关性&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;6.1 简单线性回归&lt;/h2&gt;
&lt;p&gt;线性回归模型是如下定义的： &lt;span class=&#34;math display&#34;&gt;\[
y_i=\alpha+\beta x_i+\epsilon_i
\]&lt;/span&gt; 其中，假设&lt;span class=&#34;math inline&#34;&gt;\(\epsilon_i\)&lt;/span&gt;是独立的，并且来自于&lt;span class=&#34;math inline&#34;&gt;\(N(0,\sigma^2)\)&lt;/span&gt;。这个方程非随机的部分用一条直线描述&lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt;。这条直线的斜率（回归系数）是&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;，即&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;的每变化一单位给&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;所带来的增长。这条线与&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;轴交于截距点&lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;系数&lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(\sigma^2\)&lt;/span&gt;都能用最小二乘法来估计。找到让残差平方和最小的&lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;： &lt;span class=&#34;math display&#34;&gt;\[
SS_{res}=\sum_{i}[y_i-(\alpha+\beta x_i)]^2
\]&lt;/span&gt; 对于这些参数，能够推出使得SS&lt;sub&gt;res&lt;/sub&gt;最小的显式表达式： &lt;span class=&#34;math display&#34;&gt;\[
\hat \beta=\frac{\sum(x_i-\bar x)(y_i-\bar y)}{\sum(x_i-\bar x)^2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\hat\alpha =\bar y-\hat \beta\bar x
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;残差的方差可以通过SS&lt;sub&gt;res&lt;/sub&gt;/(n-2)来估计，标准差自然是这个值的平方根。&lt;/p&gt;
&lt;p&gt;本节使用thuesen作为例子&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
attach(thuesen)
#使用函数lm（线性模型）进行线性回归分析
#lm里面的参数是模型方程，波浪号~读作通过……来描述
lm(short.velocity ~ blood.glucose)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = short.velocity ~ blood.glucose)
## 
## Coefficients:
##   (Intercept)  blood.glucose  
##       1.09781        0.02196&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数lm的原始输出格式非常简单，只有估计出来的截距α和斜率β。可以看到最优拟合直线为short.velocity=1.098+0.0220*blood.glucose，但是没有给出任何像显著性检验之类的其他信息。&lt;/p&gt;
&lt;p&gt;lm的输出结果是一个模型对象。能够通过用析取函数来得到想要的结果。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#一个基本的析取函数是summary
summary(lm(short.velocity ~ blood.glucose))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = short.velocity ~ blood.glucose)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.40141 -0.14760 -0.02202  0.03001  0.43490 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)    1.09781    0.11748   9.345 6.26e-09 ***
## blood.glucose  0.02196    0.01045   2.101   0.0479 *  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.2167 on 21 degrees of freedom
##   (1 observation deleted due to missingness)
## Multiple R-squared:  0.1737, Adjusted R-squared:  0.1343 
## F-statistic: 4.414 on 1 and 21 DF,  p-value: 0.0479&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面对输出结果进行解剖：&lt;/p&gt;
&lt;p&gt;call：&lt;/p&gt;
&lt;p&gt;lm(formula = short.velocity ~ blood.glucose)&lt;/p&gt;
&lt;p&gt;与t.test中相似，输出的开头本质上在重复一个函数调用，若用户只是在R中将其输出，那么这部分意义不大。但是如果结果被保存在一个变量中，之后查看输出的时候，这部分就很有用了。&lt;/p&gt;
&lt;p&gt;Residuals:&lt;/p&gt;
&lt;p&gt; min 1Q Median 3Q Max&lt;/p&gt;
&lt;p&gt; -0.40141 -0.14760 -0.02202 0.03001 0.43490&lt;/p&gt;
&lt;p&gt;这部分简单的描述了残差的分布，可以帮助用户对分不行的假设做快速检查。根据定义，残差的均值是0，所以中位数应该离0不远，然后最大值、最小值的绝对值也应该大致相当。这个例子中，第三分位数明显过于接近0，不过考虑到这里样本量不多，所以无须太过担心。&lt;/p&gt;
&lt;p&gt;Coefficients:&lt;/p&gt;
&lt;p&gt; Estimate Std. Error t value Pr(&amp;gt;|t|)&lt;/p&gt;
&lt;p&gt;(Intercept) 1.09781 0.11748 9.345 6.26e-09 ***&lt;/p&gt;
&lt;p&gt;blood.glucose 0.02196 0.01045 2.101 0.0479 *&lt;/p&gt;
&lt;p&gt;这里再次见到了回归系数和截距，不过这次还伴随着标准误， &lt;em&gt;t&lt;/em&gt; 检验和 &lt;em&gt;p&lt;/em&gt; 值。最右边的符号是显著性水平。这个符号可以通过options(show.signif.stars=FALSE)来关闭。&lt;/p&gt;
&lt;p&gt;Residual standard error: 0.2167 on 21 degrees of freedom&lt;/p&gt;
&lt;p&gt;(1 observation deleted due to missingness)&lt;/p&gt;
&lt;p&gt;这是残差的波动情况，通过观测值在回归线附近的波动情况来估计模型参数σ。因为short.velocity有一个缺失值，所以这个模型并没有对整个数据集进行拟合。&lt;/p&gt;
&lt;p&gt;Multiple R-squared: 0.1737， Adjusted R-squared: 0.1343&lt;/p&gt;
&lt;p&gt;第一个是R&lt;sup&gt;2&lt;/sup&gt;，在简单线性回归中能将其理解为Person相关参数的平方，即R&lt;sup&gt;2&lt;/sup&gt;=r&lt;sup&gt;2&lt;/sup&gt;。另一个是修正后R&lt;sup&gt;2&lt;/sup&gt;；如果将其乘上100%，它就可以被理解为“方差降低的百分率”。&lt;/p&gt;
&lt;p&gt;F-statistic: 4.414 on 1 and 21 DF, p-value: 0.0479&lt;/p&gt;
&lt;p&gt;这是对假设回归系数是0而进行的F检验。这个检验在简单线性回归中并不特别，因为它只是对已有信息的重复——它在解释变量不止一个时就变得更有意义了。注意，这里的结果与斜率的 &lt;em&gt;t&lt;/em&gt; 检验结果一模一样。实际上，&lt;em&gt;F&lt;/em&gt; 检验是 &lt;em&gt;t&lt;/em&gt; 检验的平方：4.414=(2.101)&lt;sup&gt;2&lt;/sup&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这里展示如何画出残差图
#首先把数据点和回归线画出来
plot(blood.glucose, short.velocity)
abline(lm(short.velocity ~ blood.glucose))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-20-r语言统计入门-第六章_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#abline函数就是(a,b)-线段的意思。根据截距α和斜率β画一条直线
#它能够接受数值参数，比如abline(1.1, 0.022)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;6.2 残差与回归值&lt;/h2&gt;
&lt;p&gt;已经用summary从回归分析的结果中提取更多信息。另外两个进一步的析取函数是fitted和resid。它们的用法如下。为了方便，将lm的返回值存入变量lm.velo中。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm.velo &amp;lt;- lm(short.velocity ~ blood.glucose)
#函数fitted返回的是回归值
#即根据最佳拟合直线与给定的x值计算出来的y值
#对于这个结果就是1.098+0.0220*blood.glucose
fitted(lm.velo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        1        2        3        4        5        6        7        8 
## 1.433841 1.335010 1.275711 1.526084 1.255945 1.214216 1.302066 1.341599 
##        9       10       11       12       13       14       15       17 
## 1.262534 1.365758 1.244964 1.212020 1.515103 1.429449 1.244964 1.190057 
##       18       19       20       21       22       23       24 
## 1.324029 1.372346 1.451411 1.389916 1.205431 1.291085 1.306459&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#函数resid显示的残差是short.velocity的回归值与观测值之差
resid(lm.velo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            1            2            3            4            5 
##  0.326158532  0.004989882 -0.005711308 -0.056084062  0.014054962 
##            6            7            8            9           10 
##  0.275783754  0.007933665 -0.251598875 -0.082533795 -0.145757649 
##           11           12           13           14           15 
##  0.005036223 -0.022019994  0.434897199 -0.149448964  0.275036223 
##           17           18           19           20           21 
## -0.070057471  0.045971143 -0.182346406 -0.401411486 -0.069916424 
##           22           23           24 
## -0.175431237 -0.171085074  0.393541161&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意的是，回归值与残差都带着数据框thuesen的行名。同时，都没有第16个观测值的信息，因为原数据在这里缺少相应变量的值。&lt;/p&gt;
&lt;p&gt;在这里有必要讨论缺少数据时出现的一些问题。&lt;/p&gt;
&lt;p&gt;虽然用abline(lm.velo)更方便，可能仍会想到用lines将回归线画在图上，不过：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot(blood.glucose,short.velocity)
#lines(blood.glucose,fitted(lm.velo))
#Error in xy.coords(x, y) : &amp;#39;x&amp;#39; and &amp;#39;y&amp;#39; lengths differ
#Calls: local ... eval -&amp;gt; lines -&amp;gt; lines.default -&amp;gt; plot.xy -&amp;gt; xy.coords&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就会出现这个情况，一共有24个观测值，但其中只有23个回归值，因为short.velocity的值是NA。碰巧的是，这个错误在一串交织在一起的函数调用中出现，它们都在报错信息中标出来以便于理解。&lt;/p&gt;
&lt;p&gt;我们需要的是blood.glucose，但是需要病人的short.velocity也被记录了才行。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#函数is.na能够产生一个向量，在参数为NA的对应位置上标记为TRUE
#这个方法的好处之一就是回归线不会超过数据的范围
#lines(blood.glucose [!is.na(short.velocity)],fitted(lm.velo))
#但是在许多个变量中都有缺失值的时候就变得很繁琐
#...blood.glucose[!is.na(short.velocity) &amp;amp; !is.na(blood.glucose)]...
#用函数complete.cases更简单
#它能够筛选出在若干个变量甚至是整个数据框中都没有缺失值的观测
cc &amp;lt;- complete.cases(thuesen)
#然后就能用thuesen[cc,]来进行分析了
#不过有更好的方法
#可以用na.exclude方法处理缺失值
#它既可以作为lm的一个参数，也可以作为一个选项
options(na.action=na.exclude)
lm.velo &amp;lt;- lm(short.velocity ~ blood.glucose)
fitted(lm.velo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        1        2        3        4        5        6        7        8 
## 1.433841 1.335010 1.275711 1.526084 1.255945 1.214216 1.302066 1.341599 
##        9       10       11       12       13       14       15       16 
## 1.262534 1.365758 1.244964 1.212020 1.515103 1.429449 1.244964       NA 
##       17       18       19       20       21       22       23       24 
## 1.190057 1.324029 1.372346 1.451411 1.389916 1.205431 1.291085 1.306459&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意的是，第16个观测带有一个缺失值出现了
#在改变了选项后，有必要重新计算lm.velo
#为了在一幅图中通过将观测值与对应的回归值连起来而显示出残差
#函数segments用来画线段，它的参数是两端断点的坐标（x1,y1,x2,y2）
#但需要注意，segments函数不能单独使用，需要先plot一个图
#以下的plot与abline前文中已经有了，但是在RMD中最好还是重新调用下
plot(blood.glucose,short.velocity)
abline(lm(short.velocity ~ blood.glucose))
segments(blood.glucose,fitted(lm.velo),
        blood.glucose,short.velocity)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-20-r语言统计入门-第六章_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也能通过Q-Q图的线性性来检验残差的正态性
qqnorm(resid(lm.velo))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-20-r语言统计入门-第六章_files/figure-html/unnamed-chunk-6-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;6.3 预测与置信带&lt;/h2&gt;
&lt;p&gt;回归线通常与不确切的边界带一起展示。一般有两种边界带，通常被称为“窄”边界和“宽”边界。 窄边界，又叫&lt;em&gt;置信带&lt;/em&gt;，反映了这条线本身的不确定性，就像SEM反映了一个已知均值的准确度。如果观测数量很多的话，这个边界会很窄，这意味着这是一个比较准确的线。这个边界通常有明显的弧度，因为回归线在点阵的中心通常更准确。 宽边界，又叫&lt;em&gt;预测带&lt;/em&gt;，包含了未来观测值的不确定性。这些边界关心大部分数据，同时不会随着观测数量的增加而缩成一条线。这个边界是由回归线±2倍的标准差（95%的水平）而得到的。在小样本情况下，这个边界也是有弧度的，因为它们包含了这条直线本身的不确定性，只不过这个弧度没有置信带的那么明显。很显然，这些边界十分依赖残差正态性以及方差齐性的假设，所以如果你的数据不太满足这些性质，那么最好不要用这个边界。 无论是否计算了置信带与预测带，我们都能用函数predict析取出预测值。不加其他参数的话，它就只会输出回归值。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predict(lm.velo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        1        2        3        4        5        6        7        8 
## 1.433841 1.335010 1.275711 1.526084 1.255945 1.214216 1.302066 1.341599 
##        9       10       11       12       13       14       15       16 
## 1.262534 1.365758 1.244964 1.212020 1.515103 1.429449 1.244964       NA 
##       17       18       19       20       21       22       23       24 
## 1.190057 1.324029 1.372346 1.451411 1.389916 1.205431 1.291085 1.306459&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果加上参数，interval=&amp;quot;confidence&amp;quot;或者interval=&amp;quot;prediction&amp;quot;
#那么就能在预测值向量的基础上获得边界的值。这个补充描述也可以用缩写
predict(lm.velo,int=&amp;quot;c&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         fit      lwr      upr
## 1  1.433841 1.291371 1.576312
## 2  1.335010 1.240589 1.429431
## 3  1.275711 1.169536 1.381887
## 4  1.526084 1.306561 1.745607
## 5  1.255945 1.139367 1.372523
## 6  1.214216 1.069315 1.359118
## 7  1.302066 1.205244 1.398889
## 8  1.341599 1.246317 1.436881
## 9  1.262534 1.149694 1.375374
## 10 1.365758 1.263750 1.467765
## 11 1.244964 1.121641 1.368287
## 12 1.212020 1.065457 1.358583
## 13 1.515103 1.305352 1.724854
## 14 1.429449 1.290217 1.568681
## 15 1.244964 1.121641 1.368287
## 16       NA       NA       NA
## 17 1.190057 1.026217 1.353898
## 18 1.324029 1.230050 1.418008
## 19 1.372346 1.267629 1.477064
## 20 1.451411 1.295446 1.607377
## 21 1.389916 1.276444 1.503389
## 22 1.205431 1.053805 1.357057
## 23 1.291085 1.191084 1.391086
## 24 1.306459 1.210592 1.402326&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predict(lm.velo,int=&amp;quot;p&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in predict.lm(lm.velo, int = &amp;quot;p&amp;quot;): predictions on current data refer to _future_ responses&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         fit       lwr      upr
## 1  1.433841 0.9612137 1.906469
## 2  1.335010 0.8745815 1.795439
## 3  1.275711 0.8127292 1.738693
## 4  1.526084 1.0248161 2.027352
## 5  1.255945 0.7904672 1.721423
## 6  1.214216 0.7408499 1.687583
## 7  1.302066 0.8411393 1.762993
## 8  1.341599 0.8809929 1.802205
## 9  1.262534 0.7979780 1.727090
## 10 1.365758 0.9037136 1.827802
## 11 1.244964 0.7777510 1.712177
## 12 1.212020 0.7381424 1.685898
## 13 1.515103 1.0180367 2.012169
## 14 1.429449 0.9577873 1.901111
## 15 1.244964 0.7777510 1.712177
## 16       NA        NA       NA
## 17 1.190057 0.7105546 1.669560
## 18 1.324029 0.8636906 1.784367
## 19 1.372346 0.9096964 1.834996
## 20 1.451411 0.9745421 1.928281
## 21 1.389916 0.9252067 1.854626
## 22 1.205431 0.7299634 1.680899
## 23 1.291085 0.8294798 1.752690
## 24 1.306459 0.8457315 1.767186&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果中fit变量表示了期望得到的值，在这里就等于回归值，而lwr和upr就分别是下界和上界，即对那些blood.glucose取此值的病人预测short.velocity时的边界。警告信息并不是说有什么做错了，而是提醒这里有一个陷阱：这个边界不能被用来考量我们用来做回归的&lt;em&gt;已观测&lt;/em&gt;数据。因为在x的极值处，数据影响力更大，所以这会导致这些地方的边界离回归线更近，也就是说，预测带弯向了错误的方向。 将置信带与预测带加到散点图上的最好方法是通过函数matlines，它能将矩阵的每一列以某一个向量作为x轴画出来。 不过，有几个小障碍： + blood.glucose的值是随机排列的，不希望置信曲线上的线段杂乱无章的排列； + 下方的预测区间超出了画图区域； + matlines的命令需要放置不停更迭的线段样式和颜色。 解决方法是用合适的x（这里是blood.glucose）生成一个新数据框，然后在新数据框上进行预测：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#用希望进行预测的blood.glucose值生成了一个新的数据框
pred.frame &amp;lt;- data.frame(blood.glucose=4:20)
#pp和pc用来记录predict函数在pred.frame上的结果，并且保留了预测带和置信带
pp &amp;lt;- predict(lm.velo, int=&amp;quot;p&amp;quot;, newdata = pred.frame)
pc &amp;lt;- predict(lm.velo, int=&amp;quot;c&amp;quot;, newdata = pred.frame)
#先plot画一个标准的散点图，并为预测带预留了足够的空间，即参数ylim
#函数range返回一个长度为2的向量，其中是传入参数的最大值和最小值
#并需要使用na.rm=T在计算中忽略缺失值
plot(blood.glucose,short.velocity,
     ylim = range(short.velocity,pp,na.rm = T))
pred.gluc &amp;lt;- pred.frame$blood.glucose
matlines(pred.gluc,pc,lty = c(1,2,2),col = &amp;quot;black&amp;quot;)
matlines(pred.gluc,pp,lty = c(1,3,3),col = &amp;quot;green&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-03-20-r语言统计入门-第六章_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;6.4 相关性&lt;/h2&gt;
&lt;p&gt;相关系数是一个对称并且不随尺度变化的量，用于衡量两个随机变量之间的关联程度。它的值域是-1到1，这两个极端表示完美的相关，0则表示没有相关性。一个变量的较大值与另一个变量的较小值有关联时，相关系数是负的；如果两个变量有同时变大或减小的趋势，那么相关系数是负的。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;6.4.1 皮尔逊相关系数&lt;/h3&gt;
&lt;p&gt;皮尔逊相关系数扎根于二维正态分布中，其中理论上的相关性描述了密度函数的椭圆等高线。如果两个变量的方差都变换成了1，那么相关系数为0就对应圆形的等高线，其他情况下，椭圆变得越来越窄，最后在相关系数等于±1的时候坍缩成一条直线。 经验相关系数是： &lt;span class=&#34;math display&#34;&gt;\[
r=\frac{\sum(x_i-\bar x)(y_i-\bar y)}{\sqrt{\sum(x_i-\bar x)^2\sum(y_i-\bar y)}}
\]&lt;/span&gt; 可以证明，在&lt;span class=&#34;math inline&#34;&gt;\(x_i\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(y_i\)&lt;/span&gt;没有完美线性相关的情况下，&lt;span class=&#34;math inline&#34;&gt;\(\left| r \right|\)&lt;/span&gt;恒小于1，皮尔逊相关系数也因此又是被称为“线性相关系数”。 函数cor能计算两个或多个向量之间的相关系数。但如果对thuesen中的两个向量也这样操作，就会出现下面情况：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(blood.glucose,short.velocity)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Error in cor(blood.glucose,short.velocity):
#           missing observations in cov/cor&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R中所有的基本统计函数都要求输入的参数没有缺失值，或者要明确指定如何处理缺失值。对于函数mean，var，sd以及类似的单向量函数，可以传递na.rm=T这个参数告诉它们在计算之前应该移除缺失值。对于函数cor，可以写成：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(blood.glucose,short.velocity,use = &amp;quot;complete.obs&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.4167546&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数cor不使用na.rm=T，因为在移除缺失值与计算出错之外还有很多其他可能性。如果要对超过两个变量进行计算，也能用所有非缺失值&lt;em&gt;对&lt;/em&gt;的信息来进行计算。 可以通过如下代码得到一个数据框中所有变量的相关系数矩阵：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor(thuesen,use = &amp;quot;complete.obs&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                blood.glucose short.velocity
## blood.glucose      1.0000000      0.4167546
## short.velocity     0.4167546      1.0000000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，上面的计算并没有告诉我们这个相关系数是不是显著不为0的。为做到这点，需要使用cor.test，可以通过指定两个变量来使用它：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor.test(blood.glucose,short.velocity)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Pearson&amp;#39;s product-moment correlation
## 
## data:  blood.glucose and short.velocity
## t = 2.101, df = 21, p-value = 0.0479
## alternative hypothesis: true correlation is not equal to 0
## 95 percent confidence interval:
##  0.005496682 0.707429479
## sample estimates:
##       cor 
## 0.4167546&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;6.4.2 斯皮尔曼相关系数&lt;/h3&gt;
&lt;p&gt;同样也有非参数的方法。即斯皮尔曼秩相关系数&lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt;。它将观测值替换为它们的秩，再计算相关系数。在两变量独立的零假设下，可以计算出&lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt;的精确分布。 与之前一个函数对应一个检验不同，相关性检验的集中方法都打包进了cor.test中。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor.test(blood.glucose,short.velocity,method = &amp;quot;spearman&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in cor.test.default(blood.glucose, short.velocity, method =
## &amp;quot;spearman&amp;quot;): Cannot compute exact p-value with ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Spearman&amp;#39;s rank correlation rho
## 
## data:  blood.glucose and short.velocity
## S = 1380.4, p-value = 0.1392
## alternative hypothesis: true rho is not equal to 0
## sample estimates:
##      rho 
## 0.318002&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;6.4.3 肯德尔等级相关系数τ&lt;/h3&gt;
&lt;p&gt;第三个可供选择的算法是肯德尔等级相关系数，这个算法基于统计一致对和不一致对的数量。如果x坐标之差的符号与y坐标之差是一致的，那么这一对点是个一致对。在一个完美的单调关系中，所有的点对要么都是一致的；要么都是不一致的。在独立的情况下，一致对和不一致对的数量应该一样多。 相关系数&lt;span class=&#34;math inline&#34;&gt;\(\tau\)&lt;/span&gt;的一大优点是其意义比斯皮尔曼更好解释，但是除此之外，就没有什么优于对方的特点了。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cor.test(blood.glucose,short.velocity,method = &amp;quot;kendall&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in cor.test.default(blood.glucose, short.velocity, method =
## &amp;quot;kendall&amp;quot;): Cannot compute exact p-value with ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Kendall&amp;#39;s rank correlation tau
## 
## data:  blood.glucose and short.velocity
## z = 1.5604, p-value = 0.1187
## alternative hypothesis: true tau is not equal to 0
## sample estimates:
##       tau 
## 0.2350616&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在rmr数据集中，画出代谢率关于体重的散点图。对这个关系拟合一个曲线。这个模型预测70 kg的体重对应的代谢率是多少？对这条线的斜率给出一个95%置信区间。&lt;/li&gt;
&lt;li&gt;在juul数据集中，拟合一个IGF-I集中度的平方根关于25岁以上人群年龄的线性回归模型。&lt;/li&gt;
&lt;li&gt;在malaria数据集中，分析对数变换后的antibody水平关于年龄的关系。画出一个关系图。&lt;/li&gt;
&lt;li&gt;一个人能够这样对指定&lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt;的二维正态分布中生成模拟数据：（a）以均值为0，标准差为1的正态分布生成&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;;（b）以均值为&lt;span class=&#34;math inline&#34;&gt;\(\rho X\)&lt;/span&gt;，标准差为&lt;span class=&#34;math inline&#34;&gt;\(\sqrt{1-\rho^2}\)&lt;/span&gt;的正态分布生成&lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;。对于指定的相关系数，用这个方法画出模拟数据的散点图。计算部分数据的斯皮尔曼相关系数与肯德尔等级相关系数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第五章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</link>
      <pubDate>Wed, 14 Mar 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第五章 单样本与双样本检验&lt;/h1&gt;
&lt;p&gt; 本章的主题是进行连续型数据的比较，可能是比较两组数据，或者是一组数据与一个预设值。&lt;/p&gt;
&lt;p&gt; 首先介绍两个函数，用来进行 &lt;em&gt;t&lt;/em&gt; 检验的t.test和进行Wilcoxon检验的wilcox.test。它们都能够对单样本、双样本与配对样本进行检验。注意的是，双样本Wilcoxon检验在许多教科书中也叫作Mann-Whitney检验。&lt;/p&gt;
&lt;div id=&#34;-t-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.1 单样本 &lt;em&gt;t&lt;/em&gt; 检验&lt;/h2&gt;
&lt;p&gt; &lt;em&gt;t&lt;/em&gt; 检验假设数据来自一个正态分布。在单样本的情况下，假设&lt;span class=&#34;math inline&#34;&gt;\(x_1,...,x_n\)&lt;/span&gt;来自于服从&lt;span class=&#34;math inline&#34;&gt;\(N(\mu,\sigma^2)\)&lt;/span&gt;的独立随机变量，其中&lt;span class=&#34;math inline&#34;&gt;\(N(\mu,\sigma^2)\)&lt;/span&gt;表示均值为&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;、方差为&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;的正态分布。希望对假设&lt;span class=&#34;math inline&#34;&gt;\(\mu=\mu_0\)&lt;/span&gt;进行检验。我们能用样本的均值&lt;span class=&#34;math inline&#34;&gt;\(\overline{x}\)&lt;/span&gt;与标准差&lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;来估计真实参数&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;与&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; 下面讲下均值的标准误，即SEM（Standard Error of the Mean），对&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;个均值为&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;、方差为&lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;的随机变量求平均值，SEM便用来描述这个平均值的波动性，它的表达式是： &lt;span class=&#34;math display&#34;&gt;\[
SEM=\sigma/\sqrt{n}
\]&lt;/span&gt;  这个值能告诉我们观察到的均值偏离真实值多远是比较合适的。对于服从正态分布的数据，有一条一般性准则：有95%的数据会落在&lt;span class=&#34;math inline&#34;&gt;\(\mu\pm2\sigma\)&lt;/span&gt;这个区间里。所以如果&lt;span class=&#34;math inline&#34;&gt;\(\mu_0\)&lt;/span&gt;是真实的平均值，那么&lt;span class=&#34;math inline&#34;&gt;\(\overline{x}\)&lt;/span&gt;就应该落在&lt;span class=&#34;math inline&#34;&gt;\(\mu_0\pm2SEM\)&lt;/span&gt;中。也就是说，可以通过计算： &lt;span class=&#34;math display&#34;&gt;\[
t=\frac{\overline{x}-\mu_0}{SEM}
\]&lt;/span&gt; 来判断 &lt;em&gt;t&lt;/em&gt; 是否落在了一个接受域中。&lt;em&gt;t&lt;/em&gt; 应该以一定的概率落在这个接受域之外，这个概率被称为显著性水平。显著性水平一般被设为5%，此时接受域大致是-2到2的区间。&lt;/p&gt;
&lt;p&gt; 如果 &lt;em&gt;t&lt;/em&gt; 落在接受域之外，那么就在预设的显著性水平上拒绝零假设。另一种（等价的）的方法是计算 &lt;em&gt;p&lt;/em&gt; 值，它指的是得到一个绝对值上大于或等于当前 &lt;em&gt;t&lt;/em&gt; 值的概率，我们能在 &lt;em&gt;p&lt;/em&gt; 值小于显著性水平的情况下拒绝零假设。&lt;/p&gt;
&lt;p&gt; 下面是一个具体例子，反映11个女性的每日摄入能量（千焦）记录。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;daily.intake &amp;lt;- c(5260,5470,6180,6390,6515,6805,7515,7515,8230,8770)
#先看下简单的描述性统计
mean(daily.intake)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6865&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd(daily.intake)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1139.213&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(daily.intake)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     0%    25%    50%    75%   100% 
## 5260.0 6232.5 6660.0 7515.0 8770.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#现在想检验一下这些数据是否与推荐值7725千焦相差甚远，假设这些数据来自于正态分布
#那么目的就是检验这个分布是否满足μ=7725
#下面用t.test进行
t.test(daily.intake,mu=7725)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  One Sample t-test
## 
## data:  daily.intake
## t = -2.3872, df = 9, p-value = 0.04074
## alternative hypothesis: true mean is not equal to 7725
## 95 percent confidence interval:
##  6050.056 7679.944
## sample estimates:
## mean of x 
##      6865&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#t.test函数还有其他参数。这里用mu来指定零假设的均值（默认mu=0）
#此外，还可以用alternative=&amp;quot;greater&amp;quot;来检验均值是否大于μ
#或者是alternative=&amp;quot;less&amp;quot;来检验均值是否小于μ
#还可以通过conf.level=0.99来得到一个99%置信区间&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 下面是对这个结果的解释：&lt;/p&gt;
&lt;p&gt; One Sample t-test&lt;/p&gt;
&lt;p&gt; 这是对所做检验的描述。注意看函数的调用格式，t.test会自动发现用户需要进行一个单样本检验&lt;/p&gt;
&lt;p&gt; data：daily.intake&lt;/p&gt;
&lt;p&gt; 这个是被检验的数据。&lt;/p&gt;
&lt;p&gt; t=-2.8208, df=10, p-value=0.01814&lt;/p&gt;
&lt;p&gt; 这里显示了 &lt;em&gt;t&lt;/em&gt; 统计量，相应的自由度df以及准确的 &lt;em&gt;p&lt;/em&gt; 值。这里不用拿着一张 &lt;em&gt;t&lt;/em&gt; 分布表来查这个统计量落在了那两个分位数之间，就能够立刻看到 &lt;em&gt;p&lt;/em&gt; &amp;lt;0.05，于是在自定义的5%显著性水平下，数据显著偏离了原假设中的均值7725千焦。&lt;/p&gt;
&lt;p&gt; alternative hypothesis：true mean is not equal to 7725&lt;/p&gt;
&lt;p&gt; 这里有两个重要的信息：（a）原假设中均值；（b）这是一个双边检验（“not equal to 7725”）。&lt;/p&gt;
&lt;p&gt; 95 percent confidence interval:&lt;/p&gt;
&lt;p&gt; 5986.348 7520.925&lt;/p&gt;
&lt;p&gt; 这是真实均值的95%置信区间：这个区间是一个集合，如果原假设的值来自于这个集合，那么数据便不会显著的偏离。对 &lt;em&gt;t&lt;/em&gt; 检验的步骤进行逆向求解，可以得到使得 &lt;em&gt;t&lt;/em&gt; 统计量会落在接受域中的一组&lt;span class=&#34;math inline&#34;&gt;\(\mu_0\)&lt;/span&gt;。 &lt;span class=&#34;math display&#34;&gt;\[
\overline{x}-t_{0.975}(f)\times SEM\lt\mu\lt\overline{x}+t_{0.975}(f)\times SEM
\]&lt;/span&gt;  sample estimates:&lt;/p&gt;
&lt;p&gt; mean of x&lt;/p&gt;
&lt;p&gt; 6753.636&lt;/p&gt;
&lt;p&gt; 位于最后的这部分是观测值的均值，也就是对真实均数的（点）估计。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wilcoxon&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.2 Wilcoxon符号秩检验&lt;/h2&gt;
&lt;p&gt; &lt;em&gt;t&lt;/em&gt; 检验在用于那些不来自于正态分布的数据时比较稳定，尤其是在大样本情况下。不过有的时候会避免做出这种假设（即非正态分布数据），这时最好用&lt;em&gt;不依赖于分布的方法&lt;/em&gt;，这些方法通常都把数据替换成了相应的顺序统计量。&lt;/p&gt;
&lt;p&gt; 对Wilcoxon秩和检验的实际应用基本上与 &lt;em&gt;t&lt;/em&gt; 检验相同。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#与t.test一样，wilcox.test有mu和alternative两个参数
#此外，还有correct这个参数，用来指示是否需要进行连续型修正，比如correct=F表示不用
#还有exact，用来指示是否需要进行精确的计算，也用TRUE和FALSE这两个逻辑值来控制
wilcox.test(daily.intake, mu=7725)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in wilcox.test.default(daily.intake, mu = 7725): cannot compute
## exact p-value with ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Wilcoxon signed rank test with continuity correction
## 
## data:  daily.intake
## V = 8, p-value = 0.05263
## alternative hypothesis: true location is not equal to 7725&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 这里比t.test的输出更短些，因为一个分参数检验不会出现类似于参数估计以及置信边界等概念。&lt;/p&gt;
&lt;p&gt; 结果里面的&lt;em&gt;V&lt;/em&gt;是检验统计量，表示的是正数对应的秩和，在这个例子中，因为存在两个7515，所以&lt;em&gt;p&lt;/em&gt;值是通过正态近似的方法来计算的。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-t-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.3 两样本 &lt;em&gt;t&lt;/em&gt; 检验&lt;/h2&gt;
&lt;p&gt; 两样本 &lt;em&gt;t&lt;/em&gt; 检验主要用来检验两个样本是否来自于均值相等的分布。&lt;/p&gt;
&lt;p&gt; 两样本检验和单样本检验的理论基础差别不大。现在从两个组别中抽出数据&lt;span class=&#34;math inline&#34;&gt;\(x_{11}...,x_{1n_1}\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(x_{21},...,x_{2n_2}\)&lt;/span&gt;，假设它们是从&lt;span class=&#34;math inline&#34;&gt;\(N(\mu_1,\sigma_1^2)\)&lt;/span&gt;与&lt;span class=&#34;math inline&#34;&gt;\(N(\mu_2,\sigma_2^2)\)&lt;/span&gt;两个分布中抽取的样本，并希望检验零假设&lt;span class=&#34;math inline&#34;&gt;\(\mu_1=\mu_2\)&lt;/span&gt;。接着计算： &lt;span class=&#34;math display&#34;&gt;\[
t=\frac{\overline{x}_2-\overline{x}_1}{SEDM}
\]&lt;/span&gt;  SEDM（Standard Error of Difference of Means）是&lt;em&gt;均值差的标准误&lt;/em&gt;，被定义为： &lt;span class=&#34;math display&#34;&gt;\[
SEDM=\sqrt{SEM_1^2+SEM^2_2}
\]&lt;/span&gt;  对于是否假设两组数据的方差相等，SEDM有两种相应计算的方法。“经典”的方法假设方差相等。在这个方法下，先根据两组的标准差计算一个综合性的 &lt;em&gt;s&lt;/em&gt; ，然后将它代入SEM。零假设下的 &lt;em&gt;t&lt;/em&gt; 值服从自由度为&lt;span class=&#34;math inline&#34;&gt;\(n_1+n_2-2\)&lt;/span&gt;的 &lt;em&gt;t&lt;/em&gt; 分布。&lt;/p&gt;
&lt;p&gt; 另一种方法由Welch提出，即以两组各自的标准差&lt;span class=&#34;math inline&#34;&gt;\(s_1\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(s_2\)&lt;/span&gt;来计算SEM。这个方法算出来 &lt;em&gt;t&lt;/em&gt; 统计量已经不满足 &lt;em&gt;t&lt;/em&gt; 分布了，不过可以通过一个 &lt;em&gt;t&lt;/em&gt; 分布来近似。这个近似分布的自由度能够通过&lt;span class=&#34;math inline&#34;&gt;\(s_1,s_2\)&lt;/span&gt;与样本量来得到，一般不是整数。&lt;/p&gt;
&lt;p&gt; 回头看看每日消耗鞥能量的数据（见1.2.14小节），来比较一下两组女性每日消耗的能量是否有差别。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
attach(energy)
energy&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    expend stature
## 1    9.21   obese
## 2    7.53    lean
## 3    7.48    lean
## 4    8.08    lean
## 5    8.09    lean
## 6   10.15    lean
## 7    8.40    lean
## 8   10.88    lean
## 9    6.13    lean
## 10   7.90    lean
## 11  11.51   obese
## 12  12.79   obese
## 13   7.05    lean
## 14  11.85   obese
## 15   9.97   obese
## 16   7.48    lean
## 17   8.79   obese
## 18   9.69   obese
## 19   9.68   obese
## 20   7.58    lean
## 21   9.19   obese
## 22   8.11    lean&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 这个数据框的两列包含了所有我们需要的信息。属性变量satrure包含了分组信息，而数值变量expend包含了以兆焦耳为单位的能量消耗。我们只要传递一个模型方程，就能通过R中的t.test和wilcox.test来分析这种格式的数据。&lt;/p&gt;
&lt;p&gt; 我们的目的是两组的水平是否有差异，所以我们用一个 &lt;em&gt;t&lt;/em&gt; 检验。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#~波浪号是致命expend是通过stature来描述的
t.test(expend~stature)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  expend by stature
## t = -3.8555, df = 15.919, p-value = 0.001411
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -3.459167 -1.004081
## sample estimates:
##  mean in group lean mean in group obese 
##            8.066154           10.297778&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 输出的内容和单样本检验中的基本一致。其中均值之差的置信区间不包含0，与 &lt;em&gt;p&lt;/em&gt; 值的结果相统一，意味着在5%的置信水平下差异是显著的。&lt;/p&gt;
&lt;p&gt; R中的 &lt;em&gt;t&lt;/em&gt; 检验默认采用Welch的变种算法，当不假设两组方差相等时就应该用它，这也会导致非整数的自由度。&lt;/p&gt;
&lt;p&gt; 为进行平常的 &lt;em&gt;t&lt;/em&gt; 检验，应该明确方差相等这个假设，可以通过使参数var.equal=T来达到这一点：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t.test(expend~stature, var.equal=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Two Sample t-test
## 
## data:  expend by stature
## t = -3.9456, df = 20, p-value = 0.000799
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -3.411451 -1.051796
## sample estimates:
##  mean in group lean mean in group obese 
##            8.066154           10.297778&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.4 比较方差&lt;/h2&gt;
&lt;p&gt; 虽然在R中不需要假设方差相等也能进行两样本 &lt;em&gt;t&lt;/em&gt; 检验，但仍可能对这个假设本身是否正确感兴趣。为此，R提供了var.test函数来做到这一点。这个函数的主要功能是对两样本的方差进行 &lt;em&gt;F&lt;/em&gt; 检验。它的使用方法和t.test一样：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var.test(expend~stature)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  F test to compare two variances
## 
## data:  expend by stature
## F = 0.78445, num df = 12, denom df = 8, p-value = 0.6797
## alternative hypothesis: true ratio of variances is not equal to 1
## 95 percent confidence interval:
##  0.1867876 2.7547991
## sample estimates:
## ratio of variances 
##           0.784446&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 这里检验结果不显著，所以不能拒绝方差相等这个假设，但是置信区间非常宽。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;wilcoxon&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.5 两样本Wilcoxon检验&lt;/h2&gt;
&lt;p&gt; 如果对正态分布假设有所怀疑，那么可能更需要使用一个非参数检验。两样本Wilcoxon检验用数据的秩（不考虑分组）代替数据本身，然后计算某一组中的秩和。这样便简化成了从1~ n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;中不重复地抽出&lt;em&gt;n&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;个数字的问题。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;wilcox.test(expend~stature)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in wilcox.test.default(x = c(7.53, 7.48, 8.08, 8.09, 10.15, 8.4, :
## cannot compute exact p-value with ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  expend by stature
## W = 12, p-value = 0.002122
## alternative hypothesis: true location shift is not equal to 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 统计量 &lt;em&gt;W&lt;/em&gt; 是第一组数据的秩和减去理论最小值（如果最小的&lt;em&gt;n&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;个数都在第一组中，那么 &lt;em&gt;W&lt;/em&gt; 就等于0）。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-t-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.6 配对 &lt;em&gt;t&lt;/em&gt; 检验&lt;/h2&gt;
&lt;p&gt; 在同一个实验单位中有着两个度量值时使用配对检验。该检验主要通过做差来将问题简化为单样本检验。不过这种方法意味着我们要假设这个差值与不同水平的度量值是独立的。我们可以将每一对数构成的点与直线y=x画在同一幅图上，或是将每一对数的差与它们的均值画在同一幅图上（即Bland~Altman图），这是有效的图形检查方法。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#还是月经前后能量摄入
attach(intake)
intake&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     pre post
## 1  5260 3910
## 2  5470 4220
## 3  5640 3885
## 4  6180 5160
## 5  6390 5645
## 6  6515 4680
## 7  6805 5265
## 8  7515 5975
## 9  7515 6790
## 10 8230 6900
## 11 8770 7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这里的关键是11位女性都被测量了2次，所以查看个人数据的差值是合理的
post-pre&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] -1350 -1250 -1755 -1020  -745 -1835 -1540 -1540  -725 -1330 -1435&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#基本上都是负数
#这意味着月经后有更低的能量摄入
#t检验中paired=T表示希望进行一个配对检验
t.test(pre, post, paired = T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Paired t-test
## 
## data:  pre and post
## t = 11.941, df = 10, p-value = 3.059e-07
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  1074.072 1566.838
## sample estimates:
## mean of the differences 
##                1320.455&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t.test(pre, post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Welch Two Sample t-test
## 
## data:  pre and post
## t = 2.6242, df = 19.92, p-value = 0.01629
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##   270.5633 2370.3458
## sample estimates:
## mean of x mean of y 
##  6753.636  5433.182&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#后者的t明显变小了，虽然在5%的水平下显著
#置信区间几乎是配对检验中的4倍
#从这两个可以看出，如果没有对比同一个人测量的前后信息，那么准确性就会降低
#当然也可以得出这样的结论
#在同一个人上进行两次测量，比对两组分别处于月经前、后的女性进行测量，效率更高&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;wilcoxon&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;5.7 配对Wilcoxon检验&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#与t.test函数相同
wilcox.test(pre, post, paired = T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in wilcox.test.default(pre, post, paired = T): cannot compute exact
## p-value with ties&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Wilcoxon signed rank test with continuity correction
## 
## data:  pre and post
## V = 66, p-value = 0.00384
## alternative hypothesis: true location shift is not equal to 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 这个结果与 &lt;em&gt;t&lt;/em&gt; 检验没有多大差别。&lt;em&gt;p&lt;/em&gt; 值没有那么极端。&lt;/p&gt;
&lt;p&gt; 又一次，在由数据相等的情况下无法精确的计算 &lt;em&gt;p&lt;/em&gt; 值，这里有两个相等的差值都是-1540。&lt;/p&gt;
&lt;p&gt; 对当前数据很容易计算精确的 &lt;em&gt;p&lt;/em&gt; 值。这是11个正差值的概率，加上11个负差值的概率，即&lt;span class=&#34;math inline&#34;&gt;\(2\times(\frac{1}{2})^{11}=\frac{1}{1024}=0.00098\)&lt;/span&gt;，所以近似计算的&lt;em&gt;p&lt;/em&gt; 值差不多是真实值的4倍。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;练习题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;数据集react（注意这是一个向量）的值看起来是正态分布的吗，它的均值在 &lt;em&gt;t&lt;/em&gt; 检验下显著地不等于0吗&lt;/li&gt;
&lt;li&gt;在数据集vitcap中使用 &lt;em&gt;t&lt;/em&gt; 检验比较两组肺活量，并计算99%置信区间。这个比较结果可能会产生误导，为什么&lt;/li&gt;
&lt;li&gt;用非参数方法对react和vitcap两个数据做分析。&lt;/li&gt;
&lt;li&gt;使用图像法检查intake数据集的配对 &lt;em&gt;t&lt;/em&gt; 检验的建设是否合理。&lt;/li&gt;
&lt;li&gt;函数shapiro.test基于Q-Q图的线性性来检验正态性。对react数据进行这个检验，它对移除异常值有帮助吗。&lt;/li&gt;
&lt;li&gt;如果忽略潜在的时间因素影响，能通过简单的方法（怎么做）送ashina里的交叉实验中分析药物效果。提示，考虑个体内部的差异，如果只出现了时间因素的影响，两组差异会有什么表现&lt;/li&gt;
&lt;li&gt;在10个含有25个观测值的模拟正态分布数据上分别做单样本 &lt;em&gt;t&lt;/em&gt; 检验。用不同的分布再重复这个实验；尝试自由度为2的&lt;em&gt;t&lt;/em&gt; 分布，以及指数分布（在后一种情况下对均值为1的分布做检验）。你能自动化这个实验从而重复更多次吗。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第四章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</link>
      <pubDate>Wed, 28 Feb 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第四章 描述性统计和图形&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.1 单组的汇总统计量&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#计算均值、标准差、方差和中位数
#比如x为50个来自于正态分布的数值的向量
x &amp;lt;- rnorm(50)
mean(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.1020794&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.7992287&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;var(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.6387666&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;median(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -0.09860993&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#经验后分位数
quantile(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          0%         25%         50%         75%        100% 
## -2.27594629 -0.51963199 -0.09860993  0.52209912  1.33801565&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#看看如何取得十分位数
#可以增加一个包含十分位数的参数
pvec &amp;lt;- seq(0, 1, 0.1)
pvec&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;quantile(x, pvec)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          0%         10%         20%         30%         40%         50% 
## -2.27594629 -1.03235747 -0.57501258 -0.45242250 -0.33083825 -0.09860993 
##         60%         70%         80%         90%        100% 
##  0.03587906  0.35254339  0.55122580  0.93672980  1.33801565&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有缺失值，那么问题会复杂一些，下面讲个例子。&lt;/p&gt;
&lt;p&gt;数据集juul，包含在ISwR包中。是Anders Juul的报告中的数据。该报告是关于健康人群，主要是学龄儿童的血清IGF-l的。现在只使用igfl。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#当试着计算igfl的均值时，出现一个问题
library(ISwR)
attach(juul)
mean(igf1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#R不能跳过缺失值
#然而可以用na.rm参数来移除未知值
mean(igf1,na.rm=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 340.168&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#但有个例外，length函数不识别na.rm
#所以不能用它来确定非缺失观测的个数
#可以用下面的语句来实现
#这个结构说明，逻辑值若用于算数计算，那么TRUE转换为1，FALSE转换为0
sum(!is.na(igf1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1018&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#summary函数可以汇总数字变量
#其中，1stQu.和3rdQu.分别指经验四分位数（0.25，0.75）
summary(igf1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&amp;#39;s 
##    25.0   202.2   313.5   340.2   462.8   915.0     321&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以对整个数据集进行汇总
summary(juul)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       age            menarche          sex             igf1      
##  Min.   : 0.170   Min.   :1.000   Min.   :1.000   Min.   : 25.0  
##  1st Qu.: 9.053   1st Qu.:1.000   1st Qu.:1.000   1st Qu.:202.2  
##  Median :12.560   Median :1.000   Median :2.000   Median :313.5  
##  Mean   :15.095   Mean   :1.476   Mean   :1.534   Mean   :340.2  
##  3rd Qu.:16.855   3rd Qu.:2.000   3rd Qu.:2.000   3rd Qu.:462.8  
##  Max.   :83.000   Max.   :2.000   Max.   :2.000   Max.   :915.0  
##  NA&amp;#39;s   :5        NA&amp;#39;s   :635     NA&amp;#39;s   :5       NA&amp;#39;s   :321    
##      tanner        testvol      
##  Min.   :1.00   Min.   : 1.000  
##  1st Qu.:1.00   1st Qu.: 1.000  
##  Median :2.00   Median : 3.000  
##  Mean   :2.64   Mean   : 7.896  
##  3rd Qu.:5.00   3rd Qu.:15.000  
##  Max.   :5.00   Max.   :30.000  
##  NA&amp;#39;s   :240    NA&amp;#39;s   :859&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#其中menarche、sex、tanner被编码为数值变量
#虽然它们显然是分类变量
#可以进行如下改进
detach(juul)
juul$sex &amp;lt;- factor(juul$sex, labels=c(&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;))
juul$menarche &amp;lt;- factor(juul$menarche, labels=c(&amp;quot;No&amp;quot;,&amp;quot;Yes&amp;quot;))
juul$tanner &amp;lt;- factor(juul$tanner, labels=c(&amp;quot;Ⅰ&amp;quot;,&amp;quot;Ⅱ&amp;quot;,&amp;quot;Ⅲ&amp;quot;,&amp;quot;Ⅳ&amp;quot;,&amp;quot;Ⅴ&amp;quot;))
attach(juul)
summary(juul)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       age         menarche     sex           igf1        tanner   
##  Min.   : 0.170   No  :369   M   :621   Min.   : 25.0   Ⅰ   :515  
##  1st Qu.: 9.053   Yes :335   F   :713   1st Qu.:202.2   Ⅱ   :103  
##  Median :12.560   NA&amp;#39;s:635   NA&amp;#39;s:  5   Median :313.5   Ⅲ   : 72  
##  Mean   :15.095                         Mean   :340.2   Ⅳ   : 81  
##  3rd Qu.:16.855                         3rd Qu.:462.8   Ⅴ   :328  
##  Max.   :83.000                         Max.   :915.0   NA&amp;#39;s:240  
##  NA&amp;#39;s   :5                              NA&amp;#39;s   :321               
##     testvol      
##  Min.   : 1.000  
##  1st Qu.: 1.000  
##  Median : 3.000  
##  Mean   : 7.896  
##  3rd Qu.:15.000  
##  Max.   :30.000  
##  NA&amp;#39;s   :859&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#变量sex、menarche和tanner被转换为辅以适当水平名称的因子变量
#在原始数据中，它们以数字代码显示
#这些转化后的变量重新放回数据集juul中，从而替代原来的sex等
#也可以用transformf函数（或within）
juul &amp;lt;- transform(juul,
                sex=factor(sex,labels=c(&amp;quot;M&amp;quot;,&amp;quot;F&amp;quot;)),
                menarche=factor(menarche,labels=c(&amp;quot;No&amp;quot;,&amp;quot;Yes&amp;quot;)),
                tanner=factor(tanner,labels=c(&amp;quot;Ⅰ&amp;quot;,&amp;quot;Ⅱ&amp;quot;,&amp;quot;Ⅲ&amp;quot;,&amp;quot;Ⅳ&amp;quot;,&amp;quot;Ⅴ&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.2 分布的图形显示&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2.1 直方图&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#绘制x的直方图
hist(x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;在hist函数中调用breaks=n，可以在直方图中得到大约n个条，这是因为算法会尽力创建“合适”的分割点。亦可以通过指定breaks为一个向量而不仅是数字完成区间分割的完全控制。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mid.age &amp;lt;- c(2.5,7.5,13,16.5,17.5,19,22.5,44.5,70.5)
acc.count &amp;lt;- c(28,46,58,20,31,64,149,316,103)
age.acc &amp;lt;- c(0,5,10,16,17,18,20,25,60,80)
brk &amp;lt;- c(0,5,10,16,17,18,20,25,60,80)
hist(age.acc, breaks=brk)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以在hist函数中，用freq=T指定列高为数据数量，freq=F可以得到密度显示&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2.2 经验累计分布&lt;/h3&gt;
&lt;p&gt;经验累计分布函数定义为小于等于x的数据占总数据的比例，可以作图如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n &amp;lt;- length(x)
#type=&amp;quot;s&amp;quot;给出一个阶梯函数，其中(x,y)是步长额左端点，ylim是两个元素的向量，用于指定y坐标的边界点
plot(sort(x),(1:n)/n,type=&amp;quot;s&amp;quot;,ylim=c(0,1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;q-q&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2.3 Q-Q图&lt;/h3&gt;
&lt;p&gt;计算经验累积分布函数的目的之一，是观察数据是否能被假设成来自正态分布。为更好地评估，可以画出第k个最小观测值和来自标准正态分布的n个值中第k个最小观测值的图形。关键之处是，用这种方法，如果数据是来自任何均值和标准差的正态分布，应该得到一条直线。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以用qqnorm函数来做这个
qqnorm(x)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2.4 箱式图&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#两个按行并列图的布局使用mfrow作图参数指定
#mfcol参数用来绘制按排列的图形
#值得注意的是，最后把布局参数重新设定回c(1,1)是必要的
#除非希望继续画此种并列图
par(mfrow=c(1,2))
boxplot(IgM)
boxplot(log(IgM))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow=c(1,1))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.3 分组数据的汇总统计量&lt;/h2&gt;
&lt;p&gt;当处理分组数据的时候，经常会希望得到一些按组计算的不同的总结统计量，比如均值和标准差的一张表格。为此目的，可以使用tapply函数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(red.cell.folate)
#tapply函数提取folate变量，根据ventilation分组
#然后对每一组计算均值
tapply(folate,ventilation,mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## N2O+O2,24h  N2O+O2,op     O2,24h 
##   316.6250   256.4444   278.0000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#同样的方法，可以计算标准差和数目
tapply(folate,ventilation,sd)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## N2O+O2,24h  N2O+O2,op     O2,24h 
##   58.71709   37.12180   33.75648&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tapply(folate,ventilation,length)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## N2O+O2,24h  N2O+O2,op     O2,24h 
##          8          9          5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以像下面这样更好的显示
xbar &amp;lt;- tapply(folate,ventilation,mean)
s &amp;lt;- tapply(folate,ventilation,sd)
n &amp;lt;- tapply(folate,ventilation,length)
#对于juul数据集来说，希望求按tanner对igfl分组后的均值
#但是又遇到了缺失值的问题
tapply(igf1,tanner,mean)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Ⅰ  Ⅱ  Ⅲ  Ⅳ  Ⅴ 
## NA NA NA NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以用na.rm排除缺失值
tapply(igf1,tanner,mean,na.rm=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        Ⅰ        Ⅱ        Ⅲ        Ⅳ        Ⅴ 
## 207.4727 352.6714 483.2222 513.0172 465.3344&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#函数aggregate和by是同一个主题的变形。
#前者非常类似于tapply，只是它对整个数据集操作并把结果作为一个数据框显示
#同时显示多个变量是很有用的
aggregate(juul[c(&amp;quot;age&amp;quot;,&amp;quot;igf1&amp;quot;)],
         list(sex=juul$sex),mean,na.rm=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex      age     igf1
## 1   M 15.38436 310.8866
## 2   F 14.84363 368.1006&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#索引变量不是数据框中必须被汇总的部分，没有像在subset中进行的“智能评价”尝试
#所以必须拼出juul$sex
#也可以使用数据框类似于列表的事实
#技巧是使用单引号索引一个数据框，产生一个座位结果的数据框
aggregate(juul[c(&amp;quot;age&amp;quot;,&amp;quot;igf1&amp;quot;)],juul[&amp;quot;sex&amp;quot;],mean,na.rm=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   sex      age     igf1
## 1   M 15.38436 310.8866
## 2   F 14.84363 368.1006&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#by函数也是类似的，但有所不同
#不同之处在于取整个（子）数据框作为它的变量，所以可以用性别总结juul数据
by(juul, juul[&amp;quot;sex&amp;quot;],summary)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sex: M
##       age        menarche   sex          igf1        tanner   
##  Min.   : 0.17   No  :  0   M:621   Min.   : 29.0   Ⅰ   :291  
##  1st Qu.: 8.85   Yes :  0   F:  0   1st Qu.:176.0   Ⅱ   : 55  
##  Median :12.38   NA&amp;#39;s:621           Median :280.0   Ⅲ   : 34  
##  Mean   :15.38                      Mean   :310.9   Ⅳ   : 41  
##  3rd Qu.:16.77                      3rd Qu.:430.2   Ⅴ   :124  
##  Max.   :83.00                      Max.   :915.0   NA&amp;#39;s: 76  
##                                     NA&amp;#39;s   :145               
##     testvol      
##  Min.   : 1.000  
##  1st Qu.: 1.000  
##  Median : 3.000  
##  Mean   : 7.896  
##  3rd Qu.:15.000  
##  Max.   :30.000  
##  NA&amp;#39;s   :141     
## -------------------------------------------------------- 
## sex: F
##       age        menarche   sex          igf1        tanner   
##  Min.   : 0.25   No  :369   M:  0   Min.   : 25.0   Ⅰ   :224  
##  1st Qu.: 9.30   Yes :335   F:713   1st Qu.:233.0   Ⅱ   : 48  
##  Median :12.80   NA&amp;#39;s:  9           Median :352.0   Ⅲ   : 38  
##  Mean   :14.84                      Mean   :368.1   Ⅳ   : 40  
##  3rd Qu.:16.93                      3rd Qu.:483.0   Ⅴ   :204  
##  Max.   :75.12                      Max.   :914.0   NA&amp;#39;s:159  
##                                     NA&amp;#39;s   :176               
##     testvol   
##  Min.   : NA  
##  1st Qu.: NA  
##  Median : NA  
##  Mean   :NaN  
##  3rd Qu.: NA  
##  Max.   : NA  
##  NA&amp;#39;s   :713&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.4 分组数据作图&lt;/h2&gt;
&lt;p&gt;这一节主要是在同一页为几组数据进行作图。&lt;/p&gt;
&lt;div id=&#34;-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.4.1 直方图&lt;/h3&gt;
&lt;p&gt;这个例子使用1.2.14节的关于两组妇女24 h能量消耗的energy数据集，选择了0.5 MJ的倍数作为分割点。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#先获得数据集
attach(energy)
#分割向量
expend.lean &amp;lt;- expend[stature==&amp;quot;lean&amp;quot;]
expend.obese &amp;lt;- expend[stature==&amp;quot;obese&amp;quot;]
#开始作图
#设置par(mfrow=c(2,1))，从而在一个图中得到两个直方图
par(mfrow=c(2,1))
hist(expend.lean,breaks=10,xlim=c(5,13),ylim=c(0,4),col=&amp;quot;white&amp;quot;)
hist(expend.obese,breaks=10,xlim=c(5,13),ylim=c(0,4),col=&amp;quot;grey&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow=c(1,1))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.4.2 并联箱式图&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建图形
#符号y~x表示用x表达的y
boxplot(expend ~ stature)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以用expend.lean和expend.obese作图
boxplot(expend.lean,expend.obese)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-10-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.4.3 带状图&lt;/h3&gt;
&lt;p&gt;刚刚介绍的箱式图并没有很好的显示“Laurel &amp;amp; Hardy”效应。原因在于一组数据的四分位点内距比另一组大很多，使箱式图变得很胖。使用这么小的分组数据四分位数的确定变得很不准确，因此对原始数据作图可能是更合适的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#mex设置减少行间距，mar减少图形区域周边线的数量
#将这些设置的原始值储存在opar中，用par(opar)重新调出
opar &amp;lt;- par(mfrow=c(2,1),mex=0.8,mar=c(3,3,2,1)+.1)
stripchart(expend ~ stature)
stripchart(expend ~ stature,method=&amp;quot;stack&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stripchart(expend ~ stature,method=&amp;quot;jitter&amp;quot;)
stripchart(expend ~ stature,method=&amp;quot;jitter&amp;quot;,jitter=.03)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-11-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(opar)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.5 表格&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.5.1 生产表格&lt;/h3&gt;
&lt;p&gt;本文主要处理双向表格（two-way）。它可以作为一个矩阵对象输入。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#matrix函数中，函数用nrow设置，一般默认是按列输入，byrow=T表示按行输入
#也可以用ncol给出列数
caff.marital &amp;lt;- matrix(c(652,1537,598,242,36,46,38,21,218,327,106,67),
                       nrow=3, byrow=T)
caff.marital&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]  652 1537  598  242
## [2,]   36   46   38   21
## [3,]  218  327  106   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#若ncol和nrow中的一个被给出，那么R将计算相应的那个，从而与输入的值的数目相匹配
#若都给出，但是与值得数目不匹配，那么，值将被循环使用
colnames(caff.marital) &amp;lt;- c(&amp;quot;0&amp;quot;,&amp;quot;1-150&amp;quot;,&amp;quot;151-300&amp;quot;,&amp;quot;&amp;gt;300&amp;quot;)
rownames(caff.marital) &amp;lt;- c(&amp;quot;Married&amp;quot;,&amp;quot;Prev.married&amp;quot;,&amp;quot;Single&amp;quot;)
caff.marital&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                0 1-150 151-300 &amp;gt;300
## Married      652  1537     598  242
## Prev.married  36    46      38   21
## Single       218   327     106   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#此外，也可以如下命名行和列的名称
names(dimnames(caff.marital)) &amp;lt;- c(&amp;quot;martial&amp;quot;,&amp;quot;consumption&amp;quot;)
caff.marital&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               consumption
## martial          0 1-150 151-300 &amp;gt;300
##   Married      652  1537     598  242
##   Prev.married  36    46      38   21
##   Single       218   327     106   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#一般来说，可以在需要两维表格的地方可以用矩阵
#在确实需要表格的时候可以用as.table
as.data.frame(as.table(caff.marital))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         martial consumption Freq
## 1       Married           0  652
## 2  Prev.married           0   36
## 3        Single           0  218
## 4       Married       1-150 1537
## 5  Prev.married       1-150   46
## 6        Single       1-150  327
## 7       Married     151-300  598
## 8  Prev.married     151-300   38
## 9        Single     151-300  106
## 10      Married        &amp;gt;300  242
## 11 Prev.married        &amp;gt;300   21
## 12       Single        &amp;gt;300   67&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#在实际中，更常见的情形是对一个数据集中的每一个人，都有一个带变量的数据框
#这时可以用table，xtabs或ftable做一个表列
attach(juul)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from juul (pos = 5):
## 
##     age, igf1, menarche, sex, tanner, testvol&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(sex)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sex
##   M   F 
## 621 713&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(sex,menarche)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    menarche
## sex  No Yes
##   M   0   0
##   F 369 335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table(menarche,tanner)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         tanner
## menarche   Ⅰ   Ⅱ   Ⅲ   Ⅳ   Ⅴ
##      No  221  43  32  14   2
##      Yes   1   1   5  26 202&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#xtabs类似于table，只不过它使用模型公式借口
#最常用的是一个单边公式，只要列出分类变量，用+分割
xtabs(~tanner + sex, data=juul)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       sex
## tanner   M   F
##      Ⅰ 291 224
##      Ⅱ  55  48
##      Ⅲ  34  38
##      Ⅳ  41  40
##      Ⅴ 124 204&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#从table或xtabs得到的多向量表形式并不是很好
xtabs(~dgn + diab + coma, data=stroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## , , coma = No
## 
##      diab
## dgn    No Yes
##   ICH  53   6
##   ID  143  21
##   INF 411  64
##   SAH  38   0
## 
## , , coma = Yes
## 
##      diab
## dgn    No Yes
##   ICH  19   1
##   ID   23   3
##   INF  23   2
##   SAH   9   0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#当增加维度时，会得到更多的二维子表格，这就是ftable的用武之地
#这个函数创建一个扁平的表格
ftable(coma + diab ~ dgn, data=stroke)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     coma  No     Yes    
##     diab  No Yes  No Yes
## dgn                     
## ICH       53   6  19   1
## ID       143  21  23   3
## INF      411  64  23   2
## SAH       38   0   9   0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以用t函数转置表格，对于多维表格，可以用aperm来转置
t(caff.marital)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            martial
## consumption Married Prev.married Single
##     0           652           36    218
##     1-150      1537           46    327
##     151-300     598           38    106
##     &amp;gt;300        242           21     67&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.5.2 边际表格和相对频数&lt;/h3&gt;
&lt;p&gt;经常会需要计算边际表格，即沿着表格的一个或另一个维度求和。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#首先生成表格
#tanner.sex是为一个交叉表任意选取的名称
tanner.sex &amp;lt;- table(tanner,sex)
tanner.sex&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       sex
## tanner   M   F
##      Ⅰ 291 224
##      Ⅱ  55  48
##      Ⅲ  34  38
##      Ⅳ  41  40
##      Ⅴ 124 204&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#然后计算边际表格
#margin.table中的参数1和2分别表示按行或按列进行求和
margin.table(tanner.sex,1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## tanner
##   Ⅰ   Ⅱ   Ⅲ   Ⅳ   Ⅴ 
## 515 103  72  81 328&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;margin.table(tanner.sex,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sex
##   M   F 
## 545 554&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#相对频数的表格可以用prop.table构建，参数1表示按行
prop.table(tanner.sex,1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       sex
## tanner         M         F
##      Ⅰ 0.5650485 0.4349515
##      Ⅱ 0.5339806 0.4660194
##      Ⅲ 0.4722222 0.5277778
##      Ⅳ 0.5061728 0.4938272
##      Ⅴ 0.3780488 0.6219512&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.6 表格的图形显示&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.6.1 条形图&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total.caff &amp;lt;- margin.table(caff.marital,2)
total.caff&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## consumption
##       0   1-150 151-300    &amp;gt;300 
##     906    1910     742     330&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;barplot(total.caff, col=&amp;quot;white&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-14-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果要创建的对象是一个矩阵，那么barplot将默认创建一个堆积条形图
#其中列根据表中不同行的贡献而被分割，beside=T表示把行的贡献放在旁边
par(mfrow=c(2,2))
barplot(caff.marital, col=&amp;quot;white&amp;quot;)
barplot(t(caff.marital), col=&amp;quot;white&amp;quot;)
barplot(t(caff.marital), col=&amp;quot;white&amp;quot;,beside=T)
barplot(prop.table(t(caff.marital),2),col=&amp;quot;white&amp;quot;,beside=T)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-14-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;par(mfrow=c(1,1))
#可以美化一下
barplot(prop.table(t(caff.marital),2),beside=T,
       legend.text=colnames(caff.marital),
       col=c(&amp;quot;white&amp;quot;,&amp;quot;grey80&amp;quot;,&amp;quot;grey50&amp;quot;,&amp;quot;black&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-14-3.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.6.2 点图&lt;/h3&gt;
&lt;p&gt;Cleveland点图，可以用来同时从两侧研究一个表格。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dotchart(t(caff.marital), lcolor=&amp;quot;black&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-15-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.6.3 饼图&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;opar &amp;lt;- par(mfrow=c(2,2),mex=0.8,mar=c(1,1,2,1))
slices &amp;lt;- c(&amp;quot;white&amp;quot;,&amp;quot;grey80&amp;quot;,&amp;quot;grey50&amp;quot;,&amp;quot;black&amp;quot;)
pie(caff.marital[&amp;quot;Married&amp;quot;,],main=&amp;quot;Married&amp;quot;,col=slices)
pie(caff.marital[&amp;quot;Prev.married&amp;quot;,],
   main=&amp;quot;Previously married&amp;quot;,col=slices)
pie(caff.marital[&amp;quot;Single&amp;quot;,],main=&amp;quot;Single&amp;quot;,col=slices)
par(opar)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-28-r语言统计入门-第四章_files/figure-html/unnamed-chunk-16-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;4.7 思考题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;探索不同类型的线和点图的可能性。变化图形的符号、线型、线宽和颜色。&lt;/li&gt;
&lt;li&gt;如果用标定的线和点绘制一个图形，比如plot(rnorm(10),type=“o”)，线将在画图符号内课件，怎样避免这一点。&lt;/li&gt;
&lt;li&gt;怎样把两个qqnorm图放在同一绘图区域，若试着用type=“1”生成一幅图，将出现什么错误，怎样避免。&lt;/li&gt;
&lt;li&gt;对react数据集画直方图。由于这些数据高度分散化，所以直方图会是有偏的。为什么。也许会希望用MASS包中的truehist作为替代。&lt;/li&gt;
&lt;li&gt;从均匀分布中生成有5个随机数的一个样本向量z，作为x的函数绘制quantile(z,x)（比如可以用curve）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第三章</title>
      <link>/post/2018-02-27-r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0/</link>
      <pubDate>Tue, 27 Feb 2018 19:21:41 +0000</pubDate>
      <guid>/post/2018-02-27-r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%89%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第三章 概率与分布&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.1 随机抽样&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#在R中，如果想进行随机抽样，比如从1-40中随机抽取5个数字
#sample函数中，第一个参数1:40表示被抽样的值向量
#第二个参数5是抽样大小
sample(1:40,5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37 16 30 21 18&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#值得注意的是，sample函数默认是无放回抽样
#如果想进行有放回抽样，需要加上参数replace=TRUE
#有放回抽样适用于投硬币或掷骰子模型
#比如模拟10次投硬币
sample(c(&amp;quot;H&amp;quot;,&amp;quot;T&amp;quot;),10,replace=T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;H&amp;quot; &amp;quot;H&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;H&amp;quot; &amp;quot;H&amp;quot; &amp;quot;T&amp;quot; &amp;quot;T&amp;quot; &amp;quot;H&amp;quot; &amp;quot;H&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以用prob参数来模拟那种结果具有不相等概率的数据
#比如成功的几率是90%
sample(c(&amp;quot;succ&amp;quot;,&amp;quot;fail&amp;quot;),10,replace=T,prob=c(0.9,0.1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;fail&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot; &amp;quot;succ&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.2 概率计算与排列组合&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#使用prod函数，进行连乘
#比如36×37×38×39×40
prod(40:36)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 78960960&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果这是一种类似于乐透彩票的游戏，需要正确猜对5个数字
#第一个数字有5种可能，第二个有4种可能，以此类推
#那么赢奖的概率为
prod(5:1)/prod(40:36)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.519738e-06&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#计算从40个数字中选取5个的所有可能
#可以用choose函数
choose(40,5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 658008&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#那么概率即为
1/choose(40,5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.519738e-06&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.3 离散分布&lt;/h2&gt;
&lt;p&gt; 当观察一个独立重复二项实验时，通常对每次实验的成功或失败并不感兴趣，更感兴趣的是成功或失败的总数。显然，这个总数是随机的，因为它依赖于每一次随机结果，因此被称为随机变量。&lt;/p&gt;
&lt;p&gt; 它是一个可以取值0,1,2,3，……，n的离散值的随机变量。&lt;/p&gt;
&lt;p&gt; 随机变量&lt;span class=&#34;math display&#34;&gt;\[X\]&lt;/span&gt;具有概率分布，可以用点概率&lt;span class=&#34;math display&#34;&gt;\[f(x)=P(X=x)\]&lt;/span&gt;或累计分布函数&lt;span class=&#34;math display&#34;&gt;\[F(x)=P(X=x)\]&lt;/span&gt;描述。在上述二项分布情形下，分布可以用点概率来得到： &lt;span class=&#34;math display&#34;&gt;\[
f(x)=(\begin{matrix}
n\\
x\\
\end{matrix})p^x(1-p)^{n-x}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 其中 &lt;span class=&#34;math display&#34;&gt;\[
(\begin{matrix}
n\\
x\\
\end{matrix})
\]&lt;/span&gt;  被称为二项系数。参数&lt;em&gt;P&lt;/em&gt;是一次独立实验中成功地概率。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.4 连续分布&lt;/h2&gt;
&lt;p&gt; 有些数据来自于对实质连续尺度的测量，比如温度什么的。这种测量通常包含随机变化的因素，这使得测量很难被完全重复。然而，这种随机波动会遵循某种模式：它会集中在某个中心值附近，大的偏差比小的要少得多。&lt;/p&gt;
&lt;p&gt; 为了连续数据建模，需要定义能包含任意实数值的随机变量。因为有无穷的数字无限接近，任何特定值的概率是0，所以这里没有像离散型随机变量那样的点概率的说法，取而代之的是&lt;strong&gt;密度&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;p&gt; 它是指&lt;em&gt;x&lt;/em&gt;的一个小邻域的无穷小概率除以区域的大小。累计分布函数的定义如前，并且有下面的关系： &lt;span class=&#34;math display&#34;&gt;\[
F(x)=\int_{-\infty}^\infty{f(x)dx}
\]&lt;/span&gt;  在统计理论中有许多常见的分布，可以在R中使用。先看下面几个例子。&lt;/p&gt;
&lt;p&gt; 均匀分布是在一个特定的区间（默认是[0,1]）上有常数密度。&lt;/p&gt;
&lt;p&gt; 正态分布（也成为高斯分布）具有密度： &lt;span class=&#34;math display&#34;&gt;\[
f(x)=\frac{1}{\sqrt{{2\pi\sigma}}}exp(-\frac{(x-\mu)^2}{2\sigma^2})
\]&lt;/span&gt;  依赖于均值&lt;span class=&#34;math display&#34;&gt;\[\mu\]&lt;/span&gt;和标准差&lt;span class=&#34;math display&#34;&gt;\[\sigma\]&lt;/span&gt;。正态分布具有标志性的钟形曲线。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.5 R中的内置分布&lt;/h2&gt;
&lt;p&gt; 与建模和统计检验有关的常用标准分布都已经嵌入到R中，因此可以完全取代传统的统计表格。下面只看一下正态分布和二项分布。&lt;/p&gt;
&lt;p&gt; 对一个统计分布可以计算4项基本内容：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;密度或点概率；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;累计概率分布函数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分位数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;伪随机数&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt; 对R中所有的分布，关于上面列出的4项都对应一个相应的函数，比如对于正态分布，它们分别为dnorm，pnorm，qnorm和rnorm（分别对应密度，概率、分位数和随机数）。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.5.1 密度&lt;/h3&gt;
&lt;p&gt; 连续分布的密度是“得到一个接近&lt;em&gt;x&lt;/em&gt;的值”的相对可能性的度量。在一个特定区间得到一个值得概率是在相应曲线下的面积。&lt;/p&gt;
&lt;p&gt; 离散分布，密度用于点概率——恰好得到&lt;em&gt;x&lt;/em&gt;值得概率。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#对于密度函数，可以如下进行
#函数seq用于产生等距数值，这里是从-4到4，步长为0.1
#type=“l“参数可以使函数在点与点之间划线而不是只画出点。
x &amp;lt;- seq(-4,4,0.1)
plot(x,dnorm(x),type=&amp;quot;l&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-27-r语言统计入门-第三章_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建图形的另外一种方法是用curve
curve(dnorm(x), from=-4, to=4)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-27-r语言统计入门-第三章_files/figure-html/unnamed-chunk-3-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#对于离散分布，变量只能取明确值，更倾向于画针形图
#下面是n=50，p=0.33的二项分布图，type=“h”指定画出针形图
x &amp;lt;- 0:50
plot(x, dbinom(x,size=50, prob=.33),type=&amp;quot;h&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-27-r语言统计入门-第三章_files/figure-html/unnamed-chunk-3-3.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.5.2 累计分布函数&lt;/h3&gt;
&lt;p&gt; 累计分布函数描述的是对一个给定分布小于或等于x的分布的概率。相应R函数按惯例以“p”开头。&lt;/p&gt;
&lt;p&gt; 比如，一种生化指标可以用均值132，标准差13的正态分布描述，而某个患者的该指标为160，则：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1-pnorm(160,mean=132,sd=13)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.01562612&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 另一个典型应用与统计检验有关。考虑简单的符号检验：&lt;/p&gt;
&lt;p&gt; 20个病人每人进行2中治疗（以随机顺序治疗），问治疗A还是治疗B更好。结果表明16人认为A好。问题是这是否能作为A确实更好的充分证据，还是说这个结果也可能只是偶然发生的，即使两种治疗效果同样好。如果两种治疗没有差别，可以认为喜欢A的人数服从n=20，&lt;em&gt;p&lt;/em&gt;=0.5的二项分布。那么所观测到的结果有多少种可能呢，如同在正态分布下，需要一个尾部概率。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pbinom(16,size=20,prob=.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9987116&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 然后用1减去它得到上尾概率，但这是不对的。我们需要的是观测到的或更极端的概率，pbinom给出了16或更少数量的概率。此处用“15或更少”来代替：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1-pbinom(15,size=20,prob=.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.005908966&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 如果因为没有关于哪种治疗方法更好的假设，而希望进行双侧检验，那么必须加上得到在另一侧同样极端结果的概率。这意味着4个或更少的人喜欢A的概率。下面给出总的概率：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;1-pbinom(15,20,.5)+pbinom(4,20,.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.01181793&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.5.3 分位数&lt;/h3&gt;
&lt;p&gt; 分位数函数是累计分布函数的反函数。具有这样的性质：得到小于等于它的概率为&lt;em&gt;p&lt;/em&gt;。根据定义，中位数即50%分位数。&lt;/p&gt;
&lt;p&gt; 理论分位数通常用于置信区间的计算，以及与设计试验有关的势函数的计算。下面给出一个置信区间计算的简单例子。&lt;/p&gt;
&lt;p&gt; 如果有来自具有共同均值μ和标准差σ的正态分布的n个观测，均值&lt;span class=&#34;math display&#34;&gt;\[ \overline{X}\]&lt;/span&gt;服从均值为&lt;span class=&#34;math display&#34;&gt;\[\mu\]&lt;/span&gt;、标准差为&lt;span class=&#34;math display&#34;&gt;\[\sigma/\sqrt{n}\]&lt;/span&gt;的正态分布，&lt;span class=&#34;math display&#34;&gt;\[\mu\]&lt;/span&gt;的95%置信区间为： &lt;span class=&#34;math display&#34;&gt;\[
\overline{x}+\sigma/\sqrt{n}\times N_{0.025}\leq\mu\leq\overline{x}+\sigma/\sqrt{n}\times N_{0.025}
\]&lt;/span&gt;  其中&lt;span class=&#34;math display&#34;&gt;\[N_{0.025}\]&lt;/span&gt;是正态分布的2.5%分位数。如果&lt;span class=&#34;math display&#34;&gt;\[\sigma=12\]&lt;/span&gt;，观测了&lt;span class=&#34;math display&#34;&gt;\[n=5\]&lt;/span&gt;个人，得到均值&lt;span class=&#34;math display&#34;&gt;\[\overline{x}=83\]&lt;/span&gt;，那么可以计算相关分位数如下：（sem表示standard error of the mean）&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xbar &amp;lt;- 83
sigma &amp;lt;- 12
n &amp;lt;- 5
sem &amp;lt;- sigma/sqrt(n)
sem&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.366563&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xbar + sem + qnorm(0.025)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 86.4066&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xbar + sem + qnorm(0.975)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 90.32653&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; 因此得到了一个&lt;span class=&#34;math display&#34;&gt;\[\mu\]&lt;/span&gt;的置信度为95%的置信区间，从72.48到93.52。&lt;/p&gt;
&lt;p&gt; 由于正态分布是对称的，所以有&lt;span class=&#34;math display&#34;&gt;\[N_{0.025}=-N_{0.975}\]&lt;/span&gt;，通常把置信区间公式写成&lt;span class=&#34;math display&#34;&gt;\[\overline{x}\pm\sigma/\sqrt{n}\times N_{0.975}\]&lt;/span&gt;。这个分位数通常被记为&lt;span class=&#34;math display&#34;&gt;\[\Phi^{-1}(0.975)\]&lt;/span&gt;。此处&lt;span class=&#34;math display&#34;&gt;\[\Phi\]&lt;/span&gt;是标准正态分布（pnorm）函数的标准符号。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;3.5.4 随机数字&lt;/h3&gt;
&lt;p&gt; 使用随机数产生函数非常简单。第一个参数指定用于计算的随机数的数量，后续参数类似于其他与相同分布有关的函数中相应位置的参数，例如：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0.04684732 -0.02948123 -0.75005173 -0.56389955  0.19080283
##  [6] -0.61748503  2.71935500  0.20708539  0.40252155  0.17880460&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] -0.08673014 -1.43452132  0.79059235 -0.44031861  0.99937695
##  [6]  0.43162762  0.44075596 -1.40122629  2.15570131  0.36923848&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(10,mean=7,sd=5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.9246116  8.4571563  5.2999963  1.2818234  9.7980067 -1.9064289
##  [7] 13.5556810  3.3486614  6.5230462  0.3127788&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rbinom(10,size=20,prob=.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  7 10  6  7  9 11  7 12  9 12&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第二章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</link>
      <pubDate>Sat, 17 Feb 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;2-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第2章 R语言环境&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.1 会话管理&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1.1 工作空间窗口&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#用ls()命令了解都哪些变量定义在工作区
ls()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## character(0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#这样输出有些乱
#可以通过rm()命令来删除某些对象
rm(height,weight)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in rm(height, weight): 找不到对象&amp;#39;height&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in rm(height, weight): 找不到对象&amp;#39;weight&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1.6 内置数据&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#加载数据thuesen
data(thuesen)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning in data(thuesen): data set &amp;#39;thuesen&amp;#39; not found&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#需要注意的是thuesen这个数据框隶属于ISwR数据
#要加载thuesen，需要先加载ISwR
library(ISwR)
data(thuesen)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;attachdetach&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1.7 attach和detach&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果要重复写一些很长的命令，在数据集中获取变量的符号很很麻烦
#比如
plot(thuesen$blood.glucose,thuesen$short.velocity)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-17-r语言统计入门-第二章_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#但可以简化
#可以让R在给定数据集的变量中寻找目标
attach(thuesen)
#然后thuesen中的数据就可以得到，而不需要使用$符号
blood.glucose&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 15.3 10.8  8.1 19.5  7.2  5.3  9.3 11.1  7.5 12.2  6.7  5.2 19.0 15.1
## [15]  6.7  8.6  4.2 10.3 12.5 16.1 13.3  4.9  8.8  9.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#上述命令使thuesen被置于系统的搜索路径中
#可以用search()看到搜索路径
#可以看到thuesen被置于搜索路径的第二位
#.GlobalEnv是工作空间
#package:base是定义了所有标准函数的系统库
search()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;.GlobalEnv&amp;quot;        &amp;quot;thuesen&amp;quot;           &amp;quot;package:ISwR&amp;quot;     
##  [4] &amp;quot;package:methods&amp;quot;   &amp;quot;package:stats&amp;quot;     &amp;quot;package:graphics&amp;quot; 
##  [7] &amp;quot;package:grDevices&amp;quot; &amp;quot;package:utils&amp;quot;     &amp;quot;package:datasets&amp;quot; 
## [10] &amp;quot;Autoloads&amp;quot;         &amp;quot;package:base&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以用detach命令从搜索路径中删除数据集
#如果不给出参数，那么位于第二位置的数据集将被删除
detach()
search()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;.GlobalEnv&amp;quot;        &amp;quot;package:ISwR&amp;quot;      &amp;quot;package:methods&amp;quot;  
##  [4] &amp;quot;package:stats&amp;quot;     &amp;quot;package:graphics&amp;quot;  &amp;quot;package:grDevices&amp;quot;
##  [7] &amp;quot;package:utils&amp;quot;     &amp;quot;package:datasets&amp;quot;  &amp;quot;Autoloads&amp;quot;        
## [10] &amp;quot;package:base&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;subsettransformwithin&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1.8 subset，transform和within&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以附加一个数据框，从而避免对其中每一个变量的繁琐的索引
#然而，这对于选择数据子集以及用变化变量创建新的数据框却少有帮助
#有一些函数使得这一操作变得简单，如：
#在此处用到subset和transform函数，这里只利用这两个函数的简单功能
#subset函数，从某一个数据框中选择出符合某条件的数据或是相关的列
#transform函数为原数据框添加新的列
thue2 &amp;lt;- subset(thuesen, blood.glucose&amp;lt;7)
thue2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    blood.glucose short.velocity
## 6            5.3           1.49
## 11           6.7           1.25
## 12           5.2           1.19
## 15           6.7           1.52
## 17           4.2           1.12
## 22           4.9           1.03&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#transform函数中的=符号并不是赋值，而是表示名称
thue3 &amp;lt;- transform(thuesen,log.gluc=log(blood.glucose))
thue3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    blood.glucose short.velocity log.gluc
## 1           15.3           1.76 2.727853
## 2           10.8           1.34 2.379546
## 3            8.1           1.27 2.091864
## 4           19.5           1.47 2.970414
## 5            7.2           1.27 1.974081
## 6            5.3           1.49 1.667707
## 7            9.3           1.31 2.230014
## 8           11.1           1.09 2.406945
## 9            7.5           1.18 2.014903
## 10          12.2           1.22 2.501436
## 11           6.7           1.25 1.902108
## 12           5.2           1.19 1.648659
## 13          19.0           1.95 2.944439
## 14          15.1           1.28 2.714695
## 15           6.7           1.52 1.902108
## 16           8.6             NA 2.151762
## 17           4.2           1.12 1.435085
## 18          10.3           1.37 2.332144
## 19          12.5           1.19 2.525729
## 20          16.1           1.05 2.778819
## 21          13.3           1.32 2.587764
## 22           4.9           1.03 1.589235
## 23           8.8           1.12 2.174752
## 24           9.5           1.70 2.251292&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#transform函数的替代方法有一种是within函数，用法如下：
thue4 &amp;lt;- within(thuesen,{
  log.gluc &amp;lt;- log(blood.glucose)
  m &amp;lt;- mean(log.gluc)
  centered.log.gluc &amp;lt;- log.gluc - m
  rm(m)
})
thue4&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    blood.glucose short.velocity centered.log.gluc log.gluc
## 1           15.3           1.76       0.481879807 2.727853
## 2           10.8           1.34       0.133573113 2.379546
## 3            8.1           1.27      -0.154108960 2.091864
## 4           19.5           1.47       0.724441444 2.970414
## 5            7.2           1.27      -0.271891996 1.974081
## 6            5.3           1.49      -0.578266201 1.667707
## 7            9.3           1.31      -0.015958621 2.230014
## 8           11.1           1.09       0.160972087 2.406945
## 9            7.5           1.18      -0.231070001 2.014903
## 10          12.2           1.22       0.255462930 2.501436
## 11           6.7           1.25      -0.343865495 1.902108
## 12           5.2           1.19      -0.597314396 1.648659
## 13          19.0           1.95       0.698465958 2.944439
## 14          15.1           1.28       0.468721722 2.714695
## 15           6.7           1.52      -0.343865495 1.902108
## 16           8.6             NA      -0.094210818 2.151762
## 17           4.2           1.12      -0.810888496 1.435085
## 18          10.3           1.37       0.086170874 2.332144
## 19          12.5           1.19       0.279755623 2.525729
## 20          16.1           1.05       0.532846250 2.778819
## 21          13.3           1.32       0.341791014 2.587764
## 22           4.9           1.03      -0.656737817 1.589235
## 23           8.8           1.12      -0.071221300 2.174752
## 24           9.5           1.70       0.005318777 2.251292&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2 作图系统&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.1 图形布局&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x &amp;lt;- runif(50, 0, 2)
y &amp;lt;- runif(50, 0, 2)
plot(x, y, main = &amp;quot;Main title&amp;quot;, sub = &amp;quot;subtitle&amp;quot;,
     xlab = &amp;quot;x-label&amp;quot;, ylab = &amp;quot;y-label&amp;quot;)
#可以在绘图区域放置点和线
#可以在plot函数中设定
#或者用points和lines添加
#也可以添加如下命令
text(0.6, 0.6, &amp;quot;text at (0.6, 0.6)&amp;quot;)
abline(h=.6, v=.6)
#调用abline仅是表明文本如何以点（0.6,0.6）为中心的
#通常，给定a和b后，abline绘制直线y=a+bx
#边界坐标由mtext函数使用
#for循环将数字-1到4放置在每条边界线的0.7位置
for(side in 1:4) mtext(-1:4, side = side, at=.7, line=-1:4)
#接下来的调用在每个边界放置一个标签，给出边的数字，font=2表示使用粗体
mtext(paste(&amp;quot;side&amp;quot;, 1:4), side = 1:4, line = -1, font = 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-17-r语言统计入门-第二章_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.2 利用部分构造图形&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#下面的命令绘制完全空白的图形
#type=&amp;quot;n&amp;quot;使得点不被绘制，axes=F删掉坐标轴以及图周围的方框
#x，y的标题标签被设置成空字符串
plot(x, y, type = &amp;quot;n&amp;quot;, xlab = &amp;quot;&amp;quot;, ylab = &amp;quot;&amp;quot;, axes = F)
#添加图形元素
#第二个axis调用如何制定了小十字符（和标签）的替换
points(x,y)
axis(1)
axis(2, at=seq(0.2, 1.8, 0.2))
box()
title(main = &amp;quot;Main title&amp;quot;, sub = &amp;quot;subtitle&amp;quot;,
      xlab = &amp;quot;x-label&amp;quot;, ylab = &amp;quot;y-label&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-17-r语言统计入门-第二章_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;par&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.3 par的使用&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;par函数可以对图的细节进行非常精细的控制&lt;/li&gt;
&lt;li&gt;par设置润徐控制线宽和类型、字符大小和字体、颜色、坐标轴的类型、图形图标区域的大小、图形的裁剪等&lt;/li&gt;
&lt;li&gt;利用mfrow和mfcol参数可以把一个图分成几个子图&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2.4 组合图形&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果希望把一个元素一起放在同一张图的时候，就会产生一些特殊的要求
#比如，为直方图添加一个正态密度函数
#hist中的freq=F参数保证了直方图是根据比例而不是绝对数值画出来的
#curve函数画出一个表达式（根据x），add=T润徐它叠加到已有的图上
#但这样的还不够好
x &amp;lt;- rnorm(100)
hist(x, freq = F)
curve(dnorm(x), add = T)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-17-r语言统计入门-第二章_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#解决方案
#首先确定两个图形元素的y值的大小，然后使图形足够大到涵盖这两个值
h &amp;lt;- hist(x, plot = F)
ylim &amp;lt;- range(0, h$density, dnorm(0))
hist(x, freq = F, ylim = ylim)
curve(dnorm(x), add = T)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-17-r语言统计入门-第二章_files/figure-html/unnamed-chunk-7-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R语言统计入门-第一章</title>
      <link>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%80%E7%AB%A0/</link>
      <pubDate>Wed, 14 Feb 2018 00:00:00 +0000</pubDate>
      <guid>/post/r%E8%AF%AD%E8%A8%80%E7%BB%9F%E8%AE%A1%E5%85%A5%E9%97%A8-%E7%AC%AC%E4%B8%80%E7%AB%A0/</guid>
      <description>


&lt;div id=&#34;1-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第1章 基础知识&lt;/h1&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.1 初始步骤&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ISwR)
#随机抽取1000个符合正态分布的随机数
plot(rnorm(1000))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-14-r语言统计入门-第一章_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1.3 向量运算&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#构建向量
weight &amp;lt;- c(60,72,57,90,95,72)
weight&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 60 72 57 90 95 72&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;height &amp;lt;- c(1.75,1.80,1.65,1.90,1.74,1.91)
#计算BMI
bmi &amp;lt;- weight/height^2
bmi&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 19.59184 22.22222 20.93664 24.93075 31.37799 19.73630&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#计算均值
xbar &amp;lt;- sum(weight)/length(weight)
#计算偏差及其平方及偏差平方和
weight - xbar&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -14.333333  -2.333333 -17.333333  15.666667  20.666667  -2.333333&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(weight - xbar)^2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 205.444444   5.444444 300.444444 245.444444 427.111111   5.444444&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum((weight - xbar)^2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1189.333&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#标准差
sqrt(sum((weight - xbar)^2)/(length(weight)-1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 15.42293&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#其实已经有函数
mean(weight)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 74.33333&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sd(weight)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 15.42293&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1.4 标准过程&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#单样本t检验，参数mu代表希腊字母μ，表示理论均值，若没有给定，则默认mu=0
t.test(bmi, mu=22.5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  One Sample t-test
## 
## data:  bmi
## t = 0.34488, df = 5, p-value = 0.7442
## alternative hypothesis: true mean is not equal to 22.5
## 95 percent confidence interval:
##  18.41734 27.84791
## sample estimates:
## mean of x 
##  23.13262&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1.5 作图&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#若研究体重与身高的关系，第一想法就是作图
plot(height, weight)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-14-r语言统计入门-第一章_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#用pch参数修改绘图符号,pch=2为三角形
plot(height, weight,pch=2)
#在图中叠加一个基于BMI为22.5的体重估计曲线
hh &amp;lt;- c(1.65,1.70,1.75,1.80,1.85,1.90)
lines(hh, 22.5*hh^2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../post/2018-02-14-r语言统计入门-第一章_files/figure-html/unnamed-chunk-4-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.2 R语言基础&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.3 向量&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#字符向量
c(&amp;quot;Huey&amp;quot;,&amp;quot;Dewey&amp;quot;,&amp;quot;Louie&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Huey&amp;quot;  &amp;quot;Dewey&amp;quot; &amp;quot;Louie&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#单引号或双引号都可以
c(&amp;#39;Huey&amp;#39;,&amp;#39;Dewey&amp;#39;,&amp;#39;louie&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Huey&amp;quot;  &amp;quot;Dewey&amp;quot; &amp;quot;louie&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.4 引用和转义序列&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#输出一个不带引号的字符串，用cat函数
cat(c(&amp;quot;Huey&amp;quot;,&amp;quot;Dewey&amp;quot;,&amp;quot;Louie&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Huey Dewey Louie&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#反斜杠\被称为转移字符。可用\&amp;quot;方式插入引用字符
cat(&amp;quot;What is \&amp;quot;R\&amp;quot; ?\n&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## What is &amp;quot;R&amp;quot; ?&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.6 生成向量的函数&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#c()函数，含义是把各分项首尾连接
c(42,57,12,39,1,3,4)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 42 57 12 39  1  3  4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以用于连接多于一个元素的向量
x &amp;lt;- c(1,2,3)
y &amp;lt;- c(10,20)
c(x, y, 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  1  2  3 10 20  5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以给某些元素明明
x &amp;lt;- c(red=&amp;quot;Huey&amp;quot;,blue=&amp;quot;Dewey&amp;quot;,green=&amp;quot;Louie&amp;quot;)
#seq()函数，用于建立数字等差序列
seq(4,9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#若间距为2
seq(4,10,2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  4  6  8 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#rep()函数，用来产生重复值
#使用时有两个参数，依赖于第二个参数是想量还是数字，产生的结果也不一样
opps &amp;lt;- c(7,9,13)
rep(opps,3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  7  9 13  7  9 13  7  9 13&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rep(opps,1:3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  7  9  9 13 13 13&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.7 矩阵和数组&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#用dim()函数设置或改变x的维度
#将一个12个数字的向量改为3*4矩阵
#值得注意的是。矩阵的存储是以列为主，即第二列元素跟在第一列元素后面
x &amp;lt;- 1:12
dim(x) &amp;lt;- c(3,4)
#还可用matrix()函数创建矩阵，byrow=T是将矩阵改成以按行而不是按列形式填充
matrix(1:12, nrow = 3, byrow = T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#给行命名
#LETTERS[]特征向量是一个包含大写字母A-Z的内置变量
rownames(x) &amp;lt;- LETTERS[1:3]
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [,1] [,2] [,3] [,4]
## A    1    4    7   10
## B    2    5    8   11
## C    3    6    9   12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#给列命名
colnames(x) &amp;lt;- LETTERS[4:7]
x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   D E F  G
## A 1 4 7 10
## B 2 5 8 11
## C 3 6 9 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#将x转置
t(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    A  B  C
## D  1  2  3
## E  4  5  6
## F  7  8  9
## G 10 11 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以按行或按列分别采用cbind和rbind函数将向量粘在一起
cbind(A=1:4,B=5:8,C=9:12)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      A B  C
## [1,] 1 5  9
## [2,] 2 6 10
## [3,] 3 7 11
## [4,] 4 8 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rbind(A=1:4,B=5:8,C=9:12)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [,1] [,2] [,3] [,4]
## A    1    2    3    4
## B    5    6    7    8
## C    9   10   11   12&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.8 因子&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建数值向量pain，对五个病人的疼痛水平编码
pain &amp;lt;- c(0,3,2,2,1)
#希望把它作为一个分类变量处理
#利用函数factor创建一个因子fpain
#这个函数除了调用pain之外，还有参数levels=0:3，意味着输入的编码使用了3个值0~3
#这个参数可以省略，R默认使用pain中合理排序的值
fpain &amp;lt;- factor(pain,levels = 0:3)
#将水平名称转换为特定的4个字符串
levels(fpain) &amp;lt;- c(&amp;quot;none&amp;quot;,&amp;quot;mild&amp;quot;,&amp;quot;medium&amp;quot;,&amp;quot;severe&amp;quot;)
fpain&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] none   severe medium medium mild  
## Levels: none mild medium severe&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.9 列表&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建11个妇女月经前后能量摄入的向量
intake.pre &amp;lt;- c(5260,5470,5640,6180,6390,6515,6805,7515,7515,8230,8770)
intake.post &amp;lt;- c(3910,4220,3885,5160,5645,4680,5265,5975,6790,6900,7335)
#把单独向量组合成一个列表
mylist &amp;lt;- list(before= intake.pre,after=intake.post)
mylist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $before
##  [1] 5260 5470 5640 6180 6390 6515 6805 7515 7515 8230 8770
## 
## $after
##  [1] 3910 4220 3885 5160 5645 4680 5265 5975 6790 6900 7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#列表各部分通过list中使用的参数名称来命名
mylist$before&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 5260 5470 5640 6180 6390 6515 6805 7515 7515 8230 8770&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.10 数据框&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#创建数据框，注意数据是成对的
d &amp;lt;- data.frame(intake.pre,intake.post)
d&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    intake.pre intake.post
## 1        5260        3910
## 2        5470        4220
## 3        5640        3885
## 4        6180        5160
## 5        6390        5645
## 6        6515        4680
## 7        6805        5265
## 8        7515        5975
## 9        7515        6790
## 10       8230        6900
## 11       8770        7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以通过$符号获得
d$intake.pre&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 5260 5470 5640 6180 6390 6515 6805 7515 7515 8230 8770&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.11 索引&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#如果需要向量的摸一个具体元素，可以这样
#这个方括号就是索引
intake.pre[5]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6390&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可创建一个包含多于一个数据的子向量
intake.pre[c(3,5,7)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5640 6390 6805&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#注意里面的c(3,5,7)是必要的。像下面的就不一样了
#intake.pre[3,5,7]
#负索引，即引用除了某些位置之外的所有元素
intake.pre[-c(3,5,7)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5260 5470 6180 6515 7515 7515 8230 8770&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.12 条件选择&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#可以通过一个关系表达式选择一些满足某种标准的数据
intake.post[intake.pre &amp;gt; 7000]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5975 6790 6900 7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#寻找经前摄入7000-8000 kj的妇女，停经后的能量摄入
intake.post[intake.pre &amp;gt; 7000 &amp;amp; intake.pre &amp;lt;8000]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5975 6790&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.13 数据框的索引&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;d &amp;lt;- data.frame(intake.pre,intake.post)
#寻找第5行。第1列的数据
d[5,1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 6390&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#寻找第5位妇女的所有数据，注意里面的逗号是必要的，若没有则表示d的第二列构成的数据框
d[5,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   intake.pre intake.post
## 5       6390        5645&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查找停经前能量摄入超过70000 kj的妇女
d[d$intake.pre &amp;gt; 7000,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    intake.pre intake.post
## 8        7515        5975
## 9        7515        6790
## 10       8230        6900
## 11       8770        7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#查看d中前几个数据
d[1:2,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   intake.pre intake.post
## 1       5260        3910
## 2       5470        4220&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#函数head()默认显示前六行
head(d)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   intake.pre intake.post
## 1       5260        3910
## 2       5470        4220
## 3       5640        3885
## 4       6180        5160
## 5       6390        5645
## 6       6515        4680&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.14 分组数据和数据框&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#R内置数据集energy，消瘦和肥胖妇女的能量消耗
energy&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    expend stature
## 1    9.21   obese
## 2    7.53    lean
## 3    7.48    lean
## 4    8.08    lean
## 5    8.09    lean
## 6   10.15    lean
## 7    8.40    lean
## 8   10.88    lean
## 9    6.13    lean
## 10   7.90    lean
## 11  11.51   obese
## 12  12.79   obese
## 13   7.05    lean
## 14  11.85   obese
## 15   9.97   obese
## 16   7.48    lean
## 17   8.79   obese
## 18   9.69   obese
## 19   9.68   obese
## 20   7.58    lean
## 21   9.19   obese
## 22   8.11    lean&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#有时候希望每一组有一个独立的向量来存储数据
exp.lean &amp;lt;- energy$expend[energy$stature == &amp;quot;lean&amp;quot;]
exp.lean&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  7.53  7.48  8.08  8.09 10.15  8.40 10.88  6.13  7.90  7.05  7.48
## [12]  7.58  8.11&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;exp.obese &amp;lt;- energy$expend[energy$stature == &amp;quot;obese&amp;quot;]
exp.obese&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  9.21 11.51 12.79 11.85  9.97  8.79  9.69  9.68  9.19&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#也可以通过split函数，它根据分组生成一系列向量
l &amp;lt;- split(energy$expend, energy$stature)
l&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $lean
##  [1]  7.53  7.48  8.08  8.09 10.15  8.40 10.88  6.13  7.90  7.05  7.48
## [12]  7.58  8.11
## 
## $obese
## [1]  9.21 11.51 12.79 11.85  9.97  8.79  9.69  9.68  9.19&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.15 隐式循环&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#计算数值向量组成的数据框中每个变量的均值
#lapply函数返回一个列表
lapply(thuesen, mean, na.rm =T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $blood.glucose
## [1] 10.3
## 
## $short.velocity
## [1] 1.325652&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#sapply函数尽可能将结果简化成矢量或矩阵
sapply(thuesen, mean, na.rm =T)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  blood.glucose short.velocity 
##      10.300000       1.325652&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#apply函数。可以针对矩阵的行或列（或广义下多维数组的下标）
#对于矩阵而言，apply函数中的参数2，表示按列，若为1，则表示按行，若为c(1,2)则表示行和列
#下面表示按列取最小值
m &amp;lt;- matrix(rnorm(12),4)
apply(m, 2, min)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -1.9068416 -0.7393233 -1.3446173&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2.16 排序&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#使用sort()函数
intake$post&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 3910 4220 3885 5160 5645 4680 5265 5975 6790 6900 7335&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sort(intake$post)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 3885 3910 4220 4680 5160 5265 5645 5975 6790 6900 7335&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
